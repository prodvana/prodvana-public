package main

import (
	"context"
	"encoding/json"
	go_errors "errors"
	"fmt"
	"io/fs"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"

	"github.com/bradenaw/juniper/xslices"
	"github.com/google/go-containerregistry/pkg/name"
	"github.com/hashicorp/go-multierror"
	"github.com/pelletier/go-toml/v2"
	"github.com/pkg/errors"
	application_pb "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/application"
	common_config_pb "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/common_config"
	"github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/environment"
	fly_pb "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/fly"
	organization_pb "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/organization"
	release_channel_pb "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/release_channel"
	"github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/secrets"
	service_pb "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/service"
	"github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/workflow"
	"github.com/spf13/cobra"
	"golang.org/x/exp/maps"
	grpc_codes "google.golang.org/grpc/codes"
	grpc_status "google.golang.org/grpc/status"
)

const (
	flyRegistryUrlNoScheme  = "registry.fly.io"
	dockerhubPublicRegistry = "dockerhub-public"
)

var (
	flyRegistryUrl = fmt.Sprintf("https://%s", flyRegistryUrlNoScheme)
)

var configureFlags = struct {
	flyctlPath  string
	flyRuntime  string
	flyRegistry string
	flyOrg      string
}{}

type flyToml struct {
	App      string           `toml:"app"`
	Prodvana *flyProdvanaToml `toml:"prodvana"`
}

type flyProdvanaToml struct {
	Application   string `toml:"application"`
	Group         string `toml:"group"`
	autogenerated bool
}

type prodvanaServiceAndApp struct {
	application string
	service     string
}

func configureOneApplication(ctx context.Context, appName string, rcs []*release_channel_pb.ReleaseChannelConfig, perRc []*service_pb.PerReleaseChannelConfig, imageInfos []imageInfo) (*prodvanaServiceAndApp, error) {
	if len(imageInfos) > 1 {
		return nil, errors.Errorf("Inconsistent image used. %+v", imageInfos)
	}
	appCfg := &application_pb.ApplicationConfig{
		Name:            appName,
		ReleaseChannels: rcs,
	}
	svcCfg := &service_pb.ServiceConfig{
		Name:              "fly-app",
		PerReleaseChannel: perRc,
	}
	if len(imageInfos) == 1 {
		svcCfg.Parameters = []*common_config_pb.ParameterDefinition{
			{
				Name:        "image",
				Description: "Docker image to deploy",
				Required:    true,
				ConfigOneof: &common_config_pb.ParameterDefinition_DockerImage{
					DockerImage: &common_config_pb.DockerImageParameterDefinition{
						ImageRegistryInfo: &common_config_pb.ImageRegistryInfo{
							ContainerRegistry: imageInfos[0].registryIntegration,
							ImageRepository:   imageInfos[0].repository,
						},
					},
				},
			},
		}
		svcCfg.BundleName = "{{.Params.image.Tag}}"
	}
	validateResp, err := getApplicationManagerClient().ValidateConfigureApplication(ctx, &application_pb.ConfigureApplicationReq{
		ApplicationConfig: appCfg,
	})
	if err != nil {
		return nil, errors.Wrap(err, "failed to validate application")
	}

	_, err = getApplicationManagerClient().ConfigureApplication(ctx, &application_pb.ConfigureApplicationReq{
		ApplicationConfig: appCfg,
		ApprovedDangerousActionIds: xslices.Map(validateResp.DangerousActions, func(action *common_config_pb.DangerousAction) string {
			return action.Id
		}),
	})
	if err != nil {
		return nil, errors.Wrap(err, "failed to configure application")
	}

	_, err = getServiceManagerClient().ConfigureService(ctx, &service_pb.ConfigureServiceReq{
		Application:   appName,
		ServiceConfig: svcCfg,
	})
	if err != nil {
		return nil, errors.Wrap(err, "failed to configure service")
	}
	return &prodvanaServiceAndApp{
		application: appCfg.Name,
		service:     svcCfg.Name,
	}, nil
}

type patchResult struct {
	patched   []byte
	origImage string
}

type notPatchError struct {
	reason string
}

func (e *notPatchError) Error() string {
	return e.reason
}

func maybePatchFlyToml(bytes []byte) (*patchResult, error) {
	var cfg map[string]interface{}
	if err := toml.Unmarshal(bytes, &cfg); err != nil {
		return nil, errors.Wrap(err, "failed to unmarshal Fly configuration")
	}
	build, ok := cfg["build"].(map[string]interface{})
	if !ok {
		return nil, &notPatchError{"no build section"}
	}
	image, ok := build["image"].(string)
	if !ok {
		return nil, &notPatchError{"no build.image not set to a string"}
	}
	build["image"] = "{{.Params.image}}"
	bytes, err := toml.Marshal(cfg)
	if err != nil {
		return nil, errors.Wrap(err, "failed to marshal Fly configuration")
	}
	return &patchResult{
		patched:   bytes,
		origImage: image,
	}, nil
}

// extractImageInfo extracts image registry information from a given image string.
// returns nil if the image info cannot be extracted
func extractImageInfo(image string) (*imageInfo, error) {
	parsed, err := name.ParseReference(image)
	if err != nil {
		return nil, nil
	}
	repository := parsed.Context().RepositoryStr()
	registry := parsed.Context().RegistryStr()
	var registryIntegration string
	switch registry {
	case "index.docker.io":
		registryIntegration = dockerhubPublicRegistry
		if !strings.Contains(repository, "/") {
			repository = "library/" + repository
		}
	case flyRegistryUrlNoScheme:
		registryIntegration = configureFlags.flyRegistry
	default:
		return nil, errors.Errorf("Unsupported registry %s", registry)
	}
	return &imageInfo{
		registryIntegration: registryIntegration,
		repository:          repository,
	}, nil
}

type imageInfo struct {
	registryIntegration string
	repository          string
}

func makeOrgAuthTokenOnce(ctx context.Context, flyOrg string) (string, error) {
	flyCmd := exec.CommandContext(ctx, "fly", "tokens", "create", "org", "--org", flyOrg, "--json", "--name", "Prodvana deploy token")
	flyCmd.Stderr = os.Stderr
	output, err := flyCmd.Output()
	if err != nil {
		return "", errors.Wrap(err, "failed to create fly token")
	}
	var token struct {
		Token string `json:"token"`
	}
	if err := json.Unmarshal(output, &token); err != nil {
		return "", errors.Wrap(err, "failed to unmarshal fly token output")
	}
	return token.Token, nil
}

func makeFlyRuntimeIfNeeded(ctx context.Context, getToken func() (string, error), flyOrg string, runtimeName string) error {
	resp, err := getEnvironmentManagerClient().GetCluster(ctx, &environment.GetClusterReq{
		Runtime: runtimeName,
	})
	if err == nil {
		if resp.Cluster.Config.GetFly() != nil {
			return nil
		}
		return errors.Errorf("Runtime %s already exists but is not a Fly runtime. Please delete it and rerun.", runtimeName)
	} else {
		if grpc_status.Code(err) != grpc_codes.NotFound {
			return err
		}
	}
	token, err := getToken()
	if err != nil {
		return err
	}
	secretKey := fmt.Sprintf("fly-token-%s", flyOrg)
	secretResp, err := getSecretsManagerClient().SetSecret(ctx, &secrets.SetSecretReq{
		Key:   secretKey,
		Value: token,
	})
	if err != nil {
		return errors.Wrap(err, "failed to store fly token")
	}
	_, err = getEnvironmentManagerClient().ConfigureCluster(ctx, &environment.ConfigureClusterReq{
		RuntimeName: runtimeName,
		Config: &environment.ClusterConfig{
			Name: runtimeName,
			ClusterOneof: &environment.ClusterConfig_Fly{
				Fly: &environment.FlyConfig{
					Credentials: &environment.FlyConfig_FlyApiToken{
						FlyApiToken: &common_config_pb.NativeSecretReferenceValue{
							ValueOneof: &common_config_pb.NativeSecretReferenceValue_Secret{
								Secret: &common_config_pb.Secret{
									Key:     secretKey,
									Version: secretResp.Version,
								},
							},
						},
					},
				},
			},
		},
	})
	if err != nil {
		return errors.Wrap(err, "failed to configure runtime")
	}
	log.Printf("Created Fly runtime %s", runtimeName)
	return nil
}

func makeFlyIntegrationIfNeeded(ctx context.Context, getToken func() (string, error), flyRegistry string) error {
	resp, err := getWorkflowManagerClient().GetContainerRegistryIntegration(ctx, &workflow.GetContainerRegistryIntegrationReq{
		RegistryName: flyRegistry,
	})
	if err == nil {
		if resp.Registry.Url == flyRegistryUrl {
			return nil
		}
		return errors.Errorf("Registry %s already exists but is not a Fly registry. Please delete it and rerun.", flyRegistry)
	} else {
		if grpc_status.Code(err) != grpc_codes.NotFound {
			return err
		}
	}
	token, err := getToken()
	if err != nil {
		return err
	}
	_, err = getWorkflowManagerClient().CreateContainerRegistryIntegration(ctx, &workflow.CreateContainerRegistryIntegrationReq{
		Name:     flyRegistry,
		Url:      flyRegistryUrl,
		Username: "x",
		Secret:   token,
		Type:     workflow.RegistryType_DOCKER_REGISTRY,
	})
	return errors.Wrapf(err, "failed to create Fly registry %s", flyRegistry)
}

func setupFlyIntegrations(ctx context.Context, flyOrg, runtimeName, flyRegistry string) error {
	getFlyToken := sync.OnceValues[string, error](func() (string, error) {
		return makeOrgAuthTokenOnce(ctx, flyOrg)
	})
	if err := makeFlyRuntimeIfNeeded(ctx, getFlyToken, flyOrg, runtimeName); err != nil {
		return err
	}
	if err := makeFlyIntegrationIfNeeded(ctx, getFlyToken, flyRegistry); err != nil {
		return err
	}
	return nil
}

var configureCmd = &cobra.Command{
	Use:   "configure",
	Short: "configure [<root directory>]",
	Long:  `Configure Prodvana by looking for Fly Apps in a given directory. Defaults to the root directory.`,
	Args:  cobra.MaximumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		ctx := context.Background()
		var dir string
		if len(args) == 0 {
			var err error
			dir, err = os.Getwd()
			if err != nil {
				return errors.Wrap(err, "failed to get current working directory")
			}
		} else {
			dir = args[0]
		}
		err := setupFlyIntegrations(ctx, configureFlags.flyOrg, configureFlags.flyRuntime, configureFlags.flyRegistry)
		if err != nil {
			return err
		}
		releaseChannels := map[string][]*release_channel_pb.ReleaseChannelConfig{}
		perReleaseChannelConfigs := map[string][]*service_pb.PerReleaseChannelConfig{}
		imageInfos := map[string]map[imageInfo]struct{}{}
		makeReleaseChannelConfig := func(flyCfg *flyToml) (*release_channel_pb.ReleaseChannelConfig, error) {
			cfg := &release_channel_pb.ReleaseChannelConfig{
				Name:  flyCfg.App,
				Group: flyCfg.Prodvana.Group,
				Runtimes: []*release_channel_pb.ReleaseChannelRuntimeConfig{
					{
						Runtime: configureFlags.flyRuntime,
					},
				},
			}
			if flyCfg.Prodvana.Group == "production" && !flyCfg.Prodvana.autogenerated {
				cfg.Preconditions = []*release_channel_pb.Precondition{
					{
						Precondition: &release_channel_pb.Precondition_ReleaseChannelStable_{
							ReleaseChannelStable: &release_channel_pb.Precondition_ReleaseChannelStable{
								StableOneof: &release_channel_pb.Precondition_ReleaseChannelStable_Selector{
									Selector: "@group=staging",
								},
								AllowEmpty: true,
							},
						},
					},
					{
						Precondition: &release_channel_pb.Precondition_ManualApproval_{
							ManualApproval: &release_channel_pb.Precondition_ManualApproval{},
						},
					},
				}
			}
			return cfg, nil
		}
		err = filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
			if err != nil {
				return err
			}
			if d.IsDir() {
				return nil
			}
			if filepath.Ext(path) == ".toml" {
				bytes, err := os.ReadFile(path)
				if err != nil {
					return errors.Wrap(err, "failed to read Fly configuration")
				}
				var cfg flyToml
				if err := toml.Unmarshal(bytes, &cfg); err != nil {
					return errors.Wrap(err, "failed to unmarshal Fly configuration")
				}
				if cfg.App == "" {
					log.Printf("skipping toml %s because it does not look like a fly toml", path)
					return nil
				}
				if cfg.Prodvana == nil {
					cfg.Prodvana = &flyProdvanaToml{
						Application:   cfg.App,
						Group:         "production",
						autogenerated: true,
					}
				}
				switch cfg.Prodvana.Group {
				case "staging", "production":
				default:
					return errors.Errorf("unknown group %s", cfg.Prodvana.Group)
				}
				patched, err := maybePatchFlyToml(bytes)
				var bytesForCfg []byte
				if err != nil {
					var notPatchError *notPatchError
					if !go_errors.As(err, &notPatchError) {
						return err
					}
					log.Printf("did not patch fly toml %s because %s, image parameters will not impact this Fly App", path, notPatchError.reason)
					bytesForCfg = bytes
				} else {
					bytesForCfg = patched.patched
					info, err := extractImageInfo(patched.origImage)
					if err != nil {
						return err
					}
					if info != nil {
						if _, ok := imageInfos[cfg.Prodvana.Application]; !ok {
							imageInfos[cfg.Prodvana.Application] = map[imageInfo]struct{}{}
						}
						imageInfos[cfg.Prodvana.Application][*info] = struct{}{}
					}
				}
				rc, err := makeReleaseChannelConfig(&cfg)
				if err != nil {
					return err
				}
				releaseChannels[cfg.Prodvana.Application] = append(releaseChannels[cfg.Prodvana.Application], rc)
				perReleaseChannelConfigs[cfg.Prodvana.Application] = append(perReleaseChannelConfigs[cfg.Prodvana.Application], &service_pb.PerReleaseChannelConfig{
					ReleaseChannel: rc.Name,
					ConfigOneof: &service_pb.PerReleaseChannelConfig_Fly{
						Fly: &fly_pb.FlyConfig{
							TomlOneof: &fly_pb.FlyConfig_Inlined{
								Inlined: string(bytesForCfg),
							},
						},
					},
				})
			}
			return nil
		})
		if err != nil {
			return err
		}
		var overallErr error
		orgResp, err := getOrganizationManagerClient().GetOrganization(ctx, &organization_pb.GetOrganizationReq{})
		if err != nil {
			return errors.Wrap(err, "failed to get organization")
		}
		for appName, channels := range releaseChannels {
			configured, err := configureOneApplication(ctx, appName, channels, perReleaseChannelConfigs[appName], maps.Keys(imageInfos[appName]))
			if err != nil {
				overallErr = multierror.Append(overallErr, errors.Wrapf(err, "failed to process Prodvana Application %s", appName))
				continue
			}
			fmt.Printf("Configured Prodvana Application. Kick off a deployment at: %s/applications/%s/services/%s\n", orgResp.Organization.UiAddress, configured.application, configured.service)
		}
		return overallErr
	},
}

func init() {
	configureCmd.Flags().StringVar(&configureFlags.flyRuntime, "fly-runtime", "fly", "Name of the Fly Runtime on Prodvana")
	configureCmd.Flags().StringVar(&configureFlags.flyRegistry, "fly-registry", "fly-registry", "Name of the Fly registry integration on Prodvana")
	configureCmd.Flags().StringVar(&configureFlags.flyctlPath, "flyctl-path", "fly", "Path to flyctl binary")
	configureCmd.Flags().StringVar(&configureFlags.flyOrg, "fly-org", "", "Name of the Fly organization.")
	// TODO(naphat) we can infer this?
	must(configureCmd.MarkFlagRequired("fly-org"))
}
