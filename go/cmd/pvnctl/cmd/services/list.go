package services

import (
	"context"
	"log"
	"os"
	"sort"
	"sync"

	"github.com/prodvana/prodvana-public/go/pkg/cmdutil"

	service_pb "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/service"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"golang.org/x/sync/errgroup"
)

var listCmd = &cobra.Command{
	Use:   "list",
	Short: "List all service instances",
	Long: `List all service instances"

pvnctl services --app=<app> list
`,
	Args: cobra.ExactArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		ctx := context.Background()
		rawExtAddr, err := cmd.Flags().GetBool("show-raw-ext-addr")
		if err != nil {
			log.Fatal(err)
		}
		hostTypePreferences := []service_pb.ExternalAddr_Type{
			service_pb.ExternalAddr_EXTERNAL,
			service_pb.ExternalAddr_AUTO,
			service_pb.ExternalAddr_RAW_HOSTNAME,
			service_pb.ExternalAddr_RAW_IP,
		}
		if rawExtAddr {
			hostTypePreferences = []service_pb.ExternalAddr_Type{
				service_pb.ExternalAddr_RAW_HOSTNAME,
				service_pb.ExternalAddr_RAW_IP,
			}
		}
		serviceResp, err := cmdutil.GetServiceManagerClient().ListServices(ctx, &service_pb.ListServicesReq{
			Application: cmdutil.App,
		})
		if err != nil {
			log.Fatal(err)
		}
		g, gCtx := errgroup.WithContext(ctx)
		serviceInstances := make(map[string][]*service_pb.ServiceInstance)
		lock := &sync.Mutex{}
		for _, service := range serviceResp.Services {
			service := service
			g.Go(func() error {
				ctx := gCtx
				instancesResp, err := cmdutil.GetServiceManagerClient().ListServiceInstances(ctx, &service_pb.ListServiceInstancesReq{
					Application: cmdutil.App,
					Service:     service.Meta.Id,
				})
				if err != nil {
					return errors.Wrap(err, "failed to list service instances")
				}
				lock.Lock()
				defer lock.Unlock()
				serviceInstances[service.Meta.Id] = instancesResp.ServiceInstances
				return nil
			})
		}
		err = g.Wait()
		if err != nil {
			log.Fatal(err)
		}
		services := serviceResp.Services
		sort.Slice(services, func(i, j int) bool {
			return services[i].Meta.Name < services[j].Meta.Name
		})
		listing := cmdutil.NewOutputListing("SERVICE ID", "SERVICE", "RELEASE CHANNEL", "EXTERNAL IP")
		for _, service := range services {
			for _, instance := range serviceInstances[service.Meta.Id] {
				externalAddr := "N/A"
				if len(instance.State.ExternalAddrs) > 0 {
					extAddrByType := map[service_pb.ExternalAddr_Type][]*service_pb.ExternalAddr{}
					for _, host := range instance.State.ExternalAddrs {
						extAddrByType[host.Type] = append(extAddrByType[host.Type], host)
					}
				HOST_TYPE_LOOP:
					for _, hostType := range hostTypePreferences {
						// sort for stability
						sort.Slice(extAddrByType[hostType], func(i, j int) bool {
							return extAddrByType[hostType][i].Addr < extAddrByType[hostType][j].Addr
						})
						for _, host := range extAddrByType[hostType] {
							externalAddr = host.Addr
							break HOST_TYPE_LOOP
						}
					}
				}

				listing.AddRow(service.Meta.Id, service.Meta.Name, instance.Meta.ReleaseChannelMeta.Name, externalAddr)
			}
		}
		err = cmdutil.WriteStdout(listing)
		if err != nil {
			cmd.PrintErrf("Failed to list services: %+v\n", err)
			os.Exit(1)
		}
	},
}

func init() {
	RootCmd.AddCommand(listCmd)
	listCmd.Flags().Bool("show-raw-ext-addr", false, "Show the raw external address instead of one generated by Prodvana.")
}
