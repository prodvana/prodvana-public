// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: prodvana/events/types.proto

package events

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	model "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/desired_state/model"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = model.Status(0)
)

// Validate checks the field values on SetDesiredStateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetDesiredStateEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetDesiredStateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetDesiredStateEventMultiError, or nil if none found.
func (m *SetDesiredStateEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *SetDesiredStateEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetDesiredStateEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetDesiredStateEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetDesiredStateEventValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DesiredStateId

	// no validation rules for RootDesiredStateId

	if all {
		switch v := interface{}(m.GetDesired()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetDesiredStateEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetDesiredStateEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDesired()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetDesiredStateEventValidationError{
				field:  "Desired",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsRollback

	if len(errors) > 0 {
		return SetDesiredStateEventMultiError(errors)
	}

	return nil
}

// SetDesiredStateEventMultiError is an error wrapping multiple validation
// errors returned by SetDesiredStateEvent.ValidateAll() if the designated
// constraints aren't met.
type SetDesiredStateEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetDesiredStateEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetDesiredStateEventMultiError) AllErrors() []error { return m }

// SetDesiredStateEventValidationError is the validation error returned by
// SetDesiredStateEvent.Validate if the designated constraints aren't met.
type SetDesiredStateEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetDesiredStateEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetDesiredStateEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetDesiredStateEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetDesiredStateEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetDesiredStateEventValidationError) ErrorName() string {
	return "SetDesiredStateEventValidationError"
}

// Error satisfies the builtin error interface
func (e SetDesiredStateEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetDesiredStateEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetDesiredStateEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetDesiredStateEventValidationError{}

// Validate checks the field values on SetTargetStateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetTargetStateEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetTargetStateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetTargetStateEventMultiError, or nil if none found.
func (m *SetTargetStateEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *SetTargetStateEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetTargetStateEventValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DesiredStateId

	// no validation rules for RootDesiredStateId

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetTargetStateEventValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDesired()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDesired()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetTargetStateEventValidationError{
				field:  "Desired",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Current",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Current",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetTargetStateEventValidationError{
				field:  "Current",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsAutoRollback

	// no validation rules for Status

	for idx, item := range m.GetStatusExplanations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetTargetStateEventValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetTargetStateEventValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetTargetStateEventValidationError{
					field:  fmt.Sprintf("StatusExplanations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SetTargetStateEventMultiError(errors)
	}

	return nil
}

// SetTargetStateEventMultiError is an error wrapping multiple validation
// errors returned by SetTargetStateEvent.ValidateAll() if the designated
// constraints aren't met.
type SetTargetStateEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetTargetStateEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetTargetStateEventMultiError) AllErrors() []error { return m }

// SetTargetStateEventValidationError is the validation error returned by
// SetTargetStateEvent.Validate if the designated constraints aren't met.
type SetTargetStateEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetTargetStateEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetTargetStateEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetTargetStateEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetTargetStateEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetTargetStateEventValidationError) ErrorName() string {
	return "SetTargetStateEventValidationError"
}

// Error satisfies the builtin error interface
func (e SetTargetStateEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetTargetStateEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetTargetStateEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetTargetStateEventValidationError{}

// Validate checks the field values on ApplyTargetStateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplyTargetStateEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyTargetStateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplyTargetStateEventMultiError, or nil if none found.
func (m *ApplyTargetStateEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyTargetStateEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyTargetStateEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyTargetStateEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyTargetStateEventValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DesiredStateId

	// no validation rules for RootDesiredStateId

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyTargetStateEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyTargetStateEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyTargetStateEventValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyTargetStateEventValidationError{
					field:  "Current",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyTargetStateEventValidationError{
					field:  "Current",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyTargetStateEventValidationError{
				field:  "Current",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsAutoRollback

	// no validation rules for Result

	// no validation rules for Error

	if len(errors) > 0 {
		return ApplyTargetStateEventMultiError(errors)
	}

	return nil
}

// ApplyTargetStateEventMultiError is an error wrapping multiple validation
// errors returned by ApplyTargetStateEvent.ValidateAll() if the designated
// constraints aren't met.
type ApplyTargetStateEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyTargetStateEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyTargetStateEventMultiError) AllErrors() []error { return m }

// ApplyTargetStateEventValidationError is the validation error returned by
// ApplyTargetStateEvent.Validate if the designated constraints aren't met.
type ApplyTargetStateEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyTargetStateEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyTargetStateEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyTargetStateEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyTargetStateEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyTargetStateEventValidationError) ErrorName() string {
	return "ApplyTargetStateEventValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyTargetStateEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyTargetStateEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyTargetStateEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyTargetStateEventValidationError{}

// Validate checks the field values on ProgramExitEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProgramExitEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgramExitEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProgramExitEventMultiError, or nil if none found.
func (m *ProgramExitEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgramExitEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Namespace

	// no validation rules for Pod

	// no validation rules for Program

	// no validation rules for RestartCount

	// no validation rules for Reason

	// no validation rules for KilledReason

	// no validation rules for ExitCode

	// no validation rules for Signal

	if len(errors) > 0 {
		return ProgramExitEventMultiError(errors)
	}

	return nil
}

// ProgramExitEventMultiError is an error wrapping multiple validation errors
// returned by ProgramExitEvent.ValidateAll() if the designated constraints
// aren't met.
type ProgramExitEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgramExitEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgramExitEventMultiError) AllErrors() []error { return m }

// ProgramExitEventValidationError is the validation error returned by
// ProgramExitEvent.Validate if the designated constraints aren't met.
type ProgramExitEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgramExitEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgramExitEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgramExitEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgramExitEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgramExitEventValidationError) ErrorName() string { return "ProgramExitEventValidationError" }

// Error satisfies the builtin error interface
func (e ProgramExitEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgramExitEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgramExitEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgramExitEventValidationError{}

// Validate checks the field values on DeliveryProgressEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeliveryProgressEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryProgressEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeliveryProgressEventMultiError, or nil if none found.
func (m *DeliveryProgressEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryProgressEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryProgressEventValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryProgressEventValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryProgressEventValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeliveryProgressEventMultiError(errors)
	}

	return nil
}

// DeliveryProgressEventMultiError is an error wrapping multiple validation
// errors returned by DeliveryProgressEvent.ValidateAll() if the designated
// constraints aren't met.
type DeliveryProgressEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryProgressEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryProgressEventMultiError) AllErrors() []error { return m }

// DeliveryProgressEventValidationError is the validation error returned by
// DeliveryProgressEvent.Validate if the designated constraints aren't met.
type DeliveryProgressEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryProgressEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryProgressEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryProgressEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryProgressEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryProgressEventValidationError) ErrorName() string {
	return "DeliveryProgressEventValidationError"
}

// Error satisfies the builtin error interface
func (e DeliveryProgressEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryProgressEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryProgressEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryProgressEventValidationError{}

// Validate checks the field values on DeliveryManualPromotionEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeliveryManualPromotionEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryManualPromotionEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeliveryManualPromotionEventMultiError, or nil if none found.
func (m *DeliveryManualPromotionEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryManualPromotionEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryManualPromotionEventValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryManualPromotionEventValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryManualPromotionEventValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Stage

	// no validation rules for Full

	if len(errors) > 0 {
		return DeliveryManualPromotionEventMultiError(errors)
	}

	return nil
}

// DeliveryManualPromotionEventMultiError is an error wrapping multiple
// validation errors returned by DeliveryManualPromotionEvent.ValidateAll() if
// the designated constraints aren't met.
type DeliveryManualPromotionEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryManualPromotionEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryManualPromotionEventMultiError) AllErrors() []error { return m }

// DeliveryManualPromotionEventValidationError is the validation error returned
// by DeliveryManualPromotionEvent.Validate if the designated constraints
// aren't met.
type DeliveryManualPromotionEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryManualPromotionEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryManualPromotionEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryManualPromotionEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryManualPromotionEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryManualPromotionEventValidationError) ErrorName() string {
	return "DeliveryManualPromotionEventValidationError"
}

// Error satisfies the builtin error interface
func (e DeliveryManualPromotionEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryManualPromotionEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryManualPromotionEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryManualPromotionEventValidationError{}

// Validate checks the field values on ManualApprovalEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ManualApprovalEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ManualApprovalEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ManualApprovalEventMultiError, or nil if none found.
func (m *ManualApprovalEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ManualApprovalEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Topic

	if len(errors) > 0 {
		return ManualApprovalEventMultiError(errors)
	}

	return nil
}

// ManualApprovalEventMultiError is an error wrapping multiple validation
// errors returned by ManualApprovalEvent.ValidateAll() if the designated
// constraints aren't met.
type ManualApprovalEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ManualApprovalEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ManualApprovalEventMultiError) AllErrors() []error { return m }

// ManualApprovalEventValidationError is the validation error returned by
// ManualApprovalEvent.Validate if the designated constraints aren't met.
type ManualApprovalEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ManualApprovalEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ManualApprovalEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ManualApprovalEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ManualApprovalEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ManualApprovalEventValidationError) ErrorName() string {
	return "ManualApprovalEventValidationError"
}

// Error satisfies the builtin error interface
func (e ManualApprovalEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sManualApprovalEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ManualApprovalEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ManualApprovalEventValidationError{}

// Validate checks the field values on CustomTaskExecutionEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CustomTaskExecutionEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CustomTaskExecutionEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CustomTaskExecutionEventMultiError, or nil if none found.
func (m *CustomTaskExecutionEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *CustomTaskExecutionEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Successful

	// no validation rules for Attempts

	// no validation rules for Reason

	if len(errors) > 0 {
		return CustomTaskExecutionEventMultiError(errors)
	}

	return nil
}

// CustomTaskExecutionEventMultiError is an error wrapping multiple validation
// errors returned by CustomTaskExecutionEvent.ValidateAll() if the designated
// constraints aren't met.
type CustomTaskExecutionEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CustomTaskExecutionEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CustomTaskExecutionEventMultiError) AllErrors() []error { return m }

// CustomTaskExecutionEventValidationError is the validation error returned by
// CustomTaskExecutionEvent.Validate if the designated constraints aren't met.
type CustomTaskExecutionEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CustomTaskExecutionEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CustomTaskExecutionEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CustomTaskExecutionEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CustomTaskExecutionEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CustomTaskExecutionEventValidationError) ErrorName() string {
	return "CustomTaskExecutionEventValidationError"
}

// Error satisfies the builtin error interface
func (e CustomTaskExecutionEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomTaskExecutionEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CustomTaskExecutionEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CustomTaskExecutionEventValidationError{}

// Validate checks the field values on RuntimeObject with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RuntimeObject) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeObject with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RuntimeObjectMultiError, or
// nil if none found.
func (m *RuntimeObject) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeObject) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Kind

	// no validation rules for Namespace

	// no validation rules for Url

	if len(errors) > 0 {
		return RuntimeObjectMultiError(errors)
	}

	return nil
}

// RuntimeObjectMultiError is an error wrapping multiple validation errors
// returned by RuntimeObject.ValidateAll() if the designated constraints
// aren't met.
type RuntimeObjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeObjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeObjectMultiError) AllErrors() []error { return m }

// RuntimeObjectValidationError is the validation error returned by
// RuntimeObject.Validate if the designated constraints aren't met.
type RuntimeObjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeObjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeObjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeObjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeObjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeObjectValidationError) ErrorName() string { return "RuntimeObjectValidationError" }

// Error satisfies the builtin error interface
func (e RuntimeObjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeObject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeObjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeObjectValidationError{}

// Validate checks the field values on RuntimeUpdateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeUpdateEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeUpdateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RuntimeUpdateEventMultiError, or nil if none found.
func (m *RuntimeUpdateEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeUpdateEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Action

	if all {
		switch v := interface{}(m.GetObject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeUpdateEventValidationError{
					field:  "Object",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeUpdateEventValidationError{
					field:  "Object",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeUpdateEventValidationError{
				field:  "Object",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	if len(errors) > 0 {
		return RuntimeUpdateEventMultiError(errors)
	}

	return nil
}

// RuntimeUpdateEventMultiError is an error wrapping multiple validation errors
// returned by RuntimeUpdateEvent.ValidateAll() if the designated constraints
// aren't met.
type RuntimeUpdateEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeUpdateEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeUpdateEventMultiError) AllErrors() []error { return m }

// RuntimeUpdateEventValidationError is the validation error returned by
// RuntimeUpdateEvent.Validate if the designated constraints aren't met.
type RuntimeUpdateEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeUpdateEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeUpdateEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeUpdateEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeUpdateEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeUpdateEventValidationError) ErrorName() string {
	return "RuntimeUpdateEventValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeUpdateEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeUpdateEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeUpdateEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeUpdateEventValidationError{}

// Validate checks the field values on DesiredStateStatusChangeEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DesiredStateStatusChangeEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DesiredStateStatusChangeEvent with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DesiredStateStatusChangeEventMultiError, or nil if none found.
func (m *DesiredStateStatusChangeEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DesiredStateStatusChangeEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DesiredStateStatusChangeEventValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DesiredStateId

	// no validation rules for RootDesiredStateId

	// no validation rules for OldStatus

	// no validation rules for NewStatus

	if all {
		switch v := interface{}(m.GetDesired()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDesired()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DesiredStateStatusChangeEventValidationError{
				field:  "Desired",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DesiredStateStatusChangeEventValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOldState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "OldState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "OldState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOldState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DesiredStateStatusChangeEventValidationError{
				field:  "OldState",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNewState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "NewState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "NewState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNewState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DesiredStateStatusChangeEventValidationError{
				field:  "NewState",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetStatusExplanations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DesiredStateStatusChangeEventValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DesiredStateStatusChangeEventValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DesiredStateStatusChangeEventValidationError{
					field:  fmt.Sprintf("StatusExplanations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DesiredStateStatusChangeEventMultiError(errors)
	}

	return nil
}

// DesiredStateStatusChangeEventMultiError is an error wrapping multiple
// validation errors returned by DesiredStateStatusChangeEvent.ValidateAll()
// if the designated constraints aren't met.
type DesiredStateStatusChangeEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DesiredStateStatusChangeEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DesiredStateStatusChangeEventMultiError) AllErrors() []error { return m }

// DesiredStateStatusChangeEventValidationError is the validation error
// returned by DesiredStateStatusChangeEvent.Validate if the designated
// constraints aren't met.
type DesiredStateStatusChangeEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DesiredStateStatusChangeEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DesiredStateStatusChangeEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DesiredStateStatusChangeEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DesiredStateStatusChangeEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DesiredStateStatusChangeEventValidationError) ErrorName() string {
	return "DesiredStateStatusChangeEventValidationError"
}

// Error satisfies the builtin error interface
func (e DesiredStateStatusChangeEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDesiredStateStatusChangeEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DesiredStateStatusChangeEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DesiredStateStatusChangeEventValidationError{}

// Validate checks the field values on KeyDeliveryDecisionEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KeyDeliveryDecisionEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyDeliveryDecisionEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KeyDeliveryDecisionEventMultiError, or nil if none found.
func (m *KeyDeliveryDecisionEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyDeliveryDecisionEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return KeyDeliveryDecisionEventValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DesiredStateId

	// no validation rules for RootDesiredStateId

	// no validation rules for Decision

	// no validation rules for Explanation

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetDesired()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDesired()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return KeyDeliveryDecisionEventValidationError{
				field:  "Desired",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return KeyDeliveryDecisionEventValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Current",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Current",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return KeyDeliveryDecisionEventValidationError{
				field:  "Current",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetStatusExplanations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, KeyDeliveryDecisionEventValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, KeyDeliveryDecisionEventValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return KeyDeliveryDecisionEventValidationError{
					field:  fmt.Sprintf("StatusExplanations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return KeyDeliveryDecisionEventMultiError(errors)
	}

	return nil
}

// KeyDeliveryDecisionEventMultiError is an error wrapping multiple validation
// errors returned by KeyDeliveryDecisionEvent.ValidateAll() if the designated
// constraints aren't met.
type KeyDeliveryDecisionEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyDeliveryDecisionEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyDeliveryDecisionEventMultiError) AllErrors() []error { return m }

// KeyDeliveryDecisionEventValidationError is the validation error returned by
// KeyDeliveryDecisionEvent.Validate if the designated constraints aren't met.
type KeyDeliveryDecisionEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyDeliveryDecisionEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyDeliveryDecisionEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyDeliveryDecisionEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyDeliveryDecisionEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyDeliveryDecisionEventValidationError) ErrorName() string {
	return "KeyDeliveryDecisionEventValidationError"
}

// Error satisfies the builtin error interface
func (e KeyDeliveryDecisionEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyDeliveryDecisionEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyDeliveryDecisionEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyDeliveryDecisionEventValidationError{}

// Validate checks the field values on EventDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EventDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EventDetailsMultiError, or
// nil if none found.
func (m *EventDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *EventDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Details.(type) {
	case *EventDetails_SetDesiredState:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetDesiredState()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "SetDesiredState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "SetDesiredState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetDesiredState()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "SetDesiredState",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_SetTargetState:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetTargetState()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "SetTargetState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "SetTargetState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetTargetState()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "SetTargetState",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_ProgramExit:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProgramExit()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ProgramExit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ProgramExit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProgramExit()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "ProgramExit",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_ApplyTargetState:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplyTargetState()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ApplyTargetState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ApplyTargetState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplyTargetState()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "ApplyTargetState",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_ManualApproval:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetManualApproval()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ManualApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ManualApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetManualApproval()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "ManualApproval",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_CustomTaskExecution:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCustomTaskExecution()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "CustomTaskExecution",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "CustomTaskExecution",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCustomTaskExecution()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "CustomTaskExecution",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_RuntimeUpdate:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRuntimeUpdate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "RuntimeUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "RuntimeUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRuntimeUpdate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "RuntimeUpdate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_DeliveryProgress:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeliveryProgress()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DeliveryProgress",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DeliveryProgress",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeliveryProgress()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "DeliveryProgress",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_DeliveryPromotion:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeliveryPromotion()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DeliveryPromotion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DeliveryPromotion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeliveryPromotion()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "DeliveryPromotion",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_DesiredStateStatusChange:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDesiredStateStatusChange()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DesiredStateStatusChange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DesiredStateStatusChange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDesiredStateStatusChange()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "DesiredStateStatusChange",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_KeyDeliveryDecision:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKeyDeliveryDecision()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "KeyDeliveryDecision",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "KeyDeliveryDecision",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKeyDeliveryDecision()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "KeyDeliveryDecision",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EventDetailsMultiError(errors)
	}

	return nil
}

// EventDetailsMultiError is an error wrapping multiple validation errors
// returned by EventDetails.ValidateAll() if the designated constraints aren't met.
type EventDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventDetailsMultiError) AllErrors() []error { return m }

// EventDetailsValidationError is the validation error returned by
// EventDetails.Validate if the designated constraints aren't met.
type EventDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventDetailsValidationError) ErrorName() string { return "EventDetailsValidationError" }

// Error satisfies the builtin error interface
func (e EventDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventDetailsValidationError{}
