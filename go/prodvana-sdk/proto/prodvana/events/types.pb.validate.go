// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: prodvana/events/types.proto

package events

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	model "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/desired_state/model"

	model1 "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/deployment/model"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = model.Status(0)

	_ = model1.DeploymentStatus(0)
)

// Validate checks the field values on SetDesiredStateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetDesiredStateEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetDesiredStateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetDesiredStateEventMultiError, or nil if none found.
func (m *SetDesiredStateEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *SetDesiredStateEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetDesiredStateEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetDesiredStateEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetDesiredStateEventValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DesiredStateId

	// no validation rules for RootDesiredStateId

	if all {
		switch v := interface{}(m.GetDesired()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetDesiredStateEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetDesiredStateEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDesired()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetDesiredStateEventValidationError{
				field:  "Desired",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsRollback

	if len(errors) > 0 {
		return SetDesiredStateEventMultiError(errors)
	}

	return nil
}

// SetDesiredStateEventMultiError is an error wrapping multiple validation
// errors returned by SetDesiredStateEvent.ValidateAll() if the designated
// constraints aren't met.
type SetDesiredStateEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetDesiredStateEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetDesiredStateEventMultiError) AllErrors() []error { return m }

// SetDesiredStateEventValidationError is the validation error returned by
// SetDesiredStateEvent.Validate if the designated constraints aren't met.
type SetDesiredStateEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetDesiredStateEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetDesiredStateEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetDesiredStateEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetDesiredStateEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetDesiredStateEventValidationError) ErrorName() string {
	return "SetDesiredStateEventValidationError"
}

// Error satisfies the builtin error interface
func (e SetDesiredStateEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetDesiredStateEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetDesiredStateEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetDesiredStateEventValidationError{}

// Validate checks the field values on SetTargetStateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetTargetStateEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetTargetStateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetTargetStateEventMultiError, or nil if none found.
func (m *SetTargetStateEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *SetTargetStateEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetTargetStateEventValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DesiredStateId

	// no validation rules for RootDesiredStateId

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetTargetStateEventValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDesired()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDesired()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetTargetStateEventValidationError{
				field:  "Desired",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Current",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetTargetStateEventValidationError{
					field:  "Current",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetTargetStateEventValidationError{
				field:  "Current",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsAutoRollback

	// no validation rules for Status

	for idx, item := range m.GetStatusExplanations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetTargetStateEventValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetTargetStateEventValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetTargetStateEventValidationError{
					field:  fmt.Sprintf("StatusExplanations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SetTargetStateEventMultiError(errors)
	}

	return nil
}

// SetTargetStateEventMultiError is an error wrapping multiple validation
// errors returned by SetTargetStateEvent.ValidateAll() if the designated
// constraints aren't met.
type SetTargetStateEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetTargetStateEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetTargetStateEventMultiError) AllErrors() []error { return m }

// SetTargetStateEventValidationError is the validation error returned by
// SetTargetStateEvent.Validate if the designated constraints aren't met.
type SetTargetStateEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetTargetStateEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetTargetStateEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetTargetStateEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetTargetStateEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetTargetStateEventValidationError) ErrorName() string {
	return "SetTargetStateEventValidationError"
}

// Error satisfies the builtin error interface
func (e SetTargetStateEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetTargetStateEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetTargetStateEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetTargetStateEventValidationError{}

// Validate checks the field values on ApplyTargetStateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplyTargetStateEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyTargetStateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplyTargetStateEventMultiError, or nil if none found.
func (m *ApplyTargetStateEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyTargetStateEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyTargetStateEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyTargetStateEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyTargetStateEventValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DesiredStateId

	// no validation rules for RootDesiredStateId

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyTargetStateEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyTargetStateEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyTargetStateEventValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyTargetStateEventValidationError{
					field:  "Current",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyTargetStateEventValidationError{
					field:  "Current",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyTargetStateEventValidationError{
				field:  "Current",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsAutoRollback

	// no validation rules for Result

	// no validation rules for Error

	// no validation rules for HasWorkReason

	if len(errors) > 0 {
		return ApplyTargetStateEventMultiError(errors)
	}

	return nil
}

// ApplyTargetStateEventMultiError is an error wrapping multiple validation
// errors returned by ApplyTargetStateEvent.ValidateAll() if the designated
// constraints aren't met.
type ApplyTargetStateEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyTargetStateEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyTargetStateEventMultiError) AllErrors() []error { return m }

// ApplyTargetStateEventValidationError is the validation error returned by
// ApplyTargetStateEvent.Validate if the designated constraints aren't met.
type ApplyTargetStateEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyTargetStateEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyTargetStateEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyTargetStateEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyTargetStateEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyTargetStateEventValidationError) ErrorName() string {
	return "ApplyTargetStateEventValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyTargetStateEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyTargetStateEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyTargetStateEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyTargetStateEventValidationError{}

// Validate checks the field values on ProgramExitEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProgramExitEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgramExitEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProgramExitEventMultiError, or nil if none found.
func (m *ProgramExitEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgramExitEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Namespace

	// no validation rules for Pod

	// no validation rules for Program

	// no validation rules for RestartCount

	// no validation rules for Reason

	// no validation rules for KilledReason

	// no validation rules for ExitCode

	// no validation rules for Signal

	if all {
		switch v := interface{}(m.GetStructuredOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProgramExitEventValidationError{
					field:  "StructuredOutput",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProgramExitEventValidationError{
					field:  "StructuredOutput",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStructuredOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProgramExitEventValidationError{
				field:  "StructuredOutput",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProgramExitEventMultiError(errors)
	}

	return nil
}

// ProgramExitEventMultiError is an error wrapping multiple validation errors
// returned by ProgramExitEvent.ValidateAll() if the designated constraints
// aren't met.
type ProgramExitEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgramExitEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgramExitEventMultiError) AllErrors() []error { return m }

// ProgramExitEventValidationError is the validation error returned by
// ProgramExitEvent.Validate if the designated constraints aren't met.
type ProgramExitEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgramExitEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgramExitEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgramExitEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgramExitEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgramExitEventValidationError) ErrorName() string { return "ProgramExitEventValidationError" }

// Error satisfies the builtin error interface
func (e ProgramExitEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgramExitEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgramExitEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgramExitEventValidationError{}

// Validate checks the field values on DeliveryProgressEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeliveryProgressEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryProgressEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeliveryProgressEventMultiError, or nil if none found.
func (m *DeliveryProgressEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryProgressEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryProgressEventValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryProgressEventValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryProgressEventValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeliveryProgressEventMultiError(errors)
	}

	return nil
}

// DeliveryProgressEventMultiError is an error wrapping multiple validation
// errors returned by DeliveryProgressEvent.ValidateAll() if the designated
// constraints aren't met.
type DeliveryProgressEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryProgressEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryProgressEventMultiError) AllErrors() []error { return m }

// DeliveryProgressEventValidationError is the validation error returned by
// DeliveryProgressEvent.Validate if the designated constraints aren't met.
type DeliveryProgressEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryProgressEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryProgressEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryProgressEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryProgressEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryProgressEventValidationError) ErrorName() string {
	return "DeliveryProgressEventValidationError"
}

// Error satisfies the builtin error interface
func (e DeliveryProgressEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryProgressEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryProgressEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryProgressEventValidationError{}

// Validate checks the field values on DeliveryManualPromotionEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeliveryManualPromotionEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryManualPromotionEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeliveryManualPromotionEventMultiError, or nil if none found.
func (m *DeliveryManualPromotionEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryManualPromotionEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryManualPromotionEventValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryManualPromotionEventValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryManualPromotionEventValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Stage

	// no validation rules for Full

	if len(errors) > 0 {
		return DeliveryManualPromotionEventMultiError(errors)
	}

	return nil
}

// DeliveryManualPromotionEventMultiError is an error wrapping multiple
// validation errors returned by DeliveryManualPromotionEvent.ValidateAll() if
// the designated constraints aren't met.
type DeliveryManualPromotionEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryManualPromotionEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryManualPromotionEventMultiError) AllErrors() []error { return m }

// DeliveryManualPromotionEventValidationError is the validation error returned
// by DeliveryManualPromotionEvent.Validate if the designated constraints
// aren't met.
type DeliveryManualPromotionEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryManualPromotionEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryManualPromotionEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryManualPromotionEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryManualPromotionEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryManualPromotionEventValidationError) ErrorName() string {
	return "DeliveryManualPromotionEventValidationError"
}

// Error satisfies the builtin error interface
func (e DeliveryManualPromotionEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryManualPromotionEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryManualPromotionEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryManualPromotionEventValidationError{}

// Validate checks the field values on ManualApprovalEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ManualApprovalEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ManualApprovalEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ManualApprovalEventMultiError, or nil if none found.
func (m *ManualApprovalEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ManualApprovalEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Topic

	if len(errors) > 0 {
		return ManualApprovalEventMultiError(errors)
	}

	return nil
}

// ManualApprovalEventMultiError is an error wrapping multiple validation
// errors returned by ManualApprovalEvent.ValidateAll() if the designated
// constraints aren't met.
type ManualApprovalEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ManualApprovalEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ManualApprovalEventMultiError) AllErrors() []error { return m }

// ManualApprovalEventValidationError is the validation error returned by
// ManualApprovalEvent.Validate if the designated constraints aren't met.
type ManualApprovalEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ManualApprovalEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ManualApprovalEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ManualApprovalEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ManualApprovalEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ManualApprovalEventValidationError) ErrorName() string {
	return "ManualApprovalEventValidationError"
}

// Error satisfies the builtin error interface
func (e ManualApprovalEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sManualApprovalEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ManualApprovalEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ManualApprovalEventValidationError{}

// Validate checks the field values on RuntimeObject with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RuntimeObject) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeObject with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RuntimeObjectMultiError, or
// nil if none found.
func (m *RuntimeObject) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeObject) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Kind

	// no validation rules for Namespace

	// no validation rules for Url

	if len(errors) > 0 {
		return RuntimeObjectMultiError(errors)
	}

	return nil
}

// RuntimeObjectMultiError is an error wrapping multiple validation errors
// returned by RuntimeObject.ValidateAll() if the designated constraints
// aren't met.
type RuntimeObjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeObjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeObjectMultiError) AllErrors() []error { return m }

// RuntimeObjectValidationError is the validation error returned by
// RuntimeObject.Validate if the designated constraints aren't met.
type RuntimeObjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeObjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeObjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeObjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeObjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeObjectValidationError) ErrorName() string { return "RuntimeObjectValidationError" }

// Error satisfies the builtin error interface
func (e RuntimeObjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeObject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeObjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeObjectValidationError{}

// Validate checks the field values on RuntimeUpdateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeUpdateEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeUpdateEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RuntimeUpdateEventMultiError, or nil if none found.
func (m *RuntimeUpdateEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeUpdateEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Action

	if all {
		switch v := interface{}(m.GetObject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeUpdateEventValidationError{
					field:  "Object",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeUpdateEventValidationError{
					field:  "Object",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeUpdateEventValidationError{
				field:  "Object",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	if len(errors) > 0 {
		return RuntimeUpdateEventMultiError(errors)
	}

	return nil
}

// RuntimeUpdateEventMultiError is an error wrapping multiple validation errors
// returned by RuntimeUpdateEvent.ValidateAll() if the designated constraints
// aren't met.
type RuntimeUpdateEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeUpdateEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeUpdateEventMultiError) AllErrors() []error { return m }

// RuntimeUpdateEventValidationError is the validation error returned by
// RuntimeUpdateEvent.Validate if the designated constraints aren't met.
type RuntimeUpdateEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeUpdateEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeUpdateEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeUpdateEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeUpdateEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeUpdateEventValidationError) ErrorName() string {
	return "RuntimeUpdateEventValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeUpdateEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeUpdateEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeUpdateEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeUpdateEventValidationError{}

// Validate checks the field values on DesiredStateStatusChangeEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DesiredStateStatusChangeEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DesiredStateStatusChangeEvent with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DesiredStateStatusChangeEventMultiError, or nil if none found.
func (m *DesiredStateStatusChangeEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DesiredStateStatusChangeEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DesiredStateStatusChangeEventValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DesiredStateId

	// no validation rules for RootDesiredStateId

	// no validation rules for OldStatus

	// no validation rules for NewStatus

	if all {
		switch v := interface{}(m.GetDesired()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDesired()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DesiredStateStatusChangeEventValidationError{
				field:  "Desired",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DesiredStateStatusChangeEventValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOldState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "OldState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "OldState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOldState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DesiredStateStatusChangeEventValidationError{
				field:  "OldState",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNewState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "NewState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DesiredStateStatusChangeEventValidationError{
					field:  "NewState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNewState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DesiredStateStatusChangeEventValidationError{
				field:  "NewState",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetStatusExplanations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DesiredStateStatusChangeEventValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DesiredStateStatusChangeEventValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DesiredStateStatusChangeEventValidationError{
					field:  fmt.Sprintf("StatusExplanations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DesiredStateStatusChangeEventMultiError(errors)
	}

	return nil
}

// DesiredStateStatusChangeEventMultiError is an error wrapping multiple
// validation errors returned by DesiredStateStatusChangeEvent.ValidateAll()
// if the designated constraints aren't met.
type DesiredStateStatusChangeEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DesiredStateStatusChangeEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DesiredStateStatusChangeEventMultiError) AllErrors() []error { return m }

// DesiredStateStatusChangeEventValidationError is the validation error
// returned by DesiredStateStatusChangeEvent.Validate if the designated
// constraints aren't met.
type DesiredStateStatusChangeEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DesiredStateStatusChangeEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DesiredStateStatusChangeEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DesiredStateStatusChangeEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DesiredStateStatusChangeEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DesiredStateStatusChangeEventValidationError) ErrorName() string {
	return "DesiredStateStatusChangeEventValidationError"
}

// Error satisfies the builtin error interface
func (e DesiredStateStatusChangeEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDesiredStateStatusChangeEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DesiredStateStatusChangeEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DesiredStateStatusChangeEventValidationError{}

// Validate checks the field values on KeyDeliveryDecisionEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KeyDeliveryDecisionEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyDeliveryDecisionEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KeyDeliveryDecisionEventMultiError, or nil if none found.
func (m *KeyDeliveryDecisionEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyDeliveryDecisionEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return KeyDeliveryDecisionEventValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DesiredStateId

	// no validation rules for RootDesiredStateId

	// no validation rules for Decision

	// no validation rules for Explanation

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetDesired()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDesired()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return KeyDeliveryDecisionEventValidationError{
				field:  "Desired",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return KeyDeliveryDecisionEventValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Current",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, KeyDeliveryDecisionEventValidationError{
					field:  "Current",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return KeyDeliveryDecisionEventValidationError{
				field:  "Current",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetStatusExplanations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, KeyDeliveryDecisionEventValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, KeyDeliveryDecisionEventValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return KeyDeliveryDecisionEventValidationError{
					field:  fmt.Sprintf("StatusExplanations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetStatusExplanationEntities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, KeyDeliveryDecisionEventValidationError{
						field:  fmt.Sprintf("StatusExplanationEntities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, KeyDeliveryDecisionEventValidationError{
						field:  fmt.Sprintf("StatusExplanationEntities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return KeyDeliveryDecisionEventValidationError{
					field:  fmt.Sprintf("StatusExplanationEntities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return KeyDeliveryDecisionEventMultiError(errors)
	}

	return nil
}

// KeyDeliveryDecisionEventMultiError is an error wrapping multiple validation
// errors returned by KeyDeliveryDecisionEvent.ValidateAll() if the designated
// constraints aren't met.
type KeyDeliveryDecisionEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyDeliveryDecisionEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyDeliveryDecisionEventMultiError) AllErrors() []error { return m }

// KeyDeliveryDecisionEventValidationError is the validation error returned by
// KeyDeliveryDecisionEvent.Validate if the designated constraints aren't met.
type KeyDeliveryDecisionEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyDeliveryDecisionEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyDeliveryDecisionEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyDeliveryDecisionEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyDeliveryDecisionEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyDeliveryDecisionEventValidationError) ErrorName() string {
	return "KeyDeliveryDecisionEventValidationError"
}

// Error satisfies the builtin error interface
func (e KeyDeliveryDecisionEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyDeliveryDecisionEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyDeliveryDecisionEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyDeliveryDecisionEventValidationError{}

// Validate checks the field values on RpcCallEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RpcCallEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RpcCallEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RpcCallEventMultiError, or
// nil if none found.
func (m *RpcCallEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *RpcCallEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for RpcService

	// no validation rules for RpcMethod

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RpcCallEventValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RpcCallEventValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RpcCallEventValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RpcCallEventValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RpcCallEventValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RpcCallEventValidationError{
				field:  "Response",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RpcCallEventMultiError(errors)
	}

	return nil
}

// RpcCallEventMultiError is an error wrapping multiple validation errors
// returned by RpcCallEvent.ValidateAll() if the designated constraints aren't met.
type RpcCallEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RpcCallEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RpcCallEventMultiError) AllErrors() []error { return m }

// RpcCallEventValidationError is the validation error returned by
// RpcCallEvent.Validate if the designated constraints aren't met.
type RpcCallEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RpcCallEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RpcCallEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RpcCallEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RpcCallEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RpcCallEventValidationError) ErrorName() string { return "RpcCallEventValidationError" }

// Error satisfies the builtin error interface
func (e RpcCallEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRpcCallEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RpcCallEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RpcCallEventValidationError{}

// Validate checks the field values on ApplicationHandle with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ApplicationHandle) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationHandle with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationHandleMultiError, or nil if none found.
func (m *ApplicationHandle) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationHandle) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Id

	if len(errors) > 0 {
		return ApplicationHandleMultiError(errors)
	}

	return nil
}

// ApplicationHandleMultiError is an error wrapping multiple validation errors
// returned by ApplicationHandle.ValidateAll() if the designated constraints
// aren't met.
type ApplicationHandleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationHandleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationHandleMultiError) AllErrors() []error { return m }

// ApplicationHandleValidationError is the validation error returned by
// ApplicationHandle.Validate if the designated constraints aren't met.
type ApplicationHandleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationHandleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationHandleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationHandleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationHandleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationHandleValidationError) ErrorName() string {
	return "ApplicationHandleValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationHandleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationHandle.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationHandleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationHandleValidationError{}

// Validate checks the field values on ReleaseChannelHandle with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReleaseChannelHandle) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseChannelHandle with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReleaseChannelHandleMultiError, or nil if none found.
func (m *ReleaseChannelHandle) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseChannelHandle) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetApplication()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReleaseChannelHandleValidationError{
					field:  "Application",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReleaseChannelHandleValidationError{
					field:  "Application",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApplication()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReleaseChannelHandleValidationError{
				field:  "Application",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	// no validation rules for Id

	if len(errors) > 0 {
		return ReleaseChannelHandleMultiError(errors)
	}

	return nil
}

// ReleaseChannelHandleMultiError is an error wrapping multiple validation
// errors returned by ReleaseChannelHandle.ValidateAll() if the designated
// constraints aren't met.
type ReleaseChannelHandleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseChannelHandleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseChannelHandleMultiError) AllErrors() []error { return m }

// ReleaseChannelHandleValidationError is the validation error returned by
// ReleaseChannelHandle.Validate if the designated constraints aren't met.
type ReleaseChannelHandleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseChannelHandleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseChannelHandleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseChannelHandleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseChannelHandleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseChannelHandleValidationError) ErrorName() string {
	return "ReleaseChannelHandleValidationError"
}

// Error satisfies the builtin error interface
func (e ReleaseChannelHandleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseChannelHandle.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseChannelHandleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseChannelHandleValidationError{}

// Validate checks the field values on ServiceHandle with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServiceHandle) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceHandle with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServiceHandleMultiError, or
// nil if none found.
func (m *ServiceHandle) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceHandle) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetApplication()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceHandleValidationError{
					field:  "Application",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceHandleValidationError{
					field:  "Application",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApplication()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceHandleValidationError{
				field:  "Application",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReleaseChannel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceHandleValidationError{
					field:  "ReleaseChannel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceHandleValidationError{
					field:  "ReleaseChannel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReleaseChannel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceHandleValidationError{
				field:  "ReleaseChannel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	// no validation rules for Id

	if len(errors) > 0 {
		return ServiceHandleMultiError(errors)
	}

	return nil
}

// ServiceHandleMultiError is an error wrapping multiple validation errors
// returned by ServiceHandle.ValidateAll() if the designated constraints
// aren't met.
type ServiceHandleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceHandleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceHandleMultiError) AllErrors() []error { return m }

// ServiceHandleValidationError is the validation error returned by
// ServiceHandle.Validate if the designated constraints aren't met.
type ServiceHandleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceHandleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceHandleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceHandleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceHandleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceHandleValidationError) ErrorName() string { return "ServiceHandleValidationError" }

// Error satisfies the builtin error interface
func (e ServiceHandleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceHandle.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceHandleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceHandleValidationError{}

// Validate checks the field values on RuntimeHandle with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RuntimeHandle) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeHandle with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RuntimeHandleMultiError, or
// nil if none found.
func (m *RuntimeHandle) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeHandle) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Id

	if len(errors) > 0 {
		return RuntimeHandleMultiError(errors)
	}

	return nil
}

// RuntimeHandleMultiError is an error wrapping multiple validation errors
// returned by RuntimeHandle.ValidateAll() if the designated constraints
// aren't met.
type RuntimeHandleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeHandleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeHandleMultiError) AllErrors() []error { return m }

// RuntimeHandleValidationError is the validation error returned by
// RuntimeHandle.Validate if the designated constraints aren't met.
type RuntimeHandleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeHandleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeHandleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeHandleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeHandleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeHandleValidationError) ErrorName() string { return "RuntimeHandleValidationError" }

// Error satisfies the builtin error interface
func (e RuntimeHandleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeHandle.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeHandleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeHandleValidationError{}

// Validate checks the field values on ProtectionHandle with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProtectionHandle) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProtectionHandle with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProtectionHandleMultiError, or nil if none found.
func (m *ProtectionHandle) ValidateAll() error {
	return m.validate(true)
}

func (m *ProtectionHandle) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Id

	if len(errors) > 0 {
		return ProtectionHandleMultiError(errors)
	}

	return nil
}

// ProtectionHandleMultiError is an error wrapping multiple validation errors
// returned by ProtectionHandle.ValidateAll() if the designated constraints
// aren't met.
type ProtectionHandleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProtectionHandleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProtectionHandleMultiError) AllErrors() []error { return m }

// ProtectionHandleValidationError is the validation error returned by
// ProtectionHandle.Validate if the designated constraints aren't met.
type ProtectionHandleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProtectionHandleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProtectionHandleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProtectionHandleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProtectionHandleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProtectionHandleValidationError) ErrorName() string { return "ProtectionHandleValidationError" }

// Error satisfies the builtin error interface
func (e ProtectionHandleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProtectionHandle.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProtectionHandleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProtectionHandleValidationError{}

// Validate checks the field values on PermissionDeniedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PermissionDeniedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PermissionDeniedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PermissionDeniedEventMultiError, or nil if none found.
func (m *PermissionDeniedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *PermissionDeniedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Action

	switch v := m.Target.(type) {
	case *PermissionDeniedEvent_Application:
		if v == nil {
			err := PermissionDeniedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplication()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PermissionDeniedEventValidationError{
						field:  "Application",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PermissionDeniedEventValidationError{
						field:  "Application",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplication()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PermissionDeniedEventValidationError{
					field:  "Application",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PermissionDeniedEvent_ReleaseChannel:
		if v == nil {
			err := PermissionDeniedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReleaseChannel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PermissionDeniedEventValidationError{
						field:  "ReleaseChannel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PermissionDeniedEventValidationError{
						field:  "ReleaseChannel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReleaseChannel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PermissionDeniedEventValidationError{
					field:  "ReleaseChannel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PermissionDeniedEvent_Service:
		if v == nil {
			err := PermissionDeniedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PermissionDeniedEventValidationError{
						field:  "Service",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PermissionDeniedEventValidationError{
						field:  "Service",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PermissionDeniedEventValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PermissionDeniedEvent_Runtime:
		if v == nil {
			err := PermissionDeniedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRuntime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PermissionDeniedEventValidationError{
						field:  "Runtime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PermissionDeniedEventValidationError{
						field:  "Runtime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRuntime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PermissionDeniedEventValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PermissionDeniedEvent_Protection:
		if v == nil {
			err := PermissionDeniedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProtection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PermissionDeniedEventValidationError{
						field:  "Protection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PermissionDeniedEventValidationError{
						field:  "Protection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProtection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PermissionDeniedEventValidationError{
					field:  "Protection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return PermissionDeniedEventMultiError(errors)
	}

	return nil
}

// PermissionDeniedEventMultiError is an error wrapping multiple validation
// errors returned by PermissionDeniedEvent.ValidateAll() if the designated
// constraints aren't met.
type PermissionDeniedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PermissionDeniedEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PermissionDeniedEventMultiError) AllErrors() []error { return m }

// PermissionDeniedEventValidationError is the validation error returned by
// PermissionDeniedEvent.Validate if the designated constraints aren't met.
type PermissionDeniedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PermissionDeniedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PermissionDeniedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PermissionDeniedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PermissionDeniedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PermissionDeniedEventValidationError) ErrorName() string {
	return "PermissionDeniedEventValidationError"
}

// Error satisfies the builtin error interface
func (e PermissionDeniedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPermissionDeniedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PermissionDeniedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PermissionDeniedEventValidationError{}

// Validate checks the field values on ObjectCreatedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ObjectCreatedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ObjectCreatedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ObjectCreatedEventMultiError, or nil if none found.
func (m *ObjectCreatedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ObjectCreatedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConfigVersion

	switch v := m.Target.(type) {
	case *ObjectCreatedEvent_Application:
		if v == nil {
			err := ObjectCreatedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplication()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectCreatedEventValidationError{
						field:  "Application",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectCreatedEventValidationError{
						field:  "Application",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplication()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectCreatedEventValidationError{
					field:  "Application",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ObjectCreatedEvent_ReleaseChannel:
		if v == nil {
			err := ObjectCreatedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReleaseChannel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectCreatedEventValidationError{
						field:  "ReleaseChannel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectCreatedEventValidationError{
						field:  "ReleaseChannel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReleaseChannel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectCreatedEventValidationError{
					field:  "ReleaseChannel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ObjectCreatedEvent_Service:
		if v == nil {
			err := ObjectCreatedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectCreatedEventValidationError{
						field:  "Service",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectCreatedEventValidationError{
						field:  "Service",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectCreatedEventValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ObjectCreatedEvent_Runtime:
		if v == nil {
			err := ObjectCreatedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRuntime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectCreatedEventValidationError{
						field:  "Runtime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectCreatedEventValidationError{
						field:  "Runtime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRuntime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectCreatedEventValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ObjectCreatedEvent_Protection:
		if v == nil {
			err := ObjectCreatedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProtection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectCreatedEventValidationError{
						field:  "Protection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectCreatedEventValidationError{
						field:  "Protection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProtection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectCreatedEventValidationError{
					field:  "Protection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ObjectCreatedEventMultiError(errors)
	}

	return nil
}

// ObjectCreatedEventMultiError is an error wrapping multiple validation errors
// returned by ObjectCreatedEvent.ValidateAll() if the designated constraints
// aren't met.
type ObjectCreatedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObjectCreatedEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObjectCreatedEventMultiError) AllErrors() []error { return m }

// ObjectCreatedEventValidationError is the validation error returned by
// ObjectCreatedEvent.Validate if the designated constraints aren't met.
type ObjectCreatedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObjectCreatedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObjectCreatedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObjectCreatedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObjectCreatedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObjectCreatedEventValidationError) ErrorName() string {
	return "ObjectCreatedEventValidationError"
}

// Error satisfies the builtin error interface
func (e ObjectCreatedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObjectCreatedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObjectCreatedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObjectCreatedEventValidationError{}

// Validate checks the field values on ObjectDeletedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ObjectDeletedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ObjectDeletedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ObjectDeletedEventMultiError, or nil if none found.
func (m *ObjectDeletedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ObjectDeletedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConfigVersion

	switch v := m.Target.(type) {
	case *ObjectDeletedEvent_Application:
		if v == nil {
			err := ObjectDeletedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplication()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectDeletedEventValidationError{
						field:  "Application",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectDeletedEventValidationError{
						field:  "Application",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplication()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectDeletedEventValidationError{
					field:  "Application",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ObjectDeletedEvent_ReleaseChannel:
		if v == nil {
			err := ObjectDeletedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReleaseChannel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectDeletedEventValidationError{
						field:  "ReleaseChannel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectDeletedEventValidationError{
						field:  "ReleaseChannel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReleaseChannel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectDeletedEventValidationError{
					field:  "ReleaseChannel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ObjectDeletedEvent_Service:
		if v == nil {
			err := ObjectDeletedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectDeletedEventValidationError{
						field:  "Service",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectDeletedEventValidationError{
						field:  "Service",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectDeletedEventValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ObjectDeletedEvent_Runtime:
		if v == nil {
			err := ObjectDeletedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRuntime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectDeletedEventValidationError{
						field:  "Runtime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectDeletedEventValidationError{
						field:  "Runtime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRuntime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectDeletedEventValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ObjectDeletedEvent_Protection:
		if v == nil {
			err := ObjectDeletedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProtection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectDeletedEventValidationError{
						field:  "Protection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectDeletedEventValidationError{
						field:  "Protection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProtection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectDeletedEventValidationError{
					field:  "Protection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ObjectDeletedEventMultiError(errors)
	}

	return nil
}

// ObjectDeletedEventMultiError is an error wrapping multiple validation errors
// returned by ObjectDeletedEvent.ValidateAll() if the designated constraints
// aren't met.
type ObjectDeletedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObjectDeletedEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObjectDeletedEventMultiError) AllErrors() []error { return m }

// ObjectDeletedEventValidationError is the validation error returned by
// ObjectDeletedEvent.Validate if the designated constraints aren't met.
type ObjectDeletedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObjectDeletedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObjectDeletedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObjectDeletedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObjectDeletedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObjectDeletedEventValidationError) ErrorName() string {
	return "ObjectDeletedEventValidationError"
}

// Error satisfies the builtin error interface
func (e ObjectDeletedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObjectDeletedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObjectDeletedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObjectDeletedEventValidationError{}

// Validate checks the field values on ObjectModifiedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ObjectModifiedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ObjectModifiedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ObjectModifiedEventMultiError, or nil if none found.
func (m *ObjectModifiedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ObjectModifiedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OldConfigVersion

	// no validation rules for NewConfigVersion

	switch v := m.Target.(type) {
	case *ObjectModifiedEvent_Application:
		if v == nil {
			err := ObjectModifiedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplication()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectModifiedEventValidationError{
						field:  "Application",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectModifiedEventValidationError{
						field:  "Application",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplication()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectModifiedEventValidationError{
					field:  "Application",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ObjectModifiedEvent_ReleaseChannel:
		if v == nil {
			err := ObjectModifiedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReleaseChannel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectModifiedEventValidationError{
						field:  "ReleaseChannel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectModifiedEventValidationError{
						field:  "ReleaseChannel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReleaseChannel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectModifiedEventValidationError{
					field:  "ReleaseChannel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ObjectModifiedEvent_Service:
		if v == nil {
			err := ObjectModifiedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectModifiedEventValidationError{
						field:  "Service",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectModifiedEventValidationError{
						field:  "Service",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectModifiedEventValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ObjectModifiedEvent_Runtime:
		if v == nil {
			err := ObjectModifiedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRuntime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectModifiedEventValidationError{
						field:  "Runtime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectModifiedEventValidationError{
						field:  "Runtime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRuntime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectModifiedEventValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ObjectModifiedEvent_Protection:
		if v == nil {
			err := ObjectModifiedEventValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProtection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectModifiedEventValidationError{
						field:  "Protection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectModifiedEventValidationError{
						field:  "Protection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProtection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectModifiedEventValidationError{
					field:  "Protection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ObjectModifiedEventMultiError(errors)
	}

	return nil
}

// ObjectModifiedEventMultiError is an error wrapping multiple validation
// errors returned by ObjectModifiedEvent.ValidateAll() if the designated
// constraints aren't met.
type ObjectModifiedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObjectModifiedEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObjectModifiedEventMultiError) AllErrors() []error { return m }

// ObjectModifiedEventValidationError is the validation error returned by
// ObjectModifiedEvent.Validate if the designated constraints aren't met.
type ObjectModifiedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObjectModifiedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObjectModifiedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObjectModifiedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObjectModifiedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObjectModifiedEventValidationError) ErrorName() string {
	return "ObjectModifiedEventValidationError"
}

// Error satisfies the builtin error interface
func (e ObjectModifiedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObjectModifiedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObjectModifiedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObjectModifiedEventValidationError{}

// Validate checks the field values on DeploymentCreatedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeploymentCreatedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeploymentCreatedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeploymentCreatedEventMultiError, or nil if none found.
func (m *DeploymentCreatedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DeploymentCreatedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDeployment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeploymentCreatedEventValidationError{
					field:  "Deployment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeploymentCreatedEventValidationError{
					field:  "Deployment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeployment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeploymentCreatedEventValidationError{
				field:  "Deployment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeploymentCreatedEventMultiError(errors)
	}

	return nil
}

// DeploymentCreatedEventMultiError is an error wrapping multiple validation
// errors returned by DeploymentCreatedEvent.ValidateAll() if the designated
// constraints aren't met.
type DeploymentCreatedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeploymentCreatedEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeploymentCreatedEventMultiError) AllErrors() []error { return m }

// DeploymentCreatedEventValidationError is the validation error returned by
// DeploymentCreatedEvent.Validate if the designated constraints aren't met.
type DeploymentCreatedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeploymentCreatedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeploymentCreatedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeploymentCreatedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeploymentCreatedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeploymentCreatedEventValidationError) ErrorName() string {
	return "DeploymentCreatedEventValidationError"
}

// Error satisfies the builtin error interface
func (e DeploymentCreatedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeploymentCreatedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeploymentCreatedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeploymentCreatedEventValidationError{}

// Validate checks the field values on DeploymentUpdatedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeploymentUpdatedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeploymentUpdatedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeploymentUpdatedEventMultiError, or nil if none found.
func (m *DeploymentUpdatedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DeploymentUpdatedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDeployment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeploymentUpdatedEventValidationError{
					field:  "Deployment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeploymentUpdatedEventValidationError{
					field:  "Deployment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeployment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeploymentUpdatedEventValidationError{
				field:  "Deployment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OldStatus

	if len(errors) > 0 {
		return DeploymentUpdatedEventMultiError(errors)
	}

	return nil
}

// DeploymentUpdatedEventMultiError is an error wrapping multiple validation
// errors returned by DeploymentUpdatedEvent.ValidateAll() if the designated
// constraints aren't met.
type DeploymentUpdatedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeploymentUpdatedEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeploymentUpdatedEventMultiError) AllErrors() []error { return m }

// DeploymentUpdatedEventValidationError is the validation error returned by
// DeploymentUpdatedEvent.Validate if the designated constraints aren't met.
type DeploymentUpdatedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeploymentUpdatedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeploymentUpdatedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeploymentUpdatedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeploymentUpdatedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeploymentUpdatedEventValidationError) ErrorName() string {
	return "DeploymentUpdatedEventValidationError"
}

// Error satisfies the builtin error interface
func (e DeploymentUpdatedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeploymentUpdatedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeploymentUpdatedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeploymentUpdatedEventValidationError{}

// Validate checks the field values on KubectlCmdEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *KubectlCmdEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KubectlCmdEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KubectlCmdEventMultiError, or nil if none found.
func (m *KubectlCmdEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *KubectlCmdEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Runtime

	// no validation rules for ExitCode

	if len(errors) > 0 {
		return KubectlCmdEventMultiError(errors)
	}

	return nil
}

// KubectlCmdEventMultiError is an error wrapping multiple validation errors
// returned by KubectlCmdEvent.ValidateAll() if the designated constraints
// aren't met.
type KubectlCmdEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KubectlCmdEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KubectlCmdEventMultiError) AllErrors() []error { return m }

// KubectlCmdEventValidationError is the validation error returned by
// KubectlCmdEvent.Validate if the designated constraints aren't met.
type KubectlCmdEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KubectlCmdEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KubectlCmdEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KubectlCmdEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KubectlCmdEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KubectlCmdEventValidationError) ErrorName() string { return "KubectlCmdEventValidationError" }

// Error satisfies the builtin error interface
func (e KubectlCmdEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKubectlCmdEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KubectlCmdEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KubectlCmdEventValidationError{}

// Validate checks the field values on AuditLogDebugEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuditLogDebugEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuditLogDebugEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuditLogDebugEventMultiError, or nil if none found.
func (m *AuditLogDebugEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *AuditLogDebugEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Details

	if len(errors) > 0 {
		return AuditLogDebugEventMultiError(errors)
	}

	return nil
}

// AuditLogDebugEventMultiError is an error wrapping multiple validation errors
// returned by AuditLogDebugEvent.ValidateAll() if the designated constraints
// aren't met.
type AuditLogDebugEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuditLogDebugEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuditLogDebugEventMultiError) AllErrors() []error { return m }

// AuditLogDebugEventValidationError is the validation error returned by
// AuditLogDebugEvent.Validate if the designated constraints aren't met.
type AuditLogDebugEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuditLogDebugEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuditLogDebugEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuditLogDebugEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuditLogDebugEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuditLogDebugEventValidationError) ErrorName() string {
	return "AuditLogDebugEventValidationError"
}

// Error satisfies the builtin error interface
func (e AuditLogDebugEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuditLogDebugEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuditLogDebugEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuditLogDebugEventValidationError{}

// Validate checks the field values on ReleaseCreatedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReleaseCreatedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseCreatedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReleaseCreatedEventMultiError, or nil if none found.
func (m *ReleaseCreatedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseCreatedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReleaseCreatedEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReleaseCreatedEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReleaseCreatedEventValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ReleaseId

	if all {
		switch v := interface{}(m.GetDesired()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReleaseCreatedEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReleaseCreatedEventValidationError{
					field:  "Desired",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDesired()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReleaseCreatedEventValidationError{
				field:  "Desired",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsRollback

	if len(errors) > 0 {
		return ReleaseCreatedEventMultiError(errors)
	}

	return nil
}

// ReleaseCreatedEventMultiError is an error wrapping multiple validation
// errors returned by ReleaseCreatedEvent.ValidateAll() if the designated
// constraints aren't met.
type ReleaseCreatedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseCreatedEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseCreatedEventMultiError) AllErrors() []error { return m }

// ReleaseCreatedEventValidationError is the validation error returned by
// ReleaseCreatedEvent.Validate if the designated constraints aren't met.
type ReleaseCreatedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseCreatedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseCreatedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseCreatedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseCreatedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseCreatedEventValidationError) ErrorName() string {
	return "ReleaseCreatedEventValidationError"
}

// Error satisfies the builtin error interface
func (e ReleaseCreatedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseCreatedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseCreatedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseCreatedEventValidationError{}

// Validate checks the field values on EventDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EventDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EventDetailsMultiError, or
// nil if none found.
func (m *EventDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *EventDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Details.(type) {
	case *EventDetails_SetDesiredState:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetDesiredState()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "SetDesiredState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "SetDesiredState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetDesiredState()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "SetDesiredState",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_SetTargetState:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetTargetState()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "SetTargetState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "SetTargetState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetTargetState()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "SetTargetState",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_ProgramExit:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProgramExit()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ProgramExit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ProgramExit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProgramExit()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "ProgramExit",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_ApplyTargetState:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplyTargetState()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ApplyTargetState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ApplyTargetState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplyTargetState()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "ApplyTargetState",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_ManualApproval:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetManualApproval()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ManualApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ManualApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetManualApproval()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "ManualApproval",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_RuntimeUpdate:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRuntimeUpdate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "RuntimeUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "RuntimeUpdate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRuntimeUpdate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "RuntimeUpdate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_DeliveryProgress:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeliveryProgress()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DeliveryProgress",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DeliveryProgress",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeliveryProgress()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "DeliveryProgress",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_DeliveryPromotion:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeliveryPromotion()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DeliveryPromotion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DeliveryPromotion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeliveryPromotion()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "DeliveryPromotion",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_DesiredStateStatusChange:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDesiredStateStatusChange()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DesiredStateStatusChange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DesiredStateStatusChange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDesiredStateStatusChange()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "DesiredStateStatusChange",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_KeyDeliveryDecision:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKeyDeliveryDecision()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "KeyDeliveryDecision",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "KeyDeliveryDecision",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKeyDeliveryDecision()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "KeyDeliveryDecision",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_RpcCall:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRpcCall()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "RpcCall",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "RpcCall",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRpcCall()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "RpcCall",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_PermissionDenied:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPermissionDenied()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "PermissionDenied",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "PermissionDenied",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPermissionDenied()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "PermissionDenied",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_ObjectCreated:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetObjectCreated()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ObjectCreated",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ObjectCreated",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetObjectCreated()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "ObjectCreated",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_ObjectDeleted:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetObjectDeleted()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ObjectDeleted",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ObjectDeleted",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetObjectDeleted()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "ObjectDeleted",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_ObjectModified:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetObjectModified()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ObjectModified",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ObjectModified",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetObjectModified()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "ObjectModified",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_KubectlCmd:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKubectlCmd()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "KubectlCmd",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "KubectlCmd",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKubectlCmd()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "KubectlCmd",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_AuditLogDebug:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuditLogDebug()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "AuditLogDebug",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "AuditLogDebug",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuditLogDebug()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "AuditLogDebug",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_DeploymentCreated:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeploymentCreated()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DeploymentCreated",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DeploymentCreated",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeploymentCreated()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "DeploymentCreated",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_DeploymentUpdated:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeploymentUpdated()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DeploymentUpdated",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "DeploymentUpdated",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeploymentUpdated()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "DeploymentUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventDetails_ReleaseCreated:
		if v == nil {
			err := EventDetailsValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReleaseCreated()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ReleaseCreated",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDetailsValidationError{
						field:  "ReleaseCreated",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReleaseCreated()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDetailsValidationError{
					field:  "ReleaseCreated",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EventDetailsMultiError(errors)
	}

	return nil
}

// EventDetailsMultiError is an error wrapping multiple validation errors
// returned by EventDetails.ValidateAll() if the designated constraints aren't met.
type EventDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventDetailsMultiError) AllErrors() []error { return m }

// EventDetailsValidationError is the validation error returned by
// EventDetails.Validate if the designated constraints aren't met.
type EventDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventDetailsValidationError) ErrorName() string { return "EventDetailsValidationError" }

// Error satisfies the builtin error interface
func (e EventDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventDetailsValidationError{}
