// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: prodvana/desired_state/model/desired_state.proto

package model

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	common_config "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/common_config"

	environment "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/environment"

	extensions "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/runtimes/extensions"

	version "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/version"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = common_config.TaskLifecycle(0)

	_ = environment.ExtensionType(0)

	_ = extensions.FetchMode(0)

	_ = version.Source(0)
)

// Validate checks the field values on ProtectionLink with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProtectionLink) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProtectionLink with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProtectionLinkMultiError,
// or nil if none found.
func (m *ProtectionLink) ValidateAll() error {
	return m.validate(true)
}

func (m *ProtectionLink) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLifecycle()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionLinkValidationError{
					field:  "Lifecycle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionLinkValidationError{
					field:  "Lifecycle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLifecycle()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionLinkValidationError{
				field:  "Lifecycle",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AttachmentId

	if len(errors) > 0 {
		return ProtectionLinkMultiError(errors)
	}

	return nil
}

// ProtectionLinkMultiError is an error wrapping multiple validation errors
// returned by ProtectionLink.ValidateAll() if the designated constraints
// aren't met.
type ProtectionLinkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProtectionLinkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProtectionLinkMultiError) AllErrors() []error { return m }

// ProtectionLinkValidationError is the validation error returned by
// ProtectionLink.Validate if the designated constraints aren't met.
type ProtectionLinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProtectionLinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProtectionLinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProtectionLinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProtectionLinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProtectionLinkValidationError) ErrorName() string { return "ProtectionLinkValidationError" }

// Error satisfies the builtin error interface
func (e ProtectionLinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProtectionLink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProtectionLinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProtectionLinkValidationError{}

// Validate checks the field values on Condition with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Condition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Condition with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConditionMultiError, or nil
// if none found.
func (m *Condition) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DesiredStateId

	switch v := m.Condition.(type) {
	case *Condition_RcCond:
		if v == nil {
			err := ConditionValidationError{
				field:  "Condition",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRcCond()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "RcCond",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "RcCond",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRcCond()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "RcCond",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Condition_ManualApproval_:
		if v == nil {
			err := ConditionValidationError{
				field:  "Condition",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetManualApproval()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "ManualApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "ManualApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetManualApproval()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "ManualApproval",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Condition_CustomTask:
		if v == nil {
			err := ConditionValidationError{
				field:  "Condition",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCustomTask()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "CustomTask",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "CustomTask",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCustomTask()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "CustomTask",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ConditionMultiError(errors)
	}

	return nil
}

// ConditionMultiError is an error wrapping multiple validation errors returned
// by Condition.ValidateAll() if the designated constraints aren't met.
type ConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConditionMultiError) AllErrors() []error { return m }

// ConditionValidationError is the validation error returned by
// Condition.Validate if the designated constraints aren't met.
type ConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConditionValidationError) ErrorName() string { return "ConditionValidationError" }

// Error satisfies the builtin error interface
func (e ConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConditionValidationError{}

// Validate checks the field values on DeliveryExtension with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeliveryExtension) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryExtension with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeliveryExtensionMultiError, or nil if none found.
func (m *DeliveryExtension) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryExtension) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Lifecycle

	for idx, item := range m.GetReferences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryExtensionValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryExtensionValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryExtensionValidationError{
					field:  fmt.Sprintf("References[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeliveryExtensionMultiError(errors)
	}

	return nil
}

// DeliveryExtensionMultiError is an error wrapping multiple validation errors
// returned by DeliveryExtension.ValidateAll() if the designated constraints
// aren't met.
type DeliveryExtensionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryExtensionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryExtensionMultiError) AllErrors() []error { return m }

// DeliveryExtensionValidationError is the validation error returned by
// DeliveryExtension.Validate if the designated constraints aren't met.
type DeliveryExtensionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryExtensionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryExtensionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryExtensionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryExtensionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryExtensionValidationError) ErrorName() string {
	return "DeliveryExtensionValidationError"
}

// Error satisfies the builtin error interface
func (e DeliveryExtensionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryExtension.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryExtensionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryExtensionValidationError{}

// Validate checks the field values on ProtectionAttachmentDefinition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProtectionAttachmentDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProtectionAttachmentDefinition with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ProtectionAttachmentDefinitionMultiError, or nil if none found.
func (m *ProtectionAttachmentDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *ProtectionAttachmentDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProtectionId

	// no validation rules for AttachmentId

	// no validation rules for ProtectionVersion

	if len(errors) > 0 {
		return ProtectionAttachmentDefinitionMultiError(errors)
	}

	return nil
}

// ProtectionAttachmentDefinitionMultiError is an error wrapping multiple
// validation errors returned by ProtectionAttachmentDefinition.ValidateAll()
// if the designated constraints aren't met.
type ProtectionAttachmentDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProtectionAttachmentDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProtectionAttachmentDefinitionMultiError) AllErrors() []error { return m }

// ProtectionAttachmentDefinitionValidationError is the validation error
// returned by ProtectionAttachmentDefinition.Validate if the designated
// constraints aren't met.
type ProtectionAttachmentDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProtectionAttachmentDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProtectionAttachmentDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProtectionAttachmentDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProtectionAttachmentDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProtectionAttachmentDefinitionValidationError) ErrorName() string {
	return "ProtectionAttachmentDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e ProtectionAttachmentDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProtectionAttachmentDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProtectionAttachmentDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProtectionAttachmentDefinitionValidationError{}

// Validate checks the field values on Identifier with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Identifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Identifier with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IdentifierMultiError, or
// nil if none found.
func (m *Identifier) ValidateAll() error {
	return m.validate(true)
}

func (m *Identifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Name

	if len(errors) > 0 {
		return IdentifierMultiError(errors)
	}

	return nil
}

// IdentifierMultiError is an error wrapping multiple validation errors
// returned by Identifier.ValidateAll() if the designated constraints aren't met.
type IdentifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IdentifierMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IdentifierMultiError) AllErrors() []error { return m }

// IdentifierValidationError is the validation error returned by
// Identifier.Validate if the designated constraints aren't met.
type IdentifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IdentifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IdentifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IdentifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IdentifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IdentifierValidationError) ErrorName() string { return "IdentifierValidationError" }

// Error satisfies the builtin error interface
func (e IdentifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIdentifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IdentifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IdentifierValidationError{}

// Validate checks the field values on ConcurrencyLimit with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ConcurrencyLimit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConcurrencyLimit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConcurrencyLimitMultiError, or nil if none found.
func (m *ConcurrencyLimit) ValidateAll() error {
	return m.validate(true)
}

func (m *ConcurrencyLimit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LimitId

	if len(errors) > 0 {
		return ConcurrencyLimitMultiError(errors)
	}

	return nil
}

// ConcurrencyLimitMultiError is an error wrapping multiple validation errors
// returned by ConcurrencyLimit.ValidateAll() if the designated constraints
// aren't met.
type ConcurrencyLimitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConcurrencyLimitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConcurrencyLimitMultiError) AllErrors() []error { return m }

// ConcurrencyLimitValidationError is the validation error returned by
// ConcurrencyLimit.Validate if the designated constraints aren't met.
type ConcurrencyLimitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConcurrencyLimitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConcurrencyLimitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConcurrencyLimitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConcurrencyLimitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConcurrencyLimitValidationError) ErrorName() string { return "ConcurrencyLimitValidationError" }

// Error satisfies the builtin error interface
func (e ConcurrencyLimitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConcurrencyLimit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConcurrencyLimitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConcurrencyLimitValidationError{}

// Validate checks the field values on Metadata with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Metadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Metadata with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetadataMultiError, or nil
// if none found.
func (m *Metadata) ValidateAll() error {
	return m.validate(true)
}

func (m *Metadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPreconditions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("Preconditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("Preconditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  fmt.Sprintf("Preconditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInvariants() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("Invariants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("Invariants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  fmt.Sprintf("Invariants[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSelf()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetadataValidationError{
					field:  "Self",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetadataValidationError{
					field:  "Self",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSelf()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetadataValidationError{
				field:  "Self",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DesiredStateId

	// no validation rules for RootDesiredStateId

	// no validation rules for ReleaseId

	for idx, item := range m.GetProtectionLinks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("ProtectionLinks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("ProtectionLinks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  fmt.Sprintf("ProtectionLinks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDeliveryExtensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetConvergenceProtectionAttachments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("ConvergenceProtectionAttachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("ConvergenceProtectionAttachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  fmt.Sprintf("ConvergenceProtectionAttachments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetConcurrencyLimits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("ConcurrencyLimits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("ConcurrencyLimits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  fmt.Sprintf("ConcurrencyLimits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TargetStateSetByParent

	// no validation rules for RequireApprovalBeforeApply

	// no validation rules for AppliesInObserverMode

	if all {
		switch v := interface{}(m.GetConvergenceGracePeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetadataValidationError{
					field:  "ConvergenceGracePeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetadataValidationError{
					field:  "ConvergenceGracePeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConvergenceGracePeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetadataValidationError{
				field:  "ConvergenceGracePeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetadataMultiError(errors)
	}

	return nil
}

// MetadataMultiError is an error wrapping multiple validation errors returned
// by Metadata.ValidateAll() if the designated constraints aren't met.
type MetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataMultiError) AllErrors() []error { return m }

// MetadataValidationError is the validation error returned by
// Metadata.Validate if the designated constraints aren't met.
type MetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataValidationError) ErrorName() string { return "MetadataValidationError" }

// Error satisfies the builtin error interface
func (e MetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataValidationError{}

// Validate checks the field values on StatusExplanation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StatusExplanation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatusExplanation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StatusExplanationMultiError, or nil if none found.
func (m *StatusExplanation) ValidateAll() error {
	return m.validate(true)
}

func (m *StatusExplanation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StatusExplanationValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StatusExplanationValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StatusExplanationValidationError{
				field:  "Subject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reason

	// no validation rules for Message

	if len(errors) > 0 {
		return StatusExplanationMultiError(errors)
	}

	return nil
}

// StatusExplanationMultiError is an error wrapping multiple validation errors
// returned by StatusExplanation.ValidateAll() if the designated constraints
// aren't met.
type StatusExplanationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatusExplanationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatusExplanationMultiError) AllErrors() []error { return m }

// StatusExplanationValidationError is the validation error returned by
// StatusExplanation.Validate if the designated constraints aren't met.
type StatusExplanationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatusExplanationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatusExplanationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatusExplanationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatusExplanationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatusExplanationValidationError) ErrorName() string {
	return "StatusExplanationValidationError"
}

// Error satisfies the builtin error interface
func (e StatusExplanationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatusExplanation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatusExplanationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatusExplanationValidationError{}

// Validate checks the field values on ActionExplanation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ActionExplanation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionExplanation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActionExplanationMultiError, or nil if none found.
func (m *ActionExplanation) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionExplanation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionExplanationValidationError{
					field:  "Ts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionExplanationValidationError{
					field:  "Ts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionExplanationValidationError{
				field:  "Ts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ActionType

	// no validation rules for Message

	if len(errors) > 0 {
		return ActionExplanationMultiError(errors)
	}

	return nil
}

// ActionExplanationMultiError is an error wrapping multiple validation errors
// returned by ActionExplanation.ValidateAll() if the designated constraints
// aren't met.
type ActionExplanationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionExplanationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionExplanationMultiError) AllErrors() []error { return m }

// ActionExplanationValidationError is the validation error returned by
// ActionExplanation.Validate if the designated constraints aren't met.
type ActionExplanationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionExplanationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionExplanationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionExplanationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionExplanationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionExplanationValidationError) ErrorName() string {
	return "ActionExplanationValidationError"
}

// Error satisfies the builtin error interface
func (e ActionExplanationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionExplanation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionExplanationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionExplanationValidationError{}

// Validate checks the field values on Version with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Version) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Version with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in VersionMultiError, or nil if none found.
func (m *Version) ValidateAll() error {
	return m.validate(true)
}

func (m *Version) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	// no validation rules for Replicas

	// no validation rules for AvailableReplicas

	if all {
		switch v := interface{}(m.GetPushTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VersionValidationError{
					field:  "PushTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VersionValidationError{
					field:  "PushTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPushTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VersionValidationError{
				field:  "PushTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Active

	// no validation rules for TargetReplicas

	// no validation rules for Dirty

	if len(errors) > 0 {
		return VersionMultiError(errors)
	}

	return nil
}

// VersionMultiError is an error wrapping multiple validation errors returned
// by Version.ValidateAll() if the designated constraints aren't met.
type VersionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VersionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VersionMultiError) AllErrors() []error { return m }

// VersionValidationError is the validation error returned by Version.Validate
// if the designated constraints aren't met.
type VersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VersionValidationError) ErrorName() string { return "VersionValidationError" }

// Error satisfies the builtin error interface
func (e VersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VersionValidationError{}

// Validate checks the field values on ServiceInstanceState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceInstanceState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceInstanceState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceInstanceStateMultiError, or nil if none found.
func (m *ServiceInstanceState) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceInstanceState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceInstanceStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceInstanceStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceInstanceStateValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Application

	// no validation rules for Service

	// no validation rules for ReleaseChannel

	// no validation rules for ServiceId

	// no validation rules for ReleaseChannelId

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceInstanceStateValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceInstanceStateValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceInstanceStateValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Rollback

	if all {
		switch v := interface{}(m.GetDelivery()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceInstanceStateValidationError{
					field:  "Delivery",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceInstanceStateValidationError{
					field:  "Delivery",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDelivery()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceInstanceStateValidationError{
				field:  "Delivery",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DeploymentOwnedByChildren

	switch v := m.AutorollbackOneof.(type) {
	case *ServiceInstanceState_RollbackVersion:
		if v == nil {
			err := ServiceInstanceStateValidationError{
				field:  "AutorollbackOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRollbackVersion()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceInstanceStateValidationError{
						field:  "RollbackVersion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceInstanceStateValidationError{
						field:  "RollbackVersion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRollbackVersion()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceInstanceStateValidationError{
					field:  "RollbackVersion",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceInstanceState_ComputeRollbackVersion:
		if v == nil {
			err := ServiceInstanceStateValidationError{
				field:  "AutorollbackOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ComputeRollbackVersion
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ServiceInstanceStateMultiError(errors)
	}

	return nil
}

// ServiceInstanceStateMultiError is an error wrapping multiple validation
// errors returned by ServiceInstanceState.ValidateAll() if the designated
// constraints aren't met.
type ServiceInstanceStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceInstanceStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceInstanceStateMultiError) AllErrors() []error { return m }

// ServiceInstanceStateValidationError is the validation error returned by
// ServiceInstanceState.Validate if the designated constraints aren't met.
type ServiceInstanceStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceInstanceStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceInstanceStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceInstanceStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceInstanceStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceInstanceStateValidationError) ErrorName() string {
	return "ServiceInstanceStateValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceInstanceStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceInstanceState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceInstanceStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceInstanceStateValidationError{}

// Validate checks the field values on ServiceState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServiceState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServiceStateMultiError, or
// nil if none found.
func (m *ServiceState) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceStateValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Application

	// no validation rules for Service

	// no validation rules for ServiceId

	for idx, item := range m.GetReleaseChannels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceStateValidationError{
						field:  fmt.Sprintf("ReleaseChannels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceStateValidationError{
						field:  fmt.Sprintf("ReleaseChannels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceStateValidationError{
					field:  fmt.Sprintf("ReleaseChannels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCustomTasks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceStateValidationError{
						field:  fmt.Sprintf("CustomTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceStateValidationError{
						field:  fmt.Sprintf("CustomTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceStateValidationError{
					field:  fmt.Sprintf("CustomTasks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDeliveryExtensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceStateValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceStateValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceStateValidationError{
					field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetReleaseChannelLabelSelectors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceStateValidationError{
						field:  fmt.Sprintf("ReleaseChannelLabelSelectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceStateValidationError{
						field:  fmt.Sprintf("ReleaseChannelLabelSelectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceStateValidationError{
					field:  fmt.Sprintf("ReleaseChannelLabelSelectors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServiceStateMultiError(errors)
	}

	return nil
}

// ServiceStateMultiError is an error wrapping multiple validation errors
// returned by ServiceState.ValidateAll() if the designated constraints aren't met.
type ServiceStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceStateMultiError) AllErrors() []error { return m }

// ServiceStateValidationError is the validation error returned by
// ServiceState.Validate if the designated constraints aren't met.
type ServiceStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceStateValidationError) ErrorName() string { return "ServiceStateValidationError" }

// Error satisfies the builtin error interface
func (e ServiceStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceStateValidationError{}

// Validate checks the field values on ServiceInstanceLabelSelector with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceInstanceLabelSelector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceInstanceLabelSelector with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceInstanceLabelSelectorMultiError, or nil if none found.
func (m *ServiceInstanceLabelSelector) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceInstanceLabelSelector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceInstanceLabelSelectorValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceInstanceLabelSelectorValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceInstanceLabelSelectorValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	oneofSelectorOneofPresent := false
	switch v := m.SelectorOneof.(type) {
	case *ServiceInstanceLabelSelector_ReleaseChannelSelector:
		if v == nil {
			err := ServiceInstanceLabelSelectorValidationError{
				field:  "SelectorOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofSelectorOneofPresent = true
		// no validation rules for ReleaseChannelSelector
	case *ServiceInstanceLabelSelector_All:
		if v == nil {
			err := ServiceInstanceLabelSelectorValidationError{
				field:  "SelectorOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofSelectorOneofPresent = true
		// no validation rules for All
	default:
		_ = v // ensures v is used
	}
	if !oneofSelectorOneofPresent {
		err := ServiceInstanceLabelSelectorValidationError{
			field:  "SelectorOneof",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}
	switch v := m.AutorollbackOneof.(type) {
	case *ServiceInstanceLabelSelector_RollbackVersion:
		if v == nil {
			err := ServiceInstanceLabelSelectorValidationError{
				field:  "AutorollbackOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRollbackVersion()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceInstanceLabelSelectorValidationError{
						field:  "RollbackVersion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceInstanceLabelSelectorValidationError{
						field:  "RollbackVersion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRollbackVersion()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceInstanceLabelSelectorValidationError{
					field:  "RollbackVersion",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceInstanceLabelSelector_ComputeRollbackVersion:
		if v == nil {
			err := ServiceInstanceLabelSelectorValidationError{
				field:  "AutorollbackOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ComputeRollbackVersion
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ServiceInstanceLabelSelectorMultiError(errors)
	}

	return nil
}

// ServiceInstanceLabelSelectorMultiError is an error wrapping multiple
// validation errors returned by ServiceInstanceLabelSelector.ValidateAll() if
// the designated constraints aren't met.
type ServiceInstanceLabelSelectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceInstanceLabelSelectorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceInstanceLabelSelectorMultiError) AllErrors() []error { return m }

// ServiceInstanceLabelSelectorValidationError is the validation error returned
// by ServiceInstanceLabelSelector.Validate if the designated constraints
// aren't met.
type ServiceInstanceLabelSelectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceInstanceLabelSelectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceInstanceLabelSelectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceInstanceLabelSelectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceInstanceLabelSelectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceInstanceLabelSelectorValidationError) ErrorName() string {
	return "ServiceInstanceLabelSelectorValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceInstanceLabelSelectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceInstanceLabelSelector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceInstanceLabelSelectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceInstanceLabelSelectorValidationError{}

// Validate checks the field values on ServiceGroupState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ServiceGroupState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceGroupState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceGroupStateMultiError, or nil if none found.
func (m *ServiceGroupState) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceGroupState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceGroupStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceGroupStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceGroupStateValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetServices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceGroupStateValidationError{
						field:  fmt.Sprintf("Services[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceGroupStateValidationError{
						field:  fmt.Sprintf("Services[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceGroupStateValidationError{
					field:  fmt.Sprintf("Services[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCustomTasks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceGroupStateValidationError{
						field:  fmt.Sprintf("CustomTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceGroupStateValidationError{
						field:  fmt.Sprintf("CustomTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceGroupStateValidationError{
					field:  fmt.Sprintf("CustomTasks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDeliveryExtensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceGroupStateValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceGroupStateValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceGroupStateValidationError{
					field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServiceGroupStateMultiError(errors)
	}

	return nil
}

// ServiceGroupStateMultiError is an error wrapping multiple validation errors
// returned by ServiceGroupState.ValidateAll() if the designated constraints
// aren't met.
type ServiceGroupStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceGroupStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceGroupStateMultiError) AllErrors() []error { return m }

// ServiceGroupStateValidationError is the validation error returned by
// ServiceGroupState.Validate if the designated constraints aren't met.
type ServiceGroupStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceGroupStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceGroupStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceGroupStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceGroupStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceGroupStateValidationError) ErrorName() string {
	return "ServiceGroupStateValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceGroupStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceGroupState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceGroupStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceGroupStateValidationError{}

// Validate checks the field values on CanaryProgressState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CanaryProgressState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CanaryProgressState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CanaryProgressStateMultiError, or nil if none found.
func (m *CanaryProgressState) ValidateAll() error {
	return m.validate(true)
}

func (m *CanaryProgressState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if val := m.GetCanaryWeight(); val < 0 || val > 100 {
		err := CanaryProgressStateValidationError{
			field:  "CanaryWeight",
			reason: "value must be inside range [0, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDuration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CanaryProgressStateValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CanaryProgressStateValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDuration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CanaryProgressStateValidationError{
				field:  "Duration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPauseStartTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CanaryProgressStateValidationError{
					field:  "PauseStartTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CanaryProgressStateValidationError{
					field:  "PauseStartTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPauseStartTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CanaryProgressStateValidationError{
				field:  "PauseStartTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CanaryProgressStateMultiError(errors)
	}

	return nil
}

// CanaryProgressStateMultiError is an error wrapping multiple validation
// errors returned by CanaryProgressState.ValidateAll() if the designated
// constraints aren't met.
type CanaryProgressStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CanaryProgressStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CanaryProgressStateMultiError) AllErrors() []error { return m }

// CanaryProgressStateValidationError is the validation error returned by
// CanaryProgressState.Validate if the designated constraints aren't met.
type CanaryProgressStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CanaryProgressStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CanaryProgressStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CanaryProgressStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CanaryProgressStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CanaryProgressStateValidationError) ErrorName() string {
	return "CanaryProgressStateValidationError"
}

// Error satisfies the builtin error interface
func (e CanaryProgressStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCanaryProgressState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CanaryProgressStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CanaryProgressStateValidationError{}

// Validate checks the field values on BlueGreenProgressState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BlueGreenProgressState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlueGreenProgressState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BlueGreenProgressStateMultiError, or nil if none found.
func (m *BlueGreenProgressState) ValidateAll() error {
	return m.validate(true)
}

func (m *BlueGreenProgressState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if len(errors) > 0 {
		return BlueGreenProgressStateMultiError(errors)
	}

	return nil
}

// BlueGreenProgressStateMultiError is an error wrapping multiple validation
// errors returned by BlueGreenProgressState.ValidateAll() if the designated
// constraints aren't met.
type BlueGreenProgressStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlueGreenProgressStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlueGreenProgressStateMultiError) AllErrors() []error { return m }

// BlueGreenProgressStateValidationError is the validation error returned by
// BlueGreenProgressState.Validate if the designated constraints aren't met.
type BlueGreenProgressStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlueGreenProgressStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlueGreenProgressStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlueGreenProgressStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlueGreenProgressStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlueGreenProgressStateValidationError) ErrorName() string {
	return "BlueGreenProgressStateValidationError"
}

// Error satisfies the builtin error interface
func (e BlueGreenProgressStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlueGreenProgressState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlueGreenProgressStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlueGreenProgressStateValidationError{}

// Validate checks the field values on DeliveryState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeliveryState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeliveryStateMultiError, or
// nil if none found.
func (m *DeliveryState) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DesiredStateId

	// no validation rules for Status

	// no validation rules for Message

	for idx, item := range m.GetCanaryProgress() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryStateValidationError{
						field:  fmt.Sprintf("CanaryProgress[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryStateValidationError{
						field:  fmt.Sprintf("CanaryProgress[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryStateValidationError{
					field:  fmt.Sprintf("CanaryProgress[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for FirstRun

	// no validation rules for Generation

	if all {
		switch v := interface{}(m.GetBlueGreenProgress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryStateValidationError{
					field:  "BlueGreenProgress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryStateValidationError{
					field:  "BlueGreenProgress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlueGreenProgress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryStateValidationError{
				field:  "BlueGreenProgress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeliveryStateMultiError(errors)
	}

	return nil
}

// DeliveryStateMultiError is an error wrapping multiple validation errors
// returned by DeliveryState.ValidateAll() if the designated constraints
// aren't met.
type DeliveryStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryStateMultiError) AllErrors() []error { return m }

// DeliveryStateValidationError is the validation error returned by
// DeliveryState.Validate if the designated constraints aren't met.
type DeliveryStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryStateValidationError) ErrorName() string { return "DeliveryStateValidationError" }

// Error satisfies the builtin error interface
func (e DeliveryStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryStateValidationError{}

// Validate checks the field values on FetchDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FetchDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FetchDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FetchDetailsMultiError, or
// nil if none found.
func (m *FetchDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *FetchDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStartedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FetchDetailsValidationError{
					field:  "StartedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FetchDetailsValidationError{
					field:  "StartedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FetchDetailsValidationError{
				field:  "StartedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCompletedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FetchDetailsValidationError{
					field:  "CompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FetchDetailsValidationError{
					field:  "CompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompletedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FetchDetailsValidationError{
				field:  "CompletedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FetchPlanBlobId

	// no validation rules for FetchPlanExplanationBlobId

	// no validation rules for Version

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FetchDetailsValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FetchDetailsValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FetchDetailsValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RuntimeObjectStatus

	for idx, item := range m.GetExternalObjects() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FetchDetailsValidationError{
						field:  fmt.Sprintf("ExternalObjects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FetchDetailsValidationError{
						field:  fmt.Sprintf("ExternalObjects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FetchDetailsValidationError{
					field:  fmt.Sprintf("ExternalObjects[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for FetchStatus

	// no validation rules for FetcherDesiredStateId

	// no validation rules for Message

	// no validation rules for FetchMode

	if all {
		switch v := interface{}(m.GetTaskRun()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FetchDetailsValidationError{
					field:  "TaskRun",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FetchDetailsValidationError{
					field:  "TaskRun",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaskRun()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FetchDetailsValidationError{
				field:  "TaskRun",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FetchDetailsMultiError(errors)
	}

	return nil
}

// FetchDetailsMultiError is an error wrapping multiple validation errors
// returned by FetchDetails.ValidateAll() if the designated constraints aren't met.
type FetchDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FetchDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FetchDetailsMultiError) AllErrors() []error { return m }

// FetchDetailsValidationError is the validation error returned by
// FetchDetails.Validate if the designated constraints aren't met.
type FetchDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FetchDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FetchDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FetchDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FetchDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FetchDetailsValidationError) ErrorName() string { return "FetchDetailsValidationError" }

// Error satisfies the builtin error interface
func (e FetchDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFetchDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FetchDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FetchDetailsValidationError{}

// Validate checks the field values on RuntimeExtensionFetchOutput with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeExtensionFetchOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeExtensionFetchOutput with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RuntimeExtensionFetchOutputMultiError, or nil if none found.
func (m *RuntimeExtensionFetchOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeExtensionFetchOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOngoingFetch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeExtensionFetchOutputValidationError{
					field:  "OngoingFetch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeExtensionFetchOutputValidationError{
					field:  "OngoingFetch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOngoingFetch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeExtensionFetchOutputValidationError{
				field:  "OngoingFetch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastSuccessfulFetch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeExtensionFetchOutputValidationError{
					field:  "LastSuccessfulFetch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeExtensionFetchOutputValidationError{
					field:  "LastSuccessfulFetch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastSuccessfulFetch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeExtensionFetchOutputValidationError{
				field:  "LastSuccessfulFetch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastFailedFetch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeExtensionFetchOutputValidationError{
					field:  "LastFailedFetch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeExtensionFetchOutputValidationError{
					field:  "LastFailedFetch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastFailedFetch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeExtensionFetchOutputValidationError{
				field:  "LastFailedFetch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RuntimeExtensionFetchOutputMultiError(errors)
	}

	return nil
}

// RuntimeExtensionFetchOutputMultiError is an error wrapping multiple
// validation errors returned by RuntimeExtensionFetchOutput.ValidateAll() if
// the designated constraints aren't met.
type RuntimeExtensionFetchOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeExtensionFetchOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeExtensionFetchOutputMultiError) AllErrors() []error { return m }

// RuntimeExtensionFetchOutputValidationError is the validation error returned
// by RuntimeExtensionFetchOutput.Validate if the designated constraints
// aren't met.
type RuntimeExtensionFetchOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeExtensionFetchOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeExtensionFetchOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeExtensionFetchOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeExtensionFetchOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeExtensionFetchOutputValidationError) ErrorName() string {
	return "RuntimeExtensionFetchOutputValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeExtensionFetchOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeExtensionFetchOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeExtensionFetchOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeExtensionFetchOutputValidationError{}

// Validate checks the field values on RuntimeExtensionGetInfoOutputContent
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *RuntimeExtensionGetInfoOutputContent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeExtensionGetInfoOutputContent
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// RuntimeExtensionGetInfoOutputContentMultiError, or nil if none found.
func (m *RuntimeExtensionGetInfoOutputContent) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeExtensionGetInfoOutputContent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for BlobId

	if len(errors) > 0 {
		return RuntimeExtensionGetInfoOutputContentMultiError(errors)
	}

	return nil
}

// RuntimeExtensionGetInfoOutputContentMultiError is an error wrapping multiple
// validation errors returned by
// RuntimeExtensionGetInfoOutputContent.ValidateAll() if the designated
// constraints aren't met.
type RuntimeExtensionGetInfoOutputContentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeExtensionGetInfoOutputContentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeExtensionGetInfoOutputContentMultiError) AllErrors() []error { return m }

// RuntimeExtensionGetInfoOutputContentValidationError is the validation error
// returned by RuntimeExtensionGetInfoOutputContent.Validate if the designated
// constraints aren't met.
type RuntimeExtensionGetInfoOutputContentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeExtensionGetInfoOutputContentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeExtensionGetInfoOutputContentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeExtensionGetInfoOutputContentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeExtensionGetInfoOutputContentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeExtensionGetInfoOutputContentValidationError) ErrorName() string {
	return "RuntimeExtensionGetInfoOutputContentValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeExtensionGetInfoOutputContentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeExtensionGetInfoOutputContent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeExtensionGetInfoOutputContentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeExtensionGetInfoOutputContentValidationError{}

// Validate checks the field values on RuntimeExtensionGetInfoDetails with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeExtensionGetInfoDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeExtensionGetInfoDetails with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// RuntimeExtensionGetInfoDetailsMultiError, or nil if none found.
func (m *RuntimeExtensionGetInfoDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeExtensionGetInfoDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SystemMessage

	for idx, item := range m.GetContents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeExtensionGetInfoDetailsValidationError{
						field:  fmt.Sprintf("Contents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeExtensionGetInfoDetailsValidationError{
						field:  fmt.Sprintf("Contents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeExtensionGetInfoDetailsValidationError{
					field:  fmt.Sprintf("Contents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetStartedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeExtensionGetInfoDetailsValidationError{
					field:  "StartedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeExtensionGetInfoDetailsValidationError{
					field:  "StartedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeExtensionGetInfoDetailsValidationError{
				field:  "StartedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCompletedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeExtensionGetInfoDetailsValidationError{
					field:  "CompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeExtensionGetInfoDetailsValidationError{
					field:  "CompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompletedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeExtensionGetInfoDetailsValidationError{
				field:  "CompletedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Version

	if len(errors) > 0 {
		return RuntimeExtensionGetInfoDetailsMultiError(errors)
	}

	return nil
}

// RuntimeExtensionGetInfoDetailsMultiError is an error wrapping multiple
// validation errors returned by RuntimeExtensionGetInfoDetails.ValidateAll()
// if the designated constraints aren't met.
type RuntimeExtensionGetInfoDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeExtensionGetInfoDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeExtensionGetInfoDetailsMultiError) AllErrors() []error { return m }

// RuntimeExtensionGetInfoDetailsValidationError is the validation error
// returned by RuntimeExtensionGetInfoDetails.Validate if the designated
// constraints aren't met.
type RuntimeExtensionGetInfoDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeExtensionGetInfoDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeExtensionGetInfoDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeExtensionGetInfoDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeExtensionGetInfoDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeExtensionGetInfoDetailsValidationError) ErrorName() string {
	return "RuntimeExtensionGetInfoDetailsValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeExtensionGetInfoDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeExtensionGetInfoDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeExtensionGetInfoDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeExtensionGetInfoDetailsValidationError{}

// Validate checks the field values on RuntimeExtensionGetInfoOutput with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeExtensionGetInfoOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeExtensionGetInfoOutput with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// RuntimeExtensionGetInfoOutputMultiError, or nil if none found.
func (m *RuntimeExtensionGetInfoOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeExtensionGetInfoOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetInfoDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeExtensionGetInfoOutputValidationError{
					field:  "GetInfoDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeExtensionGetInfoOutputValidationError{
					field:  "GetInfoDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetInfoDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeExtensionGetInfoOutputValidationError{
				field:  "GetInfoDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RuntimeExtensionGetInfoOutputMultiError(errors)
	}

	return nil
}

// RuntimeExtensionGetInfoOutputMultiError is an error wrapping multiple
// validation errors returned by RuntimeExtensionGetInfoOutput.ValidateAll()
// if the designated constraints aren't met.
type RuntimeExtensionGetInfoOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeExtensionGetInfoOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeExtensionGetInfoOutputMultiError) AllErrors() []error { return m }

// RuntimeExtensionGetInfoOutputValidationError is the validation error
// returned by RuntimeExtensionGetInfoOutput.Validate if the designated
// constraints aren't met.
type RuntimeExtensionGetInfoOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeExtensionGetInfoOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeExtensionGetInfoOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeExtensionGetInfoOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeExtensionGetInfoOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeExtensionGetInfoOutputValidationError) ErrorName() string {
	return "RuntimeExtensionGetInfoOutputValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeExtensionGetInfoOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeExtensionGetInfoOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeExtensionGetInfoOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeExtensionGetInfoOutputValidationError{}

// Validate checks the field values on ApplyDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ApplyDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ApplyDetailsMultiError, or
// nil if none found.
func (m *ApplyDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStartedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyDetailsValidationError{
					field:  "StartedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyDetailsValidationError{
					field:  "StartedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyDetailsValidationError{
				field:  "StartedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCompletedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyDetailsValidationError{
					field:  "CompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyDetailsValidationError{
					field:  "CompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompletedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyDetailsValidationError{
				field:  "CompletedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Version

	// no validation rules for ApplyStatus

	if all {
		switch v := interface{}(m.GetFetchDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyDetailsValidationError{
					field:  "FetchDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyDetailsValidationError{
					field:  "FetchDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFetchDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyDetailsValidationError{
				field:  "FetchDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HasWorkReason

	if all {
		switch v := interface{}(m.GetTaskRun()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyDetailsValidationError{
					field:  "TaskRun",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyDetailsValidationError{
					field:  "TaskRun",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaskRun()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyDetailsValidationError{
				field:  "TaskRun",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ApplyDetailsMultiError(errors)
	}

	return nil
}

// ApplyDetailsMultiError is an error wrapping multiple validation errors
// returned by ApplyDetails.ValidateAll() if the designated constraints aren't met.
type ApplyDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyDetailsMultiError) AllErrors() []error { return m }

// ApplyDetailsValidationError is the validation error returned by
// ApplyDetails.Validate if the designated constraints aren't met.
type ApplyDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyDetailsValidationError) ErrorName() string { return "ApplyDetailsValidationError" }

// Error satisfies the builtin error interface
func (e ApplyDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyDetailsValidationError{}

// Validate checks the field values on RuntimeExtensionApplyOutput with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeExtensionApplyOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeExtensionApplyOutput with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RuntimeExtensionApplyOutputMultiError, or nil if none found.
func (m *RuntimeExtensionApplyOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeExtensionApplyOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOngoingApply()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeExtensionApplyOutputValidationError{
					field:  "OngoingApply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeExtensionApplyOutputValidationError{
					field:  "OngoingApply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOngoingApply()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeExtensionApplyOutputValidationError{
				field:  "OngoingApply",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastApply()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeExtensionApplyOutputValidationError{
					field:  "LastApply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeExtensionApplyOutputValidationError{
					field:  "LastApply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastApply()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeExtensionApplyOutputValidationError{
				field:  "LastApply",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RuntimeExtensionApplyOutputMultiError(errors)
	}

	return nil
}

// RuntimeExtensionApplyOutputMultiError is an error wrapping multiple
// validation errors returned by RuntimeExtensionApplyOutput.ValidateAll() if
// the designated constraints aren't met.
type RuntimeExtensionApplyOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeExtensionApplyOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeExtensionApplyOutputMultiError) AllErrors() []error { return m }

// RuntimeExtensionApplyOutputValidationError is the validation error returned
// by RuntimeExtensionApplyOutput.Validate if the designated constraints
// aren't met.
type RuntimeExtensionApplyOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeExtensionApplyOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeExtensionApplyOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeExtensionApplyOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeExtensionApplyOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeExtensionApplyOutputValidationError) ErrorName() string {
	return "RuntimeExtensionApplyOutputValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeExtensionApplyOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeExtensionApplyOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeExtensionApplyOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeExtensionApplyOutputValidationError{}

// Validate checks the field values on RuntimeObject with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RuntimeObject) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeObject with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RuntimeObjectMultiError, or
// nil if none found.
func (m *RuntimeObject) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeObject) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObjectValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ObjectType

	// no validation rules for Namespace

	// no validation rules for Name

	// no validation rules for GenerateName

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeObjectValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeObjectValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeObjectValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetFetchVersion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "FetchVersion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "FetchVersion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFetchVersion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObjectValidationError{
				field:  "FetchVersion",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetRollbackVersion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "RollbackVersion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "RollbackVersion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRollbackVersion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObjectValidationError{
				field:  "RollbackVersion",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDelivery()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "Delivery",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "Delivery",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDelivery()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObjectValidationError{
				field:  "Delivery",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VersionAgnostic

	// no validation rules for DesiredVersionDirtyOnly

	// no validation rules for Message

	for idx, item := range m.GetDebugEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeObjectValidationError{
						field:  fmt.Sprintf("DebugEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeObjectValidationError{
						field:  fmt.Sprintf("DebugEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeObjectValidationError{
					field:  fmt.Sprintf("DebugEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRuntimeExtension()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "RuntimeExtension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "RuntimeExtension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntimeExtension()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObjectValidationError{
				field:  "RuntimeExtension",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObjectValidationError{
				field:  "Interval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSteadyStateInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "SteadyStateInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "SteadyStateInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSteadyStateInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObjectValidationError{
				field:  "SteadyStateInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequireApprovalBeforeApply

	// no validation rules for RawConfig

	// no validation rules for ManagementStatus

	if all {
		switch v := interface{}(m.GetLastCompletedTaskRun()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "LastCompletedTaskRun",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "LastCompletedTaskRun",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastCompletedTaskRun()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObjectValidationError{
				field:  "LastCompletedTaskRun",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetExternalLinks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeObjectValidationError{
						field:  fmt.Sprintf("ExternalLinks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeObjectValidationError{
						field:  fmt.Sprintf("ExternalLinks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeObjectValidationError{
					field:  fmt.Sprintf("ExternalLinks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetExternalObjects() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeObjectValidationError{
						field:  fmt.Sprintf("ExternalObjects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeObjectValidationError{
						field:  fmt.Sprintf("ExternalObjects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeObjectValidationError{
					field:  fmt.Sprintf("ExternalObjects[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Rollback

	if len(errors) > 0 {
		return RuntimeObjectMultiError(errors)
	}

	return nil
}

// RuntimeObjectMultiError is an error wrapping multiple validation errors
// returned by RuntimeObject.ValidateAll() if the designated constraints
// aren't met.
type RuntimeObjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeObjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeObjectMultiError) AllErrors() []error { return m }

// RuntimeObjectValidationError is the validation error returned by
// RuntimeObject.Validate if the designated constraints aren't met.
type RuntimeObjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeObjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeObjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeObjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeObjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeObjectValidationError) ErrorName() string { return "RuntimeObjectValidationError" }

// Error satisfies the builtin error interface
func (e RuntimeObjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeObject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeObjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeObjectValidationError{}

// Validate checks the field values on ConditionState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConditionState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConditionState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConditionStateMultiError,
// or nil if none found.
func (m *ConditionState) ValidateAll() error {
	return m.validate(true)
}

func (m *ConditionState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if len(errors) > 0 {
		return ConditionStateMultiError(errors)
	}

	return nil
}

// ConditionStateMultiError is an error wrapping multiple validation errors
// returned by ConditionState.ValidateAll() if the designated constraints
// aren't met.
type ConditionStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConditionStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConditionStateMultiError) AllErrors() []error { return m }

// ConditionStateValidationError is the validation error returned by
// ConditionState.Validate if the designated constraints aren't met.
type ConditionStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConditionStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConditionStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConditionStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConditionStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConditionStateValidationError) ErrorName() string { return "ConditionStateValidationError" }

// Error satisfies the builtin error interface
func (e ConditionStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConditionState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConditionStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConditionStateValidationError{}

// Validate checks the field values on ApplyError with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ApplyError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyError with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ApplyErrorMultiError, or
// nil if none found.
func (m *ApplyError) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return ApplyErrorMultiError(errors)
	}

	return nil
}

// ApplyErrorMultiError is an error wrapping multiple validation errors
// returned by ApplyError.ValidateAll() if the designated constraints aren't met.
type ApplyErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyErrorMultiError) AllErrors() []error { return m }

// ApplyErrorValidationError is the validation error returned by
// ApplyError.Validate if the designated constraints aren't met.
type ApplyErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyErrorValidationError) ErrorName() string { return "ApplyErrorValidationError" }

// Error satisfies the builtin error interface
func (e ApplyErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyErrorValidationError{}

// Validate checks the field values on NotificationInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NotificationInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotificationInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NotificationInfoMultiError, or nil if none found.
func (m *NotificationInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *NotificationInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FailureCount

	if all {
		switch v := interface{}(m.GetMostRecentFailure()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotificationInfoValidationError{
					field:  "MostRecentFailure",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotificationInfoValidationError{
					field:  "MostRecentFailure",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMostRecentFailure()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotificationInfoValidationError{
				field:  "MostRecentFailure",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRuntimeFetchInvokeError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotificationInfoValidationError{
					field:  "RuntimeFetchInvokeError",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotificationInfoValidationError{
					field:  "RuntimeFetchInvokeError",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntimeFetchInvokeError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotificationInfoValidationError{
				field:  "RuntimeFetchInvokeError",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRuntimeApplyInvokeError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotificationInfoValidationError{
					field:  "RuntimeApplyInvokeError",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotificationInfoValidationError{
					field:  "RuntimeApplyInvokeError",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntimeApplyInvokeError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotificationInfoValidationError{
				field:  "RuntimeApplyInvokeError",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetConcurrencyLimitExceededErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NotificationInfoValidationError{
						field:  fmt.Sprintf("ConcurrencyLimitExceededErrors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NotificationInfoValidationError{
						field:  fmt.Sprintf("ConcurrencyLimitExceededErrors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NotificationInfoValidationError{
					field:  fmt.Sprintf("ConcurrencyLimitExceededErrors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NotificationInfoMultiError(errors)
	}

	return nil
}

// NotificationInfoMultiError is an error wrapping multiple validation errors
// returned by NotificationInfo.ValidateAll() if the designated constraints
// aren't met.
type NotificationInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotificationInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotificationInfoMultiError) AllErrors() []error { return m }

// NotificationInfoValidationError is the validation error returned by
// NotificationInfo.Validate if the designated constraints aren't met.
type NotificationInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotificationInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotificationInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotificationInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotificationInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotificationInfoValidationError) ErrorName() string { return "NotificationInfoValidationError" }

// Error satisfies the builtin error interface
func (e NotificationInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotificationInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotificationInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotificationInfoValidationError{}

// Validate checks the field values on ControlState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ControlState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ControlState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ControlStateMultiError, or
// nil if none found.
func (m *ControlState) ValidateAll() error {
	return m.validate(true)
}

func (m *ControlState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rollback

	for idx, item := range m.GetPreconditionStates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ControlStateValidationError{
						field:  fmt.Sprintf("PreconditionStates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ControlStateValidationError{
						field:  fmt.Sprintf("PreconditionStates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ControlStateValidationError{
					field:  fmt.Sprintf("PreconditionStates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInvariantStates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ControlStateValidationError{
						field:  fmt.Sprintf("InvariantStates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ControlStateValidationError{
						field:  fmt.Sprintf("InvariantStates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ControlStateValidationError{
					field:  fmt.Sprintf("InvariantStates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Paused

	for idx, item := range m.GetStatusExplanations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ControlStateValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ControlStateValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ControlStateValidationError{
					field:  fmt.Sprintf("StatusExplanations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetActionExplanation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "ActionExplanation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "ActionExplanation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActionExplanation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ControlStateValidationError{
				field:  "ActionExplanation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastFetchedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "LastFetchedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "LastFetchedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastFetchedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ControlStateValidationError{
				field:  "LastFetchedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastAppliedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "LastAppliedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "LastAppliedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastAppliedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ControlStateValidationError{
				field:  "LastAppliedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExpectedNextApplyTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "ExpectedNextApplyTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "ExpectedNextApplyTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpectedNextApplyTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ControlStateValidationError{
				field:  "ExpectedNextApplyTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMissingApproval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "MissingApproval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "MissingApproval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMissingApproval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ControlStateValidationError{
				field:  "MissingApproval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ObserverMode

	if all {
		switch v := interface{}(m.GetApplyError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "ApplyError",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "ApplyError",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApplyError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ControlStateValidationError{
				field:  "ApplyError",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNotificationInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "NotificationInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "NotificationInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNotificationInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ControlStateValidationError{
				field:  "NotificationInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ControlStateMultiError(errors)
	}

	return nil
}

// ControlStateMultiError is an error wrapping multiple validation errors
// returned by ControlState.ValidateAll() if the designated constraints aren't met.
type ControlStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ControlStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ControlStateMultiError) AllErrors() []error { return m }

// ControlStateValidationError is the validation error returned by
// ControlState.Validate if the designated constraints aren't met.
type ControlStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ControlStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ControlStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ControlStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ControlStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ControlStateValidationError) ErrorName() string { return "ControlStateValidationError" }

// Error satisfies the builtin error interface
func (e ControlStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sControlState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ControlStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ControlStateValidationError{}

// Validate checks the field values on ManualApprovalState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ManualApprovalState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ManualApprovalState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ManualApprovalStateMultiError, or nil if none found.
func (m *ManualApprovalState) ValidateAll() error {
	return m.validate(true)
}

func (m *ManualApprovalState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ManualApprovalStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ManualApprovalStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ManualApprovalStateValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	// no validation rules for Topic

	// no validation rules for Description

	for idx, item := range m.GetApprovers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ManualApprovalStateValidationError{
						field:  fmt.Sprintf("Approvers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ManualApprovalStateValidationError{
						field:  fmt.Sprintf("Approvers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ManualApprovalStateValidationError{
					field:  fmt.Sprintf("Approvers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for MinApprovers

	if len(errors) > 0 {
		return ManualApprovalStateMultiError(errors)
	}

	return nil
}

// ManualApprovalStateMultiError is an error wrapping multiple validation
// errors returned by ManualApprovalState.ValidateAll() if the designated
// constraints aren't met.
type ManualApprovalStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ManualApprovalStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ManualApprovalStateMultiError) AllErrors() []error { return m }

// ManualApprovalStateValidationError is the validation error returned by
// ManualApprovalState.Validate if the designated constraints aren't met.
type ManualApprovalStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ManualApprovalStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ManualApprovalStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ManualApprovalStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ManualApprovalStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ManualApprovalStateValidationError) ErrorName() string {
	return "ManualApprovalStateValidationError"
}

// Error satisfies the builtin error interface
func (e ManualApprovalStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sManualApprovalState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ManualApprovalStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ManualApprovalStateValidationError{}

// Validate checks the field values on State with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *State) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on State with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StateMultiError, or nil if none found.
func (m *State) ValidateAll() error {
	return m.validate(true)
}

func (m *State) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.StateOneof.(type) {
	case *State_Service:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "Service",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "Service",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_ServiceInstance:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetServiceInstance()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ServiceInstance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ServiceInstance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServiceInstance()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "ServiceInstance",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_ServiceGroup:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetServiceGroup()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ServiceGroup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ServiceGroup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServiceGroup()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "ServiceGroup",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_RuntimeObject:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRuntimeObject()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "RuntimeObject",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "RuntimeObject",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRuntimeObject()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "RuntimeObject",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_ManualApproval:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetManualApproval()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ManualApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ManualApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetManualApproval()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "ManualApproval",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_CustomTask:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCustomTask()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "CustomTask",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "CustomTask",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCustomTask()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "CustomTask",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_ProtectionAttachment:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProtectionAttachment()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ProtectionAttachment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ProtectionAttachment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProtectionAttachment()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "ProtectionAttachment",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_ProtectionLink:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProtectionLink()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ProtectionLink",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ProtectionLink",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProtectionLink()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "ProtectionLink",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_DeliveryExtension:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeliveryExtension()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "DeliveryExtension",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "DeliveryExtension",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeliveryExtension()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "DeliveryExtension",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return StateMultiError(errors)
	}

	return nil
}

// StateMultiError is an error wrapping multiple validation errors returned by
// State.ValidateAll() if the designated constraints aren't met.
type StateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StateMultiError) AllErrors() []error { return m }

// StateValidationError is the validation error returned by State.Validate if
// the designated constraints aren't met.
type StateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StateValidationError) ErrorName() string { return "StateValidationError" }

// Error satisfies the builtin error interface
func (e StateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StateValidationError{}

// Validate checks the field values on Annotations with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Annotations) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Annotations with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AnnotationsMultiError, or
// nil if none found.
func (m *Annotations) ValidateAll() error {
	return m.validate(true)
}

func (m *Annotations) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AnnotationsValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AnnotationsValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AnnotationsValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AnnotationsMultiError(errors)
	}

	return nil
}

// AnnotationsMultiError is an error wrapping multiple validation errors
// returned by Annotations.ValidateAll() if the designated constraints aren't met.
type AnnotationsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnnotationsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnnotationsMultiError) AllErrors() []error { return m }

// AnnotationsValidationError is the validation error returned by
// Annotations.Validate if the designated constraints aren't met.
type AnnotationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnnotationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnnotationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnnotationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnnotationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnnotationsValidationError) ErrorName() string { return "AnnotationsValidationError" }

// Error satisfies the builtin error interface
func (e AnnotationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnnotations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnnotationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnnotationsValidationError{}

// Validate checks the field values on CustomTaskExecutionState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CustomTaskExecutionState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CustomTaskExecutionState with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CustomTaskExecutionStateMultiError, or nil if none found.
func (m *CustomTaskExecutionState) ValidateAll() error {
	return m.validate(true)
}

func (m *CustomTaskExecutionState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Attempts

	if all {
		switch v := interface{}(m.GetLatestAttemptEndTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomTaskExecutionStateValidationError{
					field:  "LatestAttemptEndTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomTaskExecutionStateValidationError{
					field:  "LatestAttemptEndTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLatestAttemptEndTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomTaskExecutionStateValidationError{
				field:  "LatestAttemptEndTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CustomTaskExecutionStateMultiError(errors)
	}

	return nil
}

// CustomTaskExecutionStateMultiError is an error wrapping multiple validation
// errors returned by CustomTaskExecutionState.ValidateAll() if the designated
// constraints aren't met.
type CustomTaskExecutionStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CustomTaskExecutionStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CustomTaskExecutionStateMultiError) AllErrors() []error { return m }

// CustomTaskExecutionStateValidationError is the validation error returned by
// CustomTaskExecutionState.Validate if the designated constraints aren't met.
type CustomTaskExecutionStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CustomTaskExecutionStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CustomTaskExecutionStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CustomTaskExecutionStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CustomTaskExecutionStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CustomTaskExecutionStateValidationError) ErrorName() string {
	return "CustomTaskExecutionStateValidationError"
}

// Error satisfies the builtin error interface
func (e CustomTaskExecutionStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomTaskExecutionState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CustomTaskExecutionStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CustomTaskExecutionStateValidationError{}

// Validate checks the field values on CustomTaskState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CustomTaskState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CustomTaskState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CustomTaskStateMultiError, or nil if none found.
func (m *CustomTaskState) ValidateAll() error {
	return m.validate(true)
}

func (m *CustomTaskState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomTaskStateValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := CustomTaskStateValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDescription()) < 1 {
		err := CustomTaskStateValidationError{
			field:  "Description",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Application

	// no validation rules for ApplicationId

	// no validation rules for ReleaseChannel

	// no validation rules for ReleaseChannelId

	if m.GetProgram() == nil {
		err := CustomTaskStateValidationError{
			field:  "Program",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProgram()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "Program",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "Program",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProgram()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomTaskStateValidationError{
				field:  "Program",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTaskState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "TaskState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "TaskState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaskState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomTaskStateValidationError{
				field:  "TaskState",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRetryConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "RetryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "RetryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRetryConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomTaskStateValidationError{
				field:  "RetryConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CustomTaskStateMultiError(errors)
	}

	return nil
}

// CustomTaskStateMultiError is an error wrapping multiple validation errors
// returned by CustomTaskState.ValidateAll() if the designated constraints
// aren't met.
type CustomTaskStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CustomTaskStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CustomTaskStateMultiError) AllErrors() []error { return m }

// CustomTaskStateValidationError is the validation error returned by
// CustomTaskState.Validate if the designated constraints aren't met.
type CustomTaskStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CustomTaskStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CustomTaskStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CustomTaskStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CustomTaskStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CustomTaskStateValidationError) ErrorName() string { return "CustomTaskStateValidationError" }

// Error satisfies the builtin error interface
func (e CustomTaskStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomTaskState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CustomTaskStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CustomTaskStateValidationError{}

// Validate checks the field values on ProtectionLinkState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProtectionLinkState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProtectionLinkState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProtectionLinkStateMultiError, or nil if none found.
func (m *ProtectionLinkState) ValidateAll() error {
	return m.validate(true)
}

func (m *ProtectionLinkState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionLinkStateValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AttachmentName

	// no validation rules for LastSeenAttachmentStatus

	if all {
		switch v := interface{}(m.GetLastSeenAttachmentResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "LastSeenAttachmentResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "LastSeenAttachmentResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastSeenAttachmentResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionLinkStateValidationError{
				field:  "LastSeenAttachmentResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetLink()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "Link",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "Link",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLink()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionLinkStateValidationError{
				field:  "Link",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStartedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "StartedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "StartedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionLinkStateValidationError{
				field:  "StartedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStoppedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "StoppedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "StoppedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStoppedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionLinkStateValidationError{
				field:  "StoppedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for StoppedReason

	if all {
		switch v := interface{}(m.GetFirstSuccessTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "FirstSuccessTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "FirstSuccessTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirstSuccessTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionLinkStateValidationError{
				field:  "FirstSuccessTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProtectionLinkStateMultiError(errors)
	}

	return nil
}

// ProtectionLinkStateMultiError is an error wrapping multiple validation
// errors returned by ProtectionLinkState.ValidateAll() if the designated
// constraints aren't met.
type ProtectionLinkStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProtectionLinkStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProtectionLinkStateMultiError) AllErrors() []error { return m }

// ProtectionLinkStateValidationError is the validation error returned by
// ProtectionLinkState.Validate if the designated constraints aren't met.
type ProtectionLinkStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProtectionLinkStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProtectionLinkStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProtectionLinkStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProtectionLinkStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProtectionLinkStateValidationError) ErrorName() string {
	return "ProtectionLinkStateValidationError"
}

// Error satisfies the builtin error interface
func (e ProtectionLinkStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProtectionLinkState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProtectionLinkStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProtectionLinkStateValidationError{}

// Validate checks the field values on ProtectionAttachmentResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProtectionAttachmentResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProtectionAttachmentResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProtectionAttachmentResultMultiError, or nil if none found.
func (m *ProtectionAttachmentResult) ValidateAll() error {
	return m.validate(true)
}

func (m *ProtectionAttachmentResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Message

	// no validation rules for SystemDebugMessage

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetExecutionTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionAttachmentResultValidationError{
					field:  "ExecutionTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionAttachmentResultValidationError{
					field:  "ExecutionTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutionTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionAttachmentResultValidationError{
				field:  "ExecutionTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProtectionAttachmentResultMultiError(errors)
	}

	return nil
}

// ProtectionAttachmentResultMultiError is an error wrapping multiple
// validation errors returned by ProtectionAttachmentResult.ValidateAll() if
// the designated constraints aren't met.
type ProtectionAttachmentResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProtectionAttachmentResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProtectionAttachmentResultMultiError) AllErrors() []error { return m }

// ProtectionAttachmentResultValidationError is the validation error returned
// by ProtectionAttachmentResult.Validate if the designated constraints aren't met.
type ProtectionAttachmentResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProtectionAttachmentResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProtectionAttachmentResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProtectionAttachmentResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProtectionAttachmentResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProtectionAttachmentResultValidationError) ErrorName() string {
	return "ProtectionAttachmentResultValidationError"
}

// Error satisfies the builtin error interface
func (e ProtectionAttachmentResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProtectionAttachmentResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProtectionAttachmentResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProtectionAttachmentResultValidationError{}

// Validate checks the field values on ProtectionAttachment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProtectionAttachment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProtectionAttachment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProtectionAttachmentMultiError, or nil if none found.
func (m *ProtectionAttachment) ValidateAll() error {
	return m.validate(true)
}

func (m *ProtectionAttachment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionAttachmentValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionAttachmentValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionAttachmentValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProtectionAttachmentValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProtectionAttachmentValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProtectionAttachmentValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetLastCompletedVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProtectionAttachmentValidationError{
						field:  fmt.Sprintf("LastCompletedVersions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProtectionAttachmentValidationError{
						field:  fmt.Sprintf("LastCompletedVersions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProtectionAttachmentValidationError{
					field:  fmt.Sprintf("LastCompletedVersions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetLastCompletedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionAttachmentValidationError{
					field:  "LastCompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionAttachmentValidationError{
					field:  "LastCompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastCompletedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionAttachmentValidationError{
				field:  "LastCompletedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LastCompletedStatus

	for idx, item := range m.GetLastCompletedStatusExplanations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProtectionAttachmentValidationError{
						field:  fmt.Sprintf("LastCompletedStatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProtectionAttachmentValidationError{
						field:  fmt.Sprintf("LastCompletedStatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProtectionAttachmentValidationError{
					field:  fmt.Sprintf("LastCompletedStatusExplanations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for LastCompletedAppliedVersion

	// no validation rules for ProtectionId

	// no validation rules for AttachmentId

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionAttachmentValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionAttachmentValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionAttachmentValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProtectionAttachmentMultiError(errors)
	}

	return nil
}

// ProtectionAttachmentMultiError is an error wrapping multiple validation
// errors returned by ProtectionAttachment.ValidateAll() if the designated
// constraints aren't met.
type ProtectionAttachmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProtectionAttachmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProtectionAttachmentMultiError) AllErrors() []error { return m }

// ProtectionAttachmentValidationError is the validation error returned by
// ProtectionAttachment.Validate if the designated constraints aren't met.
type ProtectionAttachmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProtectionAttachmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProtectionAttachmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProtectionAttachmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProtectionAttachmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProtectionAttachmentValidationError) ErrorName() string {
	return "ProtectionAttachmentValidationError"
}

// Error satisfies the builtin error interface
func (e ProtectionAttachmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProtectionAttachment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProtectionAttachmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProtectionAttachmentValidationError{}

// Validate checks the field values on DeliveryExtensionState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeliveryExtensionState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryExtensionState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeliveryExtensionStateMultiError, or nil if none found.
func (m *DeliveryExtensionState) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryExtensionState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryExtensionStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryExtensionStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryExtensionStateValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryExtensionStateValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryExtensionStateValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryExtensionStateValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ExtensionId

	// no validation rules for ExtensionInstanceId

	// no validation rules for Lifecycle

	for idx, item := range m.GetLastRuns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryExtensionStateValidationError{
						field:  fmt.Sprintf("LastRuns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryExtensionStateValidationError{
						field:  fmt.Sprintf("LastRuns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryExtensionStateValidationError{
					field:  fmt.Sprintf("LastRuns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetLastCompletedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryExtensionStateValidationError{
					field:  "LastCompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryExtensionStateValidationError{
					field:  "LastCompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastCompletedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryExtensionStateValidationError{
				field:  "LastCompletedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LastCompletedStatus

	for idx, item := range m.GetLastCompletedStatusExplanations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryExtensionStateValidationError{
						field:  fmt.Sprintf("LastCompletedStatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryExtensionStateValidationError{
						field:  fmt.Sprintf("LastCompletedStatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryExtensionStateValidationError{
					field:  fmt.Sprintf("LastCompletedStatusExplanations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for LastCompletedAppliedVersion

	// no validation rules for Attempts

	for idx, item := range m.GetReferences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryExtensionStateValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryExtensionStateValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryExtensionStateValidationError{
					field:  fmt.Sprintf("References[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeliveryExtensionStateMultiError(errors)
	}

	return nil
}

// DeliveryExtensionStateMultiError is an error wrapping multiple validation
// errors returned by DeliveryExtensionState.ValidateAll() if the designated
// constraints aren't met.
type DeliveryExtensionStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryExtensionStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryExtensionStateMultiError) AllErrors() []error { return m }

// DeliveryExtensionStateValidationError is the validation error returned by
// DeliveryExtensionState.Validate if the designated constraints aren't met.
type DeliveryExtensionStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryExtensionStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryExtensionStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryExtensionStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryExtensionStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryExtensionStateValidationError) ErrorName() string {
	return "DeliveryExtensionStateValidationError"
}

// Error satisfies the builtin error interface
func (e DeliveryExtensionStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryExtensionState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryExtensionStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryExtensionStateValidationError{}

// Validate checks the field values on Signal with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Signal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Signal with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SignalMultiError, or nil if none found.
func (m *Signal) ValidateAll() error {
	return m.validate(true)
}

func (m *Signal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	switch v := m.Config.(type) {
	case *Signal_DeliveryPromotion:
		if v == nil {
			err := SignalValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeliveryPromotion()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalValidationError{
						field:  "DeliveryPromotion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalValidationError{
						field:  "DeliveryPromotion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeliveryPromotion()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalValidationError{
					field:  "DeliveryPromotion",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Signal_ProtectionBypass_:
		if v == nil {
			err := SignalValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProtectionBypass()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalValidationError{
						field:  "ProtectionBypass",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalValidationError{
						field:  "ProtectionBypass",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProtectionBypass()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalValidationError{
					field:  "ProtectionBypass",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Signal_RuntimeExtensionApproval_:
		if v == nil {
			err := SignalValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRuntimeExtensionApproval()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalValidationError{
						field:  "RuntimeExtensionApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalValidationError{
						field:  "RuntimeExtensionApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRuntimeExtensionApproval()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalValidationError{
					field:  "RuntimeExtensionApproval",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SignalMultiError(errors)
	}

	return nil
}

// SignalMultiError is an error wrapping multiple validation errors returned by
// Signal.ValidateAll() if the designated constraints aren't met.
type SignalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalMultiError) AllErrors() []error { return m }

// SignalValidationError is the validation error returned by Signal.Validate if
// the designated constraints aren't met.
type SignalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalValidationError) ErrorName() string { return "SignalValidationError" }

// Error satisfies the builtin error interface
func (e SignalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalValidationError{}

// Validate checks the field values on DebugLog with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DebugLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebugLog with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DebugLogMultiError, or nil
// if none found.
func (m *DebugLog) ValidateAll() error {
	return m.validate(true)
}

func (m *DebugLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebugLogValidationError{
					field:  "Ts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebugLogValidationError{
					field:  "Ts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebugLogValidationError{
				field:  "Ts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Log

	if len(errors) > 0 {
		return DebugLogMultiError(errors)
	}

	return nil
}

// DebugLogMultiError is an error wrapping multiple validation errors returned
// by DebugLog.ValidateAll() if the designated constraints aren't met.
type DebugLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebugLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebugLogMultiError) AllErrors() []error { return m }

// DebugLogValidationError is the validation error returned by
// DebugLog.Validate if the designated constraints aren't met.
type DebugLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebugLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebugLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebugLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebugLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebugLogValidationError) ErrorName() string { return "DebugLogValidationError" }

// Error satisfies the builtin error interface
func (e DebugLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebugLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebugLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebugLogValidationError{}

// Validate checks the field values on RuntimeExtensionMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeExtensionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeExtensionMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RuntimeExtensionMetadataMultiError, or nil if none found.
func (m *RuntimeExtensionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeExtensionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeExtensionMetadataValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeExtensionMetadataValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeExtensionMetadataValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ApplyDesiredStateId

	if len(errors) > 0 {
		return RuntimeExtensionMetadataMultiError(errors)
	}

	return nil
}

// RuntimeExtensionMetadataMultiError is an error wrapping multiple validation
// errors returned by RuntimeExtensionMetadata.ValidateAll() if the designated
// constraints aren't met.
type RuntimeExtensionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeExtensionMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeExtensionMetadataMultiError) AllErrors() []error { return m }

// RuntimeExtensionMetadataValidationError is the validation error returned by
// RuntimeExtensionMetadata.Validate if the designated constraints aren't met.
type RuntimeExtensionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeExtensionMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeExtensionMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeExtensionMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeExtensionMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeExtensionMetadataValidationError) ErrorName() string {
	return "RuntimeExtensionMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeExtensionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeExtensionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeExtensionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeExtensionMetadataValidationError{}

// Validate checks the field values on ManualApprovalConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ManualApprovalConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ManualApprovalConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ManualApprovalConfigMultiError, or nil if none found.
func (m *ManualApprovalConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ManualApprovalConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MinApprovers

	switch v := m.Config.(type) {
	case *ManualApprovalConfig_RuntimeExtension:
		if v == nil {
			err := ManualApprovalConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRuntimeExtension()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ManualApprovalConfigValidationError{
						field:  "RuntimeExtension",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ManualApprovalConfigValidationError{
						field:  "RuntimeExtension",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRuntimeExtension()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ManualApprovalConfigValidationError{
					field:  "RuntimeExtension",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ManualApprovalConfigMultiError(errors)
	}

	return nil
}

// ManualApprovalConfigMultiError is an error wrapping multiple validation
// errors returned by ManualApprovalConfig.ValidateAll() if the designated
// constraints aren't met.
type ManualApprovalConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ManualApprovalConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ManualApprovalConfigMultiError) AllErrors() []error { return m }

// ManualApprovalConfigValidationError is the validation error returned by
// ManualApprovalConfig.Validate if the designated constraints aren't met.
type ManualApprovalConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ManualApprovalConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ManualApprovalConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ManualApprovalConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ManualApprovalConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ManualApprovalConfigValidationError) ErrorName() string {
	return "ManualApprovalConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ManualApprovalConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sManualApprovalConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ManualApprovalConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ManualApprovalConfigValidationError{}

// Validate checks the field values on MissingApproval with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MissingApproval) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MissingApproval with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MissingApprovalMultiError, or nil if none found.
func (m *MissingApproval) ValidateAll() error {
	return m.validate(true)
}

func (m *MissingApproval) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DesiredStateId

	// no validation rules for SignalType

	// no validation rules for Topic

	if all {
		switch v := interface{}(m.GetRuntimeExtension()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MissingApprovalValidationError{
					field:  "RuntimeExtension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MissingApprovalValidationError{
					field:  "RuntimeExtension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntimeExtension()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MissingApprovalValidationError{
				field:  "RuntimeExtension",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Current

	if len(errors) > 0 {
		return MissingApprovalMultiError(errors)
	}

	return nil
}

// MissingApprovalMultiError is an error wrapping multiple validation errors
// returned by MissingApproval.ValidateAll() if the designated constraints
// aren't met.
type MissingApprovalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MissingApprovalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MissingApprovalMultiError) AllErrors() []error { return m }

// MissingApprovalValidationError is the validation error returned by
// MissingApproval.Validate if the designated constraints aren't met.
type MissingApprovalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MissingApprovalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MissingApprovalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MissingApprovalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MissingApprovalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MissingApprovalValidationError) ErrorName() string { return "MissingApprovalValidationError" }

// Error satisfies the builtin error interface
func (e MissingApprovalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMissingApproval.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MissingApprovalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MissingApprovalValidationError{}

// Validate checks the field values on ConcurrencyLimitExceeded with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConcurrencyLimitExceeded) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConcurrencyLimitExceeded with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConcurrencyLimitExceededMultiError, or nil if none found.
func (m *ConcurrencyLimitExceeded) ValidateAll() error {
	return m.validate(true)
}

func (m *ConcurrencyLimitExceeded) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEntityId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConcurrencyLimitExceededValidationError{
					field:  "EntityId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConcurrencyLimitExceededValidationError{
					field:  "EntityId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEntityId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConcurrencyLimitExceededValidationError{
				field:  "EntityId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetBlockers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConcurrencyLimitExceededValidationError{
						field:  fmt.Sprintf("Blockers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConcurrencyLimitExceededValidationError{
						field:  fmt.Sprintf("Blockers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConcurrencyLimitExceededValidationError{
					field:  fmt.Sprintf("Blockers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for LimitDescription

	if len(errors) > 0 {
		return ConcurrencyLimitExceededMultiError(errors)
	}

	return nil
}

// ConcurrencyLimitExceededMultiError is an error wrapping multiple validation
// errors returned by ConcurrencyLimitExceeded.ValidateAll() if the designated
// constraints aren't met.
type ConcurrencyLimitExceededMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConcurrencyLimitExceededMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConcurrencyLimitExceededMultiError) AllErrors() []error { return m }

// ConcurrencyLimitExceededValidationError is the validation error returned by
// ConcurrencyLimitExceeded.Validate if the designated constraints aren't met.
type ConcurrencyLimitExceededValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConcurrencyLimitExceededValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConcurrencyLimitExceededValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConcurrencyLimitExceededValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConcurrencyLimitExceededValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConcurrencyLimitExceededValidationError) ErrorName() string {
	return "ConcurrencyLimitExceededValidationError"
}

// Error satisfies the builtin error interface
func (e ConcurrencyLimitExceededValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConcurrencyLimitExceeded.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConcurrencyLimitExceededValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConcurrencyLimitExceededValidationError{}

// Validate checks the field values on ApplyConditionUnsatisfied with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplyConditionUnsatisfied) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyConditionUnsatisfied with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplyConditionUnsatisfiedMultiError, or nil if none found.
func (m *ApplyConditionUnsatisfied) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyConditionUnsatisfied) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Reason.(type) {
	case *ApplyConditionUnsatisfied_MissingApproval:
		if v == nil {
			err := ApplyConditionUnsatisfiedValidationError{
				field:  "Reason",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMissingApproval()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplyConditionUnsatisfiedValidationError{
						field:  "MissingApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplyConditionUnsatisfiedValidationError{
						field:  "MissingApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMissingApproval()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplyConditionUnsatisfiedValidationError{
					field:  "MissingApproval",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ApplyConditionUnsatisfied_ConcurrencyLimitExceeded:
		if v == nil {
			err := ApplyConditionUnsatisfiedValidationError{
				field:  "Reason",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConcurrencyLimitExceeded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplyConditionUnsatisfiedValidationError{
						field:  "ConcurrencyLimitExceeded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplyConditionUnsatisfiedValidationError{
						field:  "ConcurrencyLimitExceeded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConcurrencyLimitExceeded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplyConditionUnsatisfiedValidationError{
					field:  "ConcurrencyLimitExceeded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ApplyConditionUnsatisfiedMultiError(errors)
	}

	return nil
}

// ApplyConditionUnsatisfiedMultiError is an error wrapping multiple validation
// errors returned by ApplyConditionUnsatisfied.ValidateAll() if the
// designated constraints aren't met.
type ApplyConditionUnsatisfiedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyConditionUnsatisfiedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyConditionUnsatisfiedMultiError) AllErrors() []error { return m }

// ApplyConditionUnsatisfiedValidationError is the validation error returned by
// ApplyConditionUnsatisfied.Validate if the designated constraints aren't met.
type ApplyConditionUnsatisfiedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyConditionUnsatisfiedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyConditionUnsatisfiedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyConditionUnsatisfiedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyConditionUnsatisfiedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyConditionUnsatisfiedValidationError) ErrorName() string {
	return "ApplyConditionUnsatisfiedValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyConditionUnsatisfiedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyConditionUnsatisfied.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyConditionUnsatisfiedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyConditionUnsatisfiedValidationError{}

// Validate checks the field values on FetchTaskStartDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FetchTaskStartDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FetchTaskStartDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FetchTaskStartDetailsMultiError, or nil if none found.
func (m *FetchTaskStartDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *FetchTaskStartDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FetchMode

	if len(errors) > 0 {
		return FetchTaskStartDetailsMultiError(errors)
	}

	return nil
}

// FetchTaskStartDetailsMultiError is an error wrapping multiple validation
// errors returned by FetchTaskStartDetails.ValidateAll() if the designated
// constraints aren't met.
type FetchTaskStartDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FetchTaskStartDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FetchTaskStartDetailsMultiError) AllErrors() []error { return m }

// FetchTaskStartDetailsValidationError is the validation error returned by
// FetchTaskStartDetails.Validate if the designated constraints aren't met.
type FetchTaskStartDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FetchTaskStartDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FetchTaskStartDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FetchTaskStartDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FetchTaskStartDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FetchTaskStartDetailsValidationError) ErrorName() string {
	return "FetchTaskStartDetailsValidationError"
}

// Error satisfies the builtin error interface
func (e FetchTaskStartDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFetchTaskStartDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FetchTaskStartDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FetchTaskStartDetailsValidationError{}

// Validate checks the field values on ConcurrencyLease with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ConcurrencyLease) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConcurrencyLease with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConcurrencyLeaseMultiError, or nil if none found.
func (m *ConcurrencyLease) ValidateAll() error {
	return m.validate(true)
}

func (m *ConcurrencyLease) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LimitId

	// no validation rules for LeaseId

	if len(errors) > 0 {
		return ConcurrencyLeaseMultiError(errors)
	}

	return nil
}

// ConcurrencyLeaseMultiError is an error wrapping multiple validation errors
// returned by ConcurrencyLease.ValidateAll() if the designated constraints
// aren't met.
type ConcurrencyLeaseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConcurrencyLeaseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConcurrencyLeaseMultiError) AllErrors() []error { return m }

// ConcurrencyLeaseValidationError is the validation error returned by
// ConcurrencyLease.Validate if the designated constraints aren't met.
type ConcurrencyLeaseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConcurrencyLeaseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConcurrencyLeaseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConcurrencyLeaseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConcurrencyLeaseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConcurrencyLeaseValidationError) ErrorName() string { return "ConcurrencyLeaseValidationError" }

// Error satisfies the builtin error interface
func (e ConcurrencyLeaseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConcurrencyLease.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConcurrencyLeaseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConcurrencyLeaseValidationError{}

// Validate checks the field values on TaskRun with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaskRun) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskRun with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TaskRunMultiError, or nil if none found.
func (m *TaskRun) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskRun) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	for idx, item := range m.GetStatusExplanations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TaskRunValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TaskRunValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TaskRunValidationError{
					field:  fmt.Sprintf("StatusExplanations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Version

	for idx, item := range m.GetSeenVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TaskRunValidationError{
						field:  fmt.Sprintf("SeenVersions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TaskRunValidationError{
						field:  fmt.Sprintf("SeenVersions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TaskRunValidationError{
					field:  fmt.Sprintf("SeenVersions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DesiredStateId

	// no validation rules for ReleaseId

	if all {
		switch v := interface{}(m.GetCreatedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskRunValidationError{
					field:  "CreatedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskRunValidationError{
					field:  "CreatedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskRunValidationError{
				field:  "CreatedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStartedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskRunValidationError{
					field:  "StartedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskRunValidationError{
					field:  "StartedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskRunValidationError{
				field:  "StartedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCompletedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskRunValidationError{
					field:  "CompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskRunValidationError{
					field:  "CompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompletedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskRunValidationError{
				field:  "CompletedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for StartedByProcessId

	for idx, item := range m.GetRuntimeObjectMetadatas() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TaskRunValidationError{
						field:  fmt.Sprintf("RuntimeObjectMetadatas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TaskRunValidationError{
						field:  fmt.Sprintf("RuntimeObjectMetadatas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TaskRunValidationError{
					field:  fmt.Sprintf("RuntimeObjectMetadatas[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPvnWrapperOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskRunValidationError{
					field:  "PvnWrapperOutput",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskRunValidationError{
					field:  "PvnWrapperOutput",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPvnWrapperOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskRunValidationError{
				field:  "PvnWrapperOutput",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTaskEntities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TaskRunValidationError{
						field:  fmt.Sprintf("TaskEntities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TaskRunValidationError{
						field:  fmt.Sprintf("TaskEntities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TaskRunValidationError{
					field:  fmt.Sprintf("TaskEntities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Retryable

	// no validation rules for Phase

	if all {
		switch v := interface{}(m.GetFetchDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskRunValidationError{
					field:  "FetchDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskRunValidationError{
					field:  "FetchDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFetchDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskRunValidationError{
				field:  "FetchDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFetchTaskStartDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskRunValidationError{
					field:  "FetchTaskStartDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskRunValidationError{
					field:  "FetchTaskStartDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFetchTaskStartDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskRunValidationError{
				field:  "FetchTaskStartDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HasWorkReason

	for idx, item := range m.GetConcurrencyLeases() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TaskRunValidationError{
						field:  fmt.Sprintf("ConcurrencyLeases[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TaskRunValidationError{
						field:  fmt.Sprintf("ConcurrencyLeases[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TaskRunValidationError{
					field:  fmt.Sprintf("ConcurrencyLeases[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TaskRunMultiError(errors)
	}

	return nil
}

// TaskRunMultiError is an error wrapping multiple validation errors returned
// by TaskRun.ValidateAll() if the designated constraints aren't met.
type TaskRunMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskRunMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskRunMultiError) AllErrors() []error { return m }

// TaskRunValidationError is the validation error returned by TaskRun.Validate
// if the designated constraints aren't met.
type TaskRunValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskRunValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskRunValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskRunValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskRunValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskRunValidationError) ErrorName() string { return "TaskRunValidationError" }

// Error satisfies the builtin error interface
func (e TaskRunValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskRun.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskRunValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskRunValidationError{}

// Validate checks the field values on TaskEntityContext with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TaskEntityContext) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskEntityContext with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TaskEntityContextMultiError, or nil if none found.
func (m *TaskEntityContext) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskEntityContext) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLastCompletedRun()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskEntityContextValidationError{
					field:  "LastCompletedRun",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskEntityContextValidationError{
					field:  "LastCompletedRun",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastCompletedRun()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskEntityContextValidationError{
				field:  "LastCompletedRun",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastRun()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskEntityContextValidationError{
					field:  "LastRun",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskEntityContextValidationError{
					field:  "LastRun",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastRun()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskEntityContextValidationError{
				field:  "LastRun",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TaskEntityContextMultiError(errors)
	}

	return nil
}

// TaskEntityContextMultiError is an error wrapping multiple validation errors
// returned by TaskEntityContext.ValidateAll() if the designated constraints
// aren't met.
type TaskEntityContextMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskEntityContextMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskEntityContextMultiError) AllErrors() []error { return m }

// TaskEntityContextValidationError is the validation error returned by
// TaskEntityContext.Validate if the designated constraints aren't met.
type TaskEntityContextValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskEntityContextValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskEntityContextValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskEntityContextValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskEntityContextValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskEntityContextValidationError) ErrorName() string {
	return "TaskEntityContextValidationError"
}

// Error satisfies the builtin error interface
func (e TaskEntityContextValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskEntityContext.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskEntityContextValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskEntityContextValidationError{}

// Validate checks the field values on SetDesiredStateMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetDesiredStateMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetDesiredStateMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetDesiredStateMetadataMultiError, or nil if none found.
func (m *SetDesiredStateMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *SetDesiredStateMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rollback

	// no validation rules for BypassPreconditionsAndProtections

	if len(errors) > 0 {
		return SetDesiredStateMetadataMultiError(errors)
	}

	return nil
}

// SetDesiredStateMetadataMultiError is an error wrapping multiple validation
// errors returned by SetDesiredStateMetadata.ValidateAll() if the designated
// constraints aren't met.
type SetDesiredStateMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetDesiredStateMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetDesiredStateMetadataMultiError) AllErrors() []error { return m }

// SetDesiredStateMetadataValidationError is the validation error returned by
// SetDesiredStateMetadata.Validate if the designated constraints aren't met.
type SetDesiredStateMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetDesiredStateMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetDesiredStateMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetDesiredStateMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetDesiredStateMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetDesiredStateMetadataValidationError) ErrorName() string {
	return "SetDesiredStateMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e SetDesiredStateMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetDesiredStateMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetDesiredStateMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetDesiredStateMetadataValidationError{}

// Validate checks the field values on Condition_ReleaseChannelStableCondition
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Condition_ReleaseChannelStableCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Condition_ReleaseChannelStableCondition with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// Condition_ReleaseChannelStableConditionMultiError, or nil if none found.
func (m *Condition_ReleaseChannelStableCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition_ReleaseChannelStableCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Application

	// no validation rules for Service

	// no validation rules for ServiceId

	// no validation rules for ReleaseChannel

	// no validation rules for ReleaseChannelId

	// no validation rules for ServiceVersion

	// no validation rules for InternalOnlySatisfiedInReplacedDesiredState

	if len(errors) > 0 {
		return Condition_ReleaseChannelStableConditionMultiError(errors)
	}

	return nil
}

// Condition_ReleaseChannelStableConditionMultiError is an error wrapping
// multiple validation errors returned by
// Condition_ReleaseChannelStableCondition.ValidateAll() if the designated
// constraints aren't met.
type Condition_ReleaseChannelStableConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Condition_ReleaseChannelStableConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Condition_ReleaseChannelStableConditionMultiError) AllErrors() []error { return m }

// Condition_ReleaseChannelStableConditionValidationError is the validation
// error returned by Condition_ReleaseChannelStableCondition.Validate if the
// designated constraints aren't met.
type Condition_ReleaseChannelStableConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Condition_ReleaseChannelStableConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Condition_ReleaseChannelStableConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Condition_ReleaseChannelStableConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Condition_ReleaseChannelStableConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Condition_ReleaseChannelStableConditionValidationError) ErrorName() string {
	return "Condition_ReleaseChannelStableConditionValidationError"
}

// Error satisfies the builtin error interface
func (e Condition_ReleaseChannelStableConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition_ReleaseChannelStableCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Condition_ReleaseChannelStableConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Condition_ReleaseChannelStableConditionValidationError{}

// Validate checks the field values on Condition_ManualApproval with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Condition_ManualApproval) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Condition_ManualApproval with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Condition_ManualApprovalMultiError, or nil if none found.
func (m *Condition_ManualApproval) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition_ManualApproval) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Topic

	// no validation rules for Description

	// no validation rules for MinApprovers

	if len(errors) > 0 {
		return Condition_ManualApprovalMultiError(errors)
	}

	return nil
}

// Condition_ManualApprovalMultiError is an error wrapping multiple validation
// errors returned by Condition_ManualApproval.ValidateAll() if the designated
// constraints aren't met.
type Condition_ManualApprovalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Condition_ManualApprovalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Condition_ManualApprovalMultiError) AllErrors() []error { return m }

// Condition_ManualApprovalValidationError is the validation error returned by
// Condition_ManualApproval.Validate if the designated constraints aren't met.
type Condition_ManualApprovalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Condition_ManualApprovalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Condition_ManualApprovalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Condition_ManualApprovalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Condition_ManualApprovalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Condition_ManualApprovalValidationError) ErrorName() string {
	return "Condition_ManualApprovalValidationError"
}

// Error satisfies the builtin error interface
func (e Condition_ManualApprovalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition_ManualApproval.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Condition_ManualApprovalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Condition_ManualApprovalValidationError{}

// Validate checks the field values on Condition_CustomTaskSuccessfulCondition
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Condition_CustomTaskSuccessfulCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Condition_CustomTaskSuccessfulCondition with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// Condition_CustomTaskSuccessfulConditionMultiError, or nil if none found.
func (m *Condition_CustomTaskSuccessfulCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition_CustomTaskSuccessfulCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CustomTaskName

	switch v := m.Source.(type) {
	case *Condition_CustomTaskSuccessfulCondition_Protection_:
		if v == nil {
			err := Condition_CustomTaskSuccessfulConditionValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProtection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Condition_CustomTaskSuccessfulConditionValidationError{
						field:  "Protection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Condition_CustomTaskSuccessfulConditionValidationError{
						field:  "Protection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProtection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Condition_CustomTaskSuccessfulConditionValidationError{
					field:  "Protection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return Condition_CustomTaskSuccessfulConditionMultiError(errors)
	}

	return nil
}

// Condition_CustomTaskSuccessfulConditionMultiError is an error wrapping
// multiple validation errors returned by
// Condition_CustomTaskSuccessfulCondition.ValidateAll() if the designated
// constraints aren't met.
type Condition_CustomTaskSuccessfulConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Condition_CustomTaskSuccessfulConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Condition_CustomTaskSuccessfulConditionMultiError) AllErrors() []error { return m }

// Condition_CustomTaskSuccessfulConditionValidationError is the validation
// error returned by Condition_CustomTaskSuccessfulCondition.Validate if the
// designated constraints aren't met.
type Condition_CustomTaskSuccessfulConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Condition_CustomTaskSuccessfulConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Condition_CustomTaskSuccessfulConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Condition_CustomTaskSuccessfulConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Condition_CustomTaskSuccessfulConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Condition_CustomTaskSuccessfulConditionValidationError) ErrorName() string {
	return "Condition_CustomTaskSuccessfulConditionValidationError"
}

// Error satisfies the builtin error interface
func (e Condition_CustomTaskSuccessfulConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition_CustomTaskSuccessfulCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Condition_CustomTaskSuccessfulConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Condition_CustomTaskSuccessfulConditionValidationError{}

// Validate checks the field values on
// Condition_CustomTaskSuccessfulCondition_Protection with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Condition_CustomTaskSuccessfulCondition_Protection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Condition_CustomTaskSuccessfulCondition_Protection with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// Condition_CustomTaskSuccessfulCondition_ProtectionMultiError, or nil if
// none found.
func (m *Condition_CustomTaskSuccessfulCondition_Protection) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition_CustomTaskSuccessfulCondition_Protection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for TaskType

	if len(errors) > 0 {
		return Condition_CustomTaskSuccessfulCondition_ProtectionMultiError(errors)
	}

	return nil
}

// Condition_CustomTaskSuccessfulCondition_ProtectionMultiError is an error
// wrapping multiple validation errors returned by
// Condition_CustomTaskSuccessfulCondition_Protection.ValidateAll() if the
// designated constraints aren't met.
type Condition_CustomTaskSuccessfulCondition_ProtectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Condition_CustomTaskSuccessfulCondition_ProtectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Condition_CustomTaskSuccessfulCondition_ProtectionMultiError) AllErrors() []error { return m }

// Condition_CustomTaskSuccessfulCondition_ProtectionValidationError is the
// validation error returned by
// Condition_CustomTaskSuccessfulCondition_Protection.Validate if the
// designated constraints aren't met.
type Condition_CustomTaskSuccessfulCondition_ProtectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Condition_CustomTaskSuccessfulCondition_ProtectionValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Condition_CustomTaskSuccessfulCondition_ProtectionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Condition_CustomTaskSuccessfulCondition_ProtectionValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Condition_CustomTaskSuccessfulCondition_ProtectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Condition_CustomTaskSuccessfulCondition_ProtectionValidationError) ErrorName() string {
	return "Condition_CustomTaskSuccessfulCondition_ProtectionValidationError"
}

// Error satisfies the builtin error interface
func (e Condition_CustomTaskSuccessfulCondition_ProtectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition_CustomTaskSuccessfulCondition_Protection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Condition_CustomTaskSuccessfulCondition_ProtectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Condition_CustomTaskSuccessfulCondition_ProtectionValidationError{}

// Validate checks the field values on RuntimeObject_RuntimeExtension with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeObject_RuntimeExtension) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeObject_RuntimeExtension with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// RuntimeObject_RuntimeExtensionMultiError, or nil if none found.
func (m *RuntimeObject_RuntimeExtension) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeObject_RuntimeExtension) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetApply()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "Apply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "Apply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApply()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "Apply",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFetch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "Fetch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "Fetch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFetch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "Fetch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "GetInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "GetInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "GetInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFetchInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "FetchInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "FetchInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFetchInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "FetchInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFetchSteadyStateInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "FetchSteadyStateInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "FetchSteadyStateInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFetchSteadyStateInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "FetchSteadyStateInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGetInfoInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "GetInfoInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "GetInfoInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetInfoInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "GetInfoInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ServiceId

	// no validation rules for ReleaseChannelId

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeObject_RuntimeExtensionValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetParameterValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
						field:  fmt.Sprintf("ParameterValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
						field:  fmt.Sprintf("ParameterValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeObject_RuntimeExtensionValidationError{
					field:  fmt.Sprintf("ParameterValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetFetchOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "FetchOutput",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "FetchOutput",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFetchOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "FetchOutput",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGetInfoOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "GetInfoOutput",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "GetInfoOutput",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetInfoOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "GetInfoOutput",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetApplyOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "ApplyOutput",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "ApplyOutput",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApplyOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "ApplyOutput",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFetchRetryPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "FetchRetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "FetchRetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFetchRetryPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "FetchRetryPolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetApplyRetryPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "ApplyRetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "ApplyRetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApplyRetryPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "ApplyRetryPolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGetInfoRetryPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "GetInfoRetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "GetInfoRetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetInfoRetryPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "GetInfoRetryPolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FetchMode

	if len(errors) > 0 {
		return RuntimeObject_RuntimeExtensionMultiError(errors)
	}

	return nil
}

// RuntimeObject_RuntimeExtensionMultiError is an error wrapping multiple
// validation errors returned by RuntimeObject_RuntimeExtension.ValidateAll()
// if the designated constraints aren't met.
type RuntimeObject_RuntimeExtensionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeObject_RuntimeExtensionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeObject_RuntimeExtensionMultiError) AllErrors() []error { return m }

// RuntimeObject_RuntimeExtensionValidationError is the validation error
// returned by RuntimeObject_RuntimeExtension.Validate if the designated
// constraints aren't met.
type RuntimeObject_RuntimeExtensionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeObject_RuntimeExtensionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeObject_RuntimeExtensionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeObject_RuntimeExtensionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeObject_RuntimeExtensionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeObject_RuntimeExtensionValidationError) ErrorName() string {
	return "RuntimeObject_RuntimeExtensionValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeObject_RuntimeExtensionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeObject_RuntimeExtension.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeObject_RuntimeExtensionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeObject_RuntimeExtensionValidationError{}

// Validate checks the field values on ManualApprovalState_Approver with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ManualApprovalState_Approver) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ManualApprovalState_Approver with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ManualApprovalState_ApproverMultiError, or nil if none found.
func (m *ManualApprovalState_Approver) ValidateAll() error {
	return m.validate(true)
}

func (m *ManualApprovalState_Approver) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Source

	if all {
		switch v := interface{}(m.GetSourceMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ManualApprovalState_ApproverValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ManualApprovalState_ApproverValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ManualApprovalState_ApproverValidationError{
				field:  "SourceMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ManualApprovalState_ApproverValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ManualApprovalState_ApproverValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ManualApprovalState_ApproverValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ManualApprovalState_ApproverMultiError(errors)
	}

	return nil
}

// ManualApprovalState_ApproverMultiError is an error wrapping multiple
// validation errors returned by ManualApprovalState_Approver.ValidateAll() if
// the designated constraints aren't met.
type ManualApprovalState_ApproverMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ManualApprovalState_ApproverMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ManualApprovalState_ApproverMultiError) AllErrors() []error { return m }

// ManualApprovalState_ApproverValidationError is the validation error returned
// by ManualApprovalState_Approver.Validate if the designated constraints
// aren't met.
type ManualApprovalState_ApproverValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ManualApprovalState_ApproverValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ManualApprovalState_ApproverValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ManualApprovalState_ApproverValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ManualApprovalState_ApproverValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ManualApprovalState_ApproverValidationError) ErrorName() string {
	return "ManualApprovalState_ApproverValidationError"
}

// Error satisfies the builtin error interface
func (e ManualApprovalState_ApproverValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sManualApprovalState_Approver.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ManualApprovalState_ApproverValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ManualApprovalState_ApproverValidationError{}

// Validate checks the field values on Annotations_Annotation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Annotations_Annotation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Annotations_Annotation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Annotations_AnnotationMultiError, or nil if none found.
func (m *Annotations_Annotation) ValidateAll() error {
	return m.validate(true)
}

func (m *Annotations_Annotation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	if len(errors) > 0 {
		return Annotations_AnnotationMultiError(errors)
	}

	return nil
}

// Annotations_AnnotationMultiError is an error wrapping multiple validation
// errors returned by Annotations_Annotation.ValidateAll() if the designated
// constraints aren't met.
type Annotations_AnnotationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Annotations_AnnotationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Annotations_AnnotationMultiError) AllErrors() []error { return m }

// Annotations_AnnotationValidationError is the validation error returned by
// Annotations_Annotation.Validate if the designated constraints aren't met.
type Annotations_AnnotationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Annotations_AnnotationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Annotations_AnnotationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Annotations_AnnotationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Annotations_AnnotationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Annotations_AnnotationValidationError) ErrorName() string {
	return "Annotations_AnnotationValidationError"
}

// Error satisfies the builtin error interface
func (e Annotations_AnnotationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnnotations_Annotation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Annotations_AnnotationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Annotations_AnnotationValidationError{}

// Validate checks the field values on Signal_DeliveryPromotionConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Signal_DeliveryPromotionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Signal_DeliveryPromotionConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Signal_DeliveryPromotionConfigMultiError, or nil if none found.
func (m *Signal_DeliveryPromotionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *Signal_DeliveryPromotionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Stage

	// no validation rules for Full

	// no validation rules for Reject

	if len(errors) > 0 {
		return Signal_DeliveryPromotionConfigMultiError(errors)
	}

	return nil
}

// Signal_DeliveryPromotionConfigMultiError is an error wrapping multiple
// validation errors returned by Signal_DeliveryPromotionConfig.ValidateAll()
// if the designated constraints aren't met.
type Signal_DeliveryPromotionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Signal_DeliveryPromotionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Signal_DeliveryPromotionConfigMultiError) AllErrors() []error { return m }

// Signal_DeliveryPromotionConfigValidationError is the validation error
// returned by Signal_DeliveryPromotionConfig.Validate if the designated
// constraints aren't met.
type Signal_DeliveryPromotionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Signal_DeliveryPromotionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Signal_DeliveryPromotionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Signal_DeliveryPromotionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Signal_DeliveryPromotionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Signal_DeliveryPromotionConfigValidationError) ErrorName() string {
	return "Signal_DeliveryPromotionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e Signal_DeliveryPromotionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignal_DeliveryPromotionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Signal_DeliveryPromotionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Signal_DeliveryPromotionConfigValidationError{}

// Validate checks the field values on Signal_ProtectionBypass with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Signal_ProtectionBypass) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Signal_ProtectionBypass with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Signal_ProtectionBypassMultiError, or nil if none found.
func (m *Signal_ProtectionBypass) ValidateAll() error {
	return m.validate(true)
}

func (m *Signal_ProtectionBypass) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Signal_ProtectionBypassMultiError(errors)
	}

	return nil
}

// Signal_ProtectionBypassMultiError is an error wrapping multiple validation
// errors returned by Signal_ProtectionBypass.ValidateAll() if the designated
// constraints aren't met.
type Signal_ProtectionBypassMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Signal_ProtectionBypassMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Signal_ProtectionBypassMultiError) AllErrors() []error { return m }

// Signal_ProtectionBypassValidationError is the validation error returned by
// Signal_ProtectionBypass.Validate if the designated constraints aren't met.
type Signal_ProtectionBypassValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Signal_ProtectionBypassValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Signal_ProtectionBypassValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Signal_ProtectionBypassValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Signal_ProtectionBypassValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Signal_ProtectionBypassValidationError) ErrorName() string {
	return "Signal_ProtectionBypassValidationError"
}

// Error satisfies the builtin error interface
func (e Signal_ProtectionBypassValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignal_ProtectionBypass.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Signal_ProtectionBypassValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Signal_ProtectionBypassValidationError{}

// Validate checks the field values on Signal_RuntimeExtensionApproval with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Signal_RuntimeExtensionApproval) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Signal_RuntimeExtensionApproval with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Signal_RuntimeExtensionApprovalMultiError, or nil if none found.
func (m *Signal_RuntimeExtensionApproval) ValidateAll() error {
	return m.validate(true)
}

func (m *Signal_RuntimeExtensionApproval) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Signal_RuntimeExtensionApprovalValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Signal_RuntimeExtensionApprovalValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Signal_RuntimeExtensionApprovalValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reject

	// no validation rules for PlanBlobId

	if len(errors) > 0 {
		return Signal_RuntimeExtensionApprovalMultiError(errors)
	}

	return nil
}

// Signal_RuntimeExtensionApprovalMultiError is an error wrapping multiple
// validation errors returned by Signal_RuntimeExtensionApproval.ValidateAll()
// if the designated constraints aren't met.
type Signal_RuntimeExtensionApprovalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Signal_RuntimeExtensionApprovalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Signal_RuntimeExtensionApprovalMultiError) AllErrors() []error { return m }

// Signal_RuntimeExtensionApprovalValidationError is the validation error
// returned by Signal_RuntimeExtensionApproval.Validate if the designated
// constraints aren't met.
type Signal_RuntimeExtensionApprovalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Signal_RuntimeExtensionApprovalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Signal_RuntimeExtensionApprovalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Signal_RuntimeExtensionApprovalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Signal_RuntimeExtensionApprovalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Signal_RuntimeExtensionApprovalValidationError) ErrorName() string {
	return "Signal_RuntimeExtensionApprovalValidationError"
}

// Error satisfies the builtin error interface
func (e Signal_RuntimeExtensionApprovalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignal_RuntimeExtensionApproval.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Signal_RuntimeExtensionApprovalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Signal_RuntimeExtensionApprovalValidationError{}

// Validate checks the field values on ConcurrencyLimitExceeded_Blocker with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ConcurrencyLimitExceeded_Blocker) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConcurrencyLimitExceeded_Blocker with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ConcurrencyLimitExceeded_BlockerMultiError, or nil if none found.
func (m *ConcurrencyLimitExceeded_Blocker) ValidateAll() error {
	return m.validate(true)
}

func (m *ConcurrencyLimitExceeded_Blocker) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEntityId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConcurrencyLimitExceeded_BlockerValidationError{
					field:  "EntityId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConcurrencyLimitExceeded_BlockerValidationError{
					field:  "EntityId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEntityId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConcurrencyLimitExceeded_BlockerValidationError{
				field:  "EntityId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DesiredStateId

	// no validation rules for RootDesiredStateId

	// no validation rules for ReleaseId

	if all {
		switch v := interface{}(m.GetHeldSinceTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConcurrencyLimitExceeded_BlockerValidationError{
					field:  "HeldSinceTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConcurrencyLimitExceeded_BlockerValidationError{
					field:  "HeldSinceTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHeldSinceTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConcurrencyLimitExceeded_BlockerValidationError{
				field:  "HeldSinceTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConcurrencyLimitExceeded_BlockerMultiError(errors)
	}

	return nil
}

// ConcurrencyLimitExceeded_BlockerMultiError is an error wrapping multiple
// validation errors returned by
// ConcurrencyLimitExceeded_Blocker.ValidateAll() if the designated
// constraints aren't met.
type ConcurrencyLimitExceeded_BlockerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConcurrencyLimitExceeded_BlockerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConcurrencyLimitExceeded_BlockerMultiError) AllErrors() []error { return m }

// ConcurrencyLimitExceeded_BlockerValidationError is the validation error
// returned by ConcurrencyLimitExceeded_Blocker.Validate if the designated
// constraints aren't met.
type ConcurrencyLimitExceeded_BlockerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConcurrencyLimitExceeded_BlockerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConcurrencyLimitExceeded_BlockerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConcurrencyLimitExceeded_BlockerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConcurrencyLimitExceeded_BlockerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConcurrencyLimitExceeded_BlockerValidationError) ErrorName() string {
	return "ConcurrencyLimitExceeded_BlockerValidationError"
}

// Error satisfies the builtin error interface
func (e ConcurrencyLimitExceeded_BlockerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConcurrencyLimitExceeded_Blocker.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConcurrencyLimitExceeded_BlockerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConcurrencyLimitExceeded_BlockerValidationError{}

// Validate checks the field values on
// ApplyConditionUnsatisfied_InternalMissingApproval with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ApplyConditionUnsatisfied_InternalMissingApproval) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ApplyConditionUnsatisfied_InternalMissingApproval with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// ApplyConditionUnsatisfied_InternalMissingApprovalMultiError, or nil if none found.
func (m *ApplyConditionUnsatisfied_InternalMissingApproval) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyConditionUnsatisfied_InternalMissingApproval) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DesiredStateId

	// no validation rules for SignalType

	// no validation rules for Topic

	if all {
		switch v := interface{}(m.GetRuntimeExtension()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyConditionUnsatisfied_InternalMissingApprovalValidationError{
					field:  "RuntimeExtension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyConditionUnsatisfied_InternalMissingApprovalValidationError{
					field:  "RuntimeExtension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntimeExtension()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyConditionUnsatisfied_InternalMissingApprovalValidationError{
				field:  "RuntimeExtension",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ApplyConditionUnsatisfied_InternalMissingApprovalMultiError(errors)
	}

	return nil
}

// ApplyConditionUnsatisfied_InternalMissingApprovalMultiError is an error
// wrapping multiple validation errors returned by
// ApplyConditionUnsatisfied_InternalMissingApproval.ValidateAll() if the
// designated constraints aren't met.
type ApplyConditionUnsatisfied_InternalMissingApprovalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyConditionUnsatisfied_InternalMissingApprovalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyConditionUnsatisfied_InternalMissingApprovalMultiError) AllErrors() []error { return m }

// ApplyConditionUnsatisfied_InternalMissingApprovalValidationError is the
// validation error returned by
// ApplyConditionUnsatisfied_InternalMissingApproval.Validate if the
// designated constraints aren't met.
type ApplyConditionUnsatisfied_InternalMissingApprovalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyConditionUnsatisfied_InternalMissingApprovalValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e ApplyConditionUnsatisfied_InternalMissingApprovalValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ApplyConditionUnsatisfied_InternalMissingApprovalValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e ApplyConditionUnsatisfied_InternalMissingApprovalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyConditionUnsatisfied_InternalMissingApprovalValidationError) ErrorName() string {
	return "ApplyConditionUnsatisfied_InternalMissingApprovalValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyConditionUnsatisfied_InternalMissingApprovalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyConditionUnsatisfied_InternalMissingApproval.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyConditionUnsatisfied_InternalMissingApprovalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyConditionUnsatisfied_InternalMissingApprovalValidationError{}

// Validate checks the field values on TaskRun_RuntimeObjectMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TaskRun_RuntimeObjectMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskRun_RuntimeObjectMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// TaskRun_RuntimeObjectMetadataMultiError, or nil if none found.
func (m *TaskRun_RuntimeObjectMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskRun_RuntimeObjectMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskRun_RuntimeObjectMetadataValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskRun_RuntimeObjectMetadataValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskRun_RuntimeObjectMetadataValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	// no validation rules for ObjectType

	// no validation rules for Namespace

	if len(errors) > 0 {
		return TaskRun_RuntimeObjectMetadataMultiError(errors)
	}

	return nil
}

// TaskRun_RuntimeObjectMetadataMultiError is an error wrapping multiple
// validation errors returned by TaskRun_RuntimeObjectMetadata.ValidateAll()
// if the designated constraints aren't met.
type TaskRun_RuntimeObjectMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskRun_RuntimeObjectMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskRun_RuntimeObjectMetadataMultiError) AllErrors() []error { return m }

// TaskRun_RuntimeObjectMetadataValidationError is the validation error
// returned by TaskRun_RuntimeObjectMetadata.Validate if the designated
// constraints aren't met.
type TaskRun_RuntimeObjectMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskRun_RuntimeObjectMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskRun_RuntimeObjectMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskRun_RuntimeObjectMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskRun_RuntimeObjectMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskRun_RuntimeObjectMetadataValidationError) ErrorName() string {
	return "TaskRun_RuntimeObjectMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e TaskRun_RuntimeObjectMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskRun_RuntimeObjectMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskRun_RuntimeObjectMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskRun_RuntimeObjectMetadataValidationError{}
