// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: prodvana/desired_state/model/desired_state.proto

package model

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	common_config "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/common_config"

	environment "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/environment"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = common_config.TaskLifecycle(0)

	_ = environment.ExtensionType(0)
)

// Validate checks the field values on ProtectionLink with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProtectionLink) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProtectionLink with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProtectionLinkMultiError,
// or nil if none found.
func (m *ProtectionLink) ValidateAll() error {
	return m.validate(true)
}

func (m *ProtectionLink) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLifecycle()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionLinkValidationError{
					field:  "Lifecycle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionLinkValidationError{
					field:  "Lifecycle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLifecycle()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionLinkValidationError{
				field:  "Lifecycle",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AttachmentId

	if len(errors) > 0 {
		return ProtectionLinkMultiError(errors)
	}

	return nil
}

// ProtectionLinkMultiError is an error wrapping multiple validation errors
// returned by ProtectionLink.ValidateAll() if the designated constraints
// aren't met.
type ProtectionLinkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProtectionLinkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProtectionLinkMultiError) AllErrors() []error { return m }

// ProtectionLinkValidationError is the validation error returned by
// ProtectionLink.Validate if the designated constraints aren't met.
type ProtectionLinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProtectionLinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProtectionLinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProtectionLinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProtectionLinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProtectionLinkValidationError) ErrorName() string { return "ProtectionLinkValidationError" }

// Error satisfies the builtin error interface
func (e ProtectionLinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProtectionLink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProtectionLinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProtectionLinkValidationError{}

// Validate checks the field values on Condition with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Condition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Condition with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConditionMultiError, or nil
// if none found.
func (m *Condition) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DesiredStateId

	switch v := m.Condition.(type) {
	case *Condition_RcCond:
		if v == nil {
			err := ConditionValidationError{
				field:  "Condition",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRcCond()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "RcCond",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "RcCond",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRcCond()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "RcCond",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Condition_ManualApproval_:
		if v == nil {
			err := ConditionValidationError{
				field:  "Condition",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetManualApproval()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "ManualApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "ManualApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetManualApproval()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "ManualApproval",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Condition_CustomTask:
		if v == nil {
			err := ConditionValidationError{
				field:  "Condition",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCustomTask()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "CustomTask",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "CustomTask",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCustomTask()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "CustomTask",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ConditionMultiError(errors)
	}

	return nil
}

// ConditionMultiError is an error wrapping multiple validation errors returned
// by Condition.ValidateAll() if the designated constraints aren't met.
type ConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConditionMultiError) AllErrors() []error { return m }

// ConditionValidationError is the validation error returned by
// Condition.Validate if the designated constraints aren't met.
type ConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConditionValidationError) ErrorName() string { return "ConditionValidationError" }

// Error satisfies the builtin error interface
func (e ConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConditionValidationError{}

// Validate checks the field values on DeliveryExtension with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeliveryExtension) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryExtension with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeliveryExtensionMultiError, or nil if none found.
func (m *DeliveryExtension) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryExtension) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Lifecycle

	for idx, item := range m.GetReferences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryExtensionValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryExtensionValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryExtensionValidationError{
					field:  fmt.Sprintf("References[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeliveryExtensionMultiError(errors)
	}

	return nil
}

// DeliveryExtensionMultiError is an error wrapping multiple validation errors
// returned by DeliveryExtension.ValidateAll() if the designated constraints
// aren't met.
type DeliveryExtensionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryExtensionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryExtensionMultiError) AllErrors() []error { return m }

// DeliveryExtensionValidationError is the validation error returned by
// DeliveryExtension.Validate if the designated constraints aren't met.
type DeliveryExtensionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryExtensionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryExtensionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryExtensionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryExtensionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryExtensionValidationError) ErrorName() string {
	return "DeliveryExtensionValidationError"
}

// Error satisfies the builtin error interface
func (e DeliveryExtensionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryExtension.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryExtensionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryExtensionValidationError{}

// Validate checks the field values on Identifier with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Identifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Identifier with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IdentifierMultiError, or
// nil if none found.
func (m *Identifier) ValidateAll() error {
	return m.validate(true)
}

func (m *Identifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Name

	if len(errors) > 0 {
		return IdentifierMultiError(errors)
	}

	return nil
}

// IdentifierMultiError is an error wrapping multiple validation errors
// returned by Identifier.ValidateAll() if the designated constraints aren't met.
type IdentifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IdentifierMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IdentifierMultiError) AllErrors() []error { return m }

// IdentifierValidationError is the validation error returned by
// Identifier.Validate if the designated constraints aren't met.
type IdentifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IdentifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IdentifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IdentifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IdentifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IdentifierValidationError) ErrorName() string { return "IdentifierValidationError" }

// Error satisfies the builtin error interface
func (e IdentifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIdentifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IdentifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IdentifierValidationError{}

// Validate checks the field values on Metadata with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Metadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Metadata with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetadataMultiError, or nil
// if none found.
func (m *Metadata) ValidateAll() error {
	return m.validate(true)
}

func (m *Metadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPreconditions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("Preconditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("Preconditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  fmt.Sprintf("Preconditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInvariants() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("Invariants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("Invariants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  fmt.Sprintf("Invariants[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSelf()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetadataValidationError{
					field:  "Self",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetadataValidationError{
					field:  "Self",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSelf()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetadataValidationError{
				field:  "Self",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DesiredStateId

	// no validation rules for RootDesiredStateId

	for idx, item := range m.GetProtectionLinks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("ProtectionLinks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("ProtectionLinks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  fmt.Sprintf("ProtectionLinks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDeliveryExtensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TargetStateSetByParent

	// no validation rules for RequireApprovalBeforeApply

	if len(errors) > 0 {
		return MetadataMultiError(errors)
	}

	return nil
}

// MetadataMultiError is an error wrapping multiple validation errors returned
// by Metadata.ValidateAll() if the designated constraints aren't met.
type MetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataMultiError) AllErrors() []error { return m }

// MetadataValidationError is the validation error returned by
// Metadata.Validate if the designated constraints aren't met.
type MetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataValidationError) ErrorName() string { return "MetadataValidationError" }

// Error satisfies the builtin error interface
func (e MetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataValidationError{}

// Validate checks the field values on StatusExplanation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StatusExplanation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatusExplanation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StatusExplanationMultiError, or nil if none found.
func (m *StatusExplanation) ValidateAll() error {
	return m.validate(true)
}

func (m *StatusExplanation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StatusExplanationValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StatusExplanationValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StatusExplanationValidationError{
				field:  "Subject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reason

	// no validation rules for Message

	if len(errors) > 0 {
		return StatusExplanationMultiError(errors)
	}

	return nil
}

// StatusExplanationMultiError is an error wrapping multiple validation errors
// returned by StatusExplanation.ValidateAll() if the designated constraints
// aren't met.
type StatusExplanationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatusExplanationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatusExplanationMultiError) AllErrors() []error { return m }

// StatusExplanationValidationError is the validation error returned by
// StatusExplanation.Validate if the designated constraints aren't met.
type StatusExplanationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatusExplanationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatusExplanationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatusExplanationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatusExplanationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatusExplanationValidationError) ErrorName() string {
	return "StatusExplanationValidationError"
}

// Error satisfies the builtin error interface
func (e StatusExplanationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatusExplanation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatusExplanationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatusExplanationValidationError{}

// Validate checks the field values on ActionExplanation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ActionExplanation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionExplanation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActionExplanationMultiError, or nil if none found.
func (m *ActionExplanation) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionExplanation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionExplanationValidationError{
					field:  "Ts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionExplanationValidationError{
					field:  "Ts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionExplanationValidationError{
				field:  "Ts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ActionType

	// no validation rules for Message

	if len(errors) > 0 {
		return ActionExplanationMultiError(errors)
	}

	return nil
}

// ActionExplanationMultiError is an error wrapping multiple validation errors
// returned by ActionExplanation.ValidateAll() if the designated constraints
// aren't met.
type ActionExplanationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionExplanationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionExplanationMultiError) AllErrors() []error { return m }

// ActionExplanationValidationError is the validation error returned by
// ActionExplanation.Validate if the designated constraints aren't met.
type ActionExplanationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionExplanationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionExplanationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionExplanationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionExplanationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionExplanationValidationError) ErrorName() string {
	return "ActionExplanationValidationError"
}

// Error satisfies the builtin error interface
func (e ActionExplanationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionExplanation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionExplanationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionExplanationValidationError{}

// Validate checks the field values on Version with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Version) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Version with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in VersionMultiError, or nil if none found.
func (m *Version) ValidateAll() error {
	return m.validate(true)
}

func (m *Version) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	// no validation rules for Replicas

	// no validation rules for AvailableReplicas

	if all {
		switch v := interface{}(m.GetPushTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VersionValidationError{
					field:  "PushTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VersionValidationError{
					field:  "PushTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPushTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VersionValidationError{
				field:  "PushTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Active

	// no validation rules for TargetReplicas

	// no validation rules for Dirty

	if len(errors) > 0 {
		return VersionMultiError(errors)
	}

	return nil
}

// VersionMultiError is an error wrapping multiple validation errors returned
// by Version.ValidateAll() if the designated constraints aren't met.
type VersionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VersionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VersionMultiError) AllErrors() []error { return m }

// VersionValidationError is the validation error returned by Version.Validate
// if the designated constraints aren't met.
type VersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VersionValidationError) ErrorName() string { return "VersionValidationError" }

// Error satisfies the builtin error interface
func (e VersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VersionValidationError{}

// Validate checks the field values on ServiceInstanceState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceInstanceState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceInstanceState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceInstanceStateMultiError, or nil if none found.
func (m *ServiceInstanceState) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceInstanceState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceInstanceStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceInstanceStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceInstanceStateValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Application

	// no validation rules for Service

	// no validation rules for ReleaseChannel

	// no validation rules for ServiceId

	// no validation rules for ReleaseChannelId

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceInstanceStateValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceInstanceStateValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceInstanceStateValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRollbackVersion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceInstanceStateValidationError{
					field:  "RollbackVersion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceInstanceStateValidationError{
					field:  "RollbackVersion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRollbackVersion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceInstanceStateValidationError{
				field:  "RollbackVersion",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Rollback

	if all {
		switch v := interface{}(m.GetDelivery()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceInstanceStateValidationError{
					field:  "Delivery",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceInstanceStateValidationError{
					field:  "Delivery",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDelivery()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceInstanceStateValidationError{
				field:  "Delivery",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ServiceInstanceStateMultiError(errors)
	}

	return nil
}

// ServiceInstanceStateMultiError is an error wrapping multiple validation
// errors returned by ServiceInstanceState.ValidateAll() if the designated
// constraints aren't met.
type ServiceInstanceStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceInstanceStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceInstanceStateMultiError) AllErrors() []error { return m }

// ServiceInstanceStateValidationError is the validation error returned by
// ServiceInstanceState.Validate if the designated constraints aren't met.
type ServiceInstanceStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceInstanceStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceInstanceStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceInstanceStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceInstanceStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceInstanceStateValidationError) ErrorName() string {
	return "ServiceInstanceStateValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceInstanceStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceInstanceState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceInstanceStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceInstanceStateValidationError{}

// Validate checks the field values on ServiceState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServiceState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServiceStateMultiError, or
// nil if none found.
func (m *ServiceState) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceStateValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Application

	// no validation rules for Service

	// no validation rules for ServiceId

	for idx, item := range m.GetReleaseChannels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceStateValidationError{
						field:  fmt.Sprintf("ReleaseChannels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceStateValidationError{
						field:  fmt.Sprintf("ReleaseChannels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceStateValidationError{
					field:  fmt.Sprintf("ReleaseChannels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCustomTasks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceStateValidationError{
						field:  fmt.Sprintf("CustomTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceStateValidationError{
						field:  fmt.Sprintf("CustomTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceStateValidationError{
					field:  fmt.Sprintf("CustomTasks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDeliveryExtensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceStateValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceStateValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceStateValidationError{
					field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServiceStateMultiError(errors)
	}

	return nil
}

// ServiceStateMultiError is an error wrapping multiple validation errors
// returned by ServiceState.ValidateAll() if the designated constraints aren't met.
type ServiceStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceStateMultiError) AllErrors() []error { return m }

// ServiceStateValidationError is the validation error returned by
// ServiceState.Validate if the designated constraints aren't met.
type ServiceStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceStateValidationError) ErrorName() string { return "ServiceStateValidationError" }

// Error satisfies the builtin error interface
func (e ServiceStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceStateValidationError{}

// Validate checks the field values on ServiceGroupState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ServiceGroupState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceGroupState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceGroupStateMultiError, or nil if none found.
func (m *ServiceGroupState) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceGroupState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceGroupStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceGroupStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceGroupStateValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetServices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceGroupStateValidationError{
						field:  fmt.Sprintf("Services[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceGroupStateValidationError{
						field:  fmt.Sprintf("Services[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceGroupStateValidationError{
					field:  fmt.Sprintf("Services[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCustomTasks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceGroupStateValidationError{
						field:  fmt.Sprintf("CustomTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceGroupStateValidationError{
						field:  fmt.Sprintf("CustomTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceGroupStateValidationError{
					field:  fmt.Sprintf("CustomTasks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDeliveryExtensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceGroupStateValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceGroupStateValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceGroupStateValidationError{
					field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServiceGroupStateMultiError(errors)
	}

	return nil
}

// ServiceGroupStateMultiError is an error wrapping multiple validation errors
// returned by ServiceGroupState.ValidateAll() if the designated constraints
// aren't met.
type ServiceGroupStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceGroupStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceGroupStateMultiError) AllErrors() []error { return m }

// ServiceGroupStateValidationError is the validation error returned by
// ServiceGroupState.Validate if the designated constraints aren't met.
type ServiceGroupStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceGroupStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceGroupStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceGroupStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceGroupStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceGroupStateValidationError) ErrorName() string {
	return "ServiceGroupStateValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceGroupStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceGroupState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceGroupStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceGroupStateValidationError{}

// Validate checks the field values on CanaryProgressState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CanaryProgressState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CanaryProgressState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CanaryProgressStateMultiError, or nil if none found.
func (m *CanaryProgressState) ValidateAll() error {
	return m.validate(true)
}

func (m *CanaryProgressState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if val := m.GetCanaryWeight(); val < 0 || val > 100 {
		err := CanaryProgressStateValidationError{
			field:  "CanaryWeight",
			reason: "value must be inside range [0, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDuration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CanaryProgressStateValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CanaryProgressStateValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDuration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CanaryProgressStateValidationError{
				field:  "Duration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPauseStartTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CanaryProgressStateValidationError{
					field:  "PauseStartTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CanaryProgressStateValidationError{
					field:  "PauseStartTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPauseStartTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CanaryProgressStateValidationError{
				field:  "PauseStartTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CanaryProgressStateMultiError(errors)
	}

	return nil
}

// CanaryProgressStateMultiError is an error wrapping multiple validation
// errors returned by CanaryProgressState.ValidateAll() if the designated
// constraints aren't met.
type CanaryProgressStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CanaryProgressStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CanaryProgressStateMultiError) AllErrors() []error { return m }

// CanaryProgressStateValidationError is the validation error returned by
// CanaryProgressState.Validate if the designated constraints aren't met.
type CanaryProgressStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CanaryProgressStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CanaryProgressStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CanaryProgressStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CanaryProgressStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CanaryProgressStateValidationError) ErrorName() string {
	return "CanaryProgressStateValidationError"
}

// Error satisfies the builtin error interface
func (e CanaryProgressStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCanaryProgressState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CanaryProgressStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CanaryProgressStateValidationError{}

// Validate checks the field values on DeliveryState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeliveryState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeliveryStateMultiError, or
// nil if none found.
func (m *DeliveryState) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DesiredStateId

	// no validation rules for Status

	// no validation rules for Message

	for idx, item := range m.GetCanaryProgress() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryStateValidationError{
						field:  fmt.Sprintf("CanaryProgress[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryStateValidationError{
						field:  fmt.Sprintf("CanaryProgress[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryStateValidationError{
					field:  fmt.Sprintf("CanaryProgress[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for FirstRun

	// no validation rules for Generation

	if len(errors) > 0 {
		return DeliveryStateMultiError(errors)
	}

	return nil
}

// DeliveryStateMultiError is an error wrapping multiple validation errors
// returned by DeliveryState.ValidateAll() if the designated constraints
// aren't met.
type DeliveryStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryStateMultiError) AllErrors() []error { return m }

// DeliveryStateValidationError is the validation error returned by
// DeliveryState.Validate if the designated constraints aren't met.
type DeliveryStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryStateValidationError) ErrorName() string { return "DeliveryStateValidationError" }

// Error satisfies the builtin error interface
func (e DeliveryStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryStateValidationError{}

// Validate checks the field values on RuntimeExtensionFetchOutput with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeExtensionFetchOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeExtensionFetchOutput with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RuntimeExtensionFetchOutputMultiError, or nil if none found.
func (m *RuntimeExtensionFetchOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeExtensionFetchOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Dirty

	// no validation rules for Message

	if len(errors) > 0 {
		return RuntimeExtensionFetchOutputMultiError(errors)
	}

	return nil
}

// RuntimeExtensionFetchOutputMultiError is an error wrapping multiple
// validation errors returned by RuntimeExtensionFetchOutput.ValidateAll() if
// the designated constraints aren't met.
type RuntimeExtensionFetchOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeExtensionFetchOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeExtensionFetchOutputMultiError) AllErrors() []error { return m }

// RuntimeExtensionFetchOutputValidationError is the validation error returned
// by RuntimeExtensionFetchOutput.Validate if the designated constraints
// aren't met.
type RuntimeExtensionFetchOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeExtensionFetchOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeExtensionFetchOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeExtensionFetchOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeExtensionFetchOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeExtensionFetchOutputValidationError) ErrorName() string {
	return "RuntimeExtensionFetchOutputValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeExtensionFetchOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeExtensionFetchOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeExtensionFetchOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeExtensionFetchOutputValidationError{}

// Validate checks the field values on RuntimeObject with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RuntimeObject) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeObject with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RuntimeObjectMultiError, or
// nil if none found.
func (m *RuntimeObject) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeObject) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObjectValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ObjectType

	// no validation rules for Namespace

	// no validation rules for Name

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeObjectValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeObjectValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeObjectValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetRollbackVersion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "RollbackVersion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "RollbackVersion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRollbackVersion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObjectValidationError{
				field:  "RollbackVersion",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDelivery()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "Delivery",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "Delivery",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDelivery()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObjectValidationError{
				field:  "Delivery",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VersionAgnostic

	// no validation rules for DesiredVersionDirtyOnly

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetRuntimeExtension()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "RuntimeExtension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "RuntimeExtension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntimeExtension()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObjectValidationError{
				field:  "RuntimeExtension",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObjectValidationError{
				field:  "Interval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObjectValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObjectValidationError{
				field:  "Timeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequireApprovalBeforeApply

	// no validation rules for RawConfig

	if len(errors) > 0 {
		return RuntimeObjectMultiError(errors)
	}

	return nil
}

// RuntimeObjectMultiError is an error wrapping multiple validation errors
// returned by RuntimeObject.ValidateAll() if the designated constraints
// aren't met.
type RuntimeObjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeObjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeObjectMultiError) AllErrors() []error { return m }

// RuntimeObjectValidationError is the validation error returned by
// RuntimeObject.Validate if the designated constraints aren't met.
type RuntimeObjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeObjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeObjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeObjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeObjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeObjectValidationError) ErrorName() string { return "RuntimeObjectValidationError" }

// Error satisfies the builtin error interface
func (e RuntimeObjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeObject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeObjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeObjectValidationError{}

// Validate checks the field values on ConditionState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConditionState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConditionState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConditionStateMultiError,
// or nil if none found.
func (m *ConditionState) ValidateAll() error {
	return m.validate(true)
}

func (m *ConditionState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if len(errors) > 0 {
		return ConditionStateMultiError(errors)
	}

	return nil
}

// ConditionStateMultiError is an error wrapping multiple validation errors
// returned by ConditionState.ValidateAll() if the designated constraints
// aren't met.
type ConditionStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConditionStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConditionStateMultiError) AllErrors() []error { return m }

// ConditionStateValidationError is the validation error returned by
// ConditionState.Validate if the designated constraints aren't met.
type ConditionStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConditionStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConditionStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConditionStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConditionStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConditionStateValidationError) ErrorName() string { return "ConditionStateValidationError" }

// Error satisfies the builtin error interface
func (e ConditionStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConditionState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConditionStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConditionStateValidationError{}

// Validate checks the field values on ControlState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ControlState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ControlState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ControlStateMultiError, or
// nil if none found.
func (m *ControlState) ValidateAll() error {
	return m.validate(true)
}

func (m *ControlState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rollback

	for idx, item := range m.GetPreconditionStates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ControlStateValidationError{
						field:  fmt.Sprintf("PreconditionStates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ControlStateValidationError{
						field:  fmt.Sprintf("PreconditionStates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ControlStateValidationError{
					field:  fmt.Sprintf("PreconditionStates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInvariantStates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ControlStateValidationError{
						field:  fmt.Sprintf("InvariantStates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ControlStateValidationError{
						field:  fmt.Sprintf("InvariantStates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ControlStateValidationError{
					field:  fmt.Sprintf("InvariantStates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Paused

	for idx, item := range m.GetStatusExplanations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ControlStateValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ControlStateValidationError{
						field:  fmt.Sprintf("StatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ControlStateValidationError{
					field:  fmt.Sprintf("StatusExplanations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetActionExplanation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "ActionExplanation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "ActionExplanation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActionExplanation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ControlStateValidationError{
				field:  "ActionExplanation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastFetchedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "LastFetchedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "LastFetchedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastFetchedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ControlStateValidationError{
				field:  "LastFetchedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastAppliedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "LastAppliedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "LastAppliedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastAppliedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ControlStateValidationError{
				field:  "LastAppliedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMissingApproval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "MissingApproval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ControlStateValidationError{
					field:  "MissingApproval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMissingApproval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ControlStateValidationError{
				field:  "MissingApproval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ControlStateMultiError(errors)
	}

	return nil
}

// ControlStateMultiError is an error wrapping multiple validation errors
// returned by ControlState.ValidateAll() if the designated constraints aren't met.
type ControlStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ControlStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ControlStateMultiError) AllErrors() []error { return m }

// ControlStateValidationError is the validation error returned by
// ControlState.Validate if the designated constraints aren't met.
type ControlStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ControlStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ControlStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ControlStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ControlStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ControlStateValidationError) ErrorName() string { return "ControlStateValidationError" }

// Error satisfies the builtin error interface
func (e ControlStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sControlState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ControlStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ControlStateValidationError{}

// Validate checks the field values on ManualApprovalState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ManualApprovalState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ManualApprovalState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ManualApprovalStateMultiError, or nil if none found.
func (m *ManualApprovalState) ValidateAll() error {
	return m.validate(true)
}

func (m *ManualApprovalState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ManualApprovalStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ManualApprovalStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ManualApprovalStateValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	// no validation rules for Topic

	// no validation rules for Description

	if len(errors) > 0 {
		return ManualApprovalStateMultiError(errors)
	}

	return nil
}

// ManualApprovalStateMultiError is an error wrapping multiple validation
// errors returned by ManualApprovalState.ValidateAll() if the designated
// constraints aren't met.
type ManualApprovalStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ManualApprovalStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ManualApprovalStateMultiError) AllErrors() []error { return m }

// ManualApprovalStateValidationError is the validation error returned by
// ManualApprovalState.Validate if the designated constraints aren't met.
type ManualApprovalStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ManualApprovalStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ManualApprovalStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ManualApprovalStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ManualApprovalStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ManualApprovalStateValidationError) ErrorName() string {
	return "ManualApprovalStateValidationError"
}

// Error satisfies the builtin error interface
func (e ManualApprovalStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sManualApprovalState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ManualApprovalStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ManualApprovalStateValidationError{}

// Validate checks the field values on State with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *State) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on State with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StateMultiError, or nil if none found.
func (m *State) ValidateAll() error {
	return m.validate(true)
}

func (m *State) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.StateOneof.(type) {
	case *State_Service:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetService()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "Service",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "Service",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetService()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_ServiceInstance:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetServiceInstance()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ServiceInstance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ServiceInstance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServiceInstance()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "ServiceInstance",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_ServiceGroup:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetServiceGroup()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ServiceGroup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ServiceGroup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServiceGroup()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "ServiceGroup",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_RuntimeObject:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRuntimeObject()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "RuntimeObject",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "RuntimeObject",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRuntimeObject()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "RuntimeObject",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_ManualApproval:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetManualApproval()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ManualApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ManualApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetManualApproval()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "ManualApproval",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_CustomTask:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCustomTask()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "CustomTask",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "CustomTask",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCustomTask()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "CustomTask",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_ProtectionAttachment:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProtectionAttachment()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ProtectionAttachment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ProtectionAttachment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProtectionAttachment()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "ProtectionAttachment",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_ProtectionLink:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProtectionLink()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ProtectionLink",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "ProtectionLink",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProtectionLink()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "ProtectionLink",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *State_DeliveryExtension:
		if v == nil {
			err := StateValidationError{
				field:  "StateOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeliveryExtension()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "DeliveryExtension",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  "DeliveryExtension",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeliveryExtension()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  "DeliveryExtension",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return StateMultiError(errors)
	}

	return nil
}

// StateMultiError is an error wrapping multiple validation errors returned by
// State.ValidateAll() if the designated constraints aren't met.
type StateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StateMultiError) AllErrors() []error { return m }

// StateValidationError is the validation error returned by State.Validate if
// the designated constraints aren't met.
type StateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StateValidationError) ErrorName() string { return "StateValidationError" }

// Error satisfies the builtin error interface
func (e StateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StateValidationError{}

// Validate checks the field values on Annotations with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Annotations) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Annotations with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AnnotationsMultiError, or
// nil if none found.
func (m *Annotations) ValidateAll() error {
	return m.validate(true)
}

func (m *Annotations) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AnnotationsValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AnnotationsValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AnnotationsValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AnnotationsMultiError(errors)
	}

	return nil
}

// AnnotationsMultiError is an error wrapping multiple validation errors
// returned by Annotations.ValidateAll() if the designated constraints aren't met.
type AnnotationsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnnotationsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnnotationsMultiError) AllErrors() []error { return m }

// AnnotationsValidationError is the validation error returned by
// Annotations.Validate if the designated constraints aren't met.
type AnnotationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnnotationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnnotationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnnotationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnnotationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnnotationsValidationError) ErrorName() string { return "AnnotationsValidationError" }

// Error satisfies the builtin error interface
func (e AnnotationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnnotations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnnotationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnnotationsValidationError{}

// Validate checks the field values on CustomTaskExecutionState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CustomTaskExecutionState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CustomTaskExecutionState with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CustomTaskExecutionStateMultiError, or nil if none found.
func (m *CustomTaskExecutionState) ValidateAll() error {
	return m.validate(true)
}

func (m *CustomTaskExecutionState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Attempts

	if all {
		switch v := interface{}(m.GetLatestAttemptEndTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomTaskExecutionStateValidationError{
					field:  "LatestAttemptEndTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomTaskExecutionStateValidationError{
					field:  "LatestAttemptEndTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLatestAttemptEndTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomTaskExecutionStateValidationError{
				field:  "LatestAttemptEndTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CustomTaskExecutionStateMultiError(errors)
	}

	return nil
}

// CustomTaskExecutionStateMultiError is an error wrapping multiple validation
// errors returned by CustomTaskExecutionState.ValidateAll() if the designated
// constraints aren't met.
type CustomTaskExecutionStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CustomTaskExecutionStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CustomTaskExecutionStateMultiError) AllErrors() []error { return m }

// CustomTaskExecutionStateValidationError is the validation error returned by
// CustomTaskExecutionState.Validate if the designated constraints aren't met.
type CustomTaskExecutionStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CustomTaskExecutionStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CustomTaskExecutionStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CustomTaskExecutionStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CustomTaskExecutionStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CustomTaskExecutionStateValidationError) ErrorName() string {
	return "CustomTaskExecutionStateValidationError"
}

// Error satisfies the builtin error interface
func (e CustomTaskExecutionStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomTaskExecutionState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CustomTaskExecutionStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CustomTaskExecutionStateValidationError{}

// Validate checks the field values on CustomTaskState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CustomTaskState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CustomTaskState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CustomTaskStateMultiError, or nil if none found.
func (m *CustomTaskState) ValidateAll() error {
	return m.validate(true)
}

func (m *CustomTaskState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomTaskStateValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := CustomTaskStateValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDescription()) < 1 {
		err := CustomTaskStateValidationError{
			field:  "Description",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Application

	// no validation rules for ApplicationId

	// no validation rules for ReleaseChannel

	// no validation rules for ReleaseChannelId

	if m.GetProgram() == nil {
		err := CustomTaskStateValidationError{
			field:  "Program",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProgram()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "Program",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "Program",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProgram()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomTaskStateValidationError{
				field:  "Program",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTaskState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "TaskState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "TaskState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaskState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomTaskStateValidationError{
				field:  "TaskState",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRetryConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "RetryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomTaskStateValidationError{
					field:  "RetryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRetryConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomTaskStateValidationError{
				field:  "RetryConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CustomTaskStateMultiError(errors)
	}

	return nil
}

// CustomTaskStateMultiError is an error wrapping multiple validation errors
// returned by CustomTaskState.ValidateAll() if the designated constraints
// aren't met.
type CustomTaskStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CustomTaskStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CustomTaskStateMultiError) AllErrors() []error { return m }

// CustomTaskStateValidationError is the validation error returned by
// CustomTaskState.Validate if the designated constraints aren't met.
type CustomTaskStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CustomTaskStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CustomTaskStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CustomTaskStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CustomTaskStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CustomTaskStateValidationError) ErrorName() string { return "CustomTaskStateValidationError" }

// Error satisfies the builtin error interface
func (e CustomTaskStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomTaskState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CustomTaskStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CustomTaskStateValidationError{}

// Validate checks the field values on ProtectionLinkState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProtectionLinkState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProtectionLinkState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProtectionLinkStateMultiError, or nil if none found.
func (m *ProtectionLinkState) ValidateAll() error {
	return m.validate(true)
}

func (m *ProtectionLinkState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionLinkStateValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetLink()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "Link",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "Link",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLink()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionLinkStateValidationError{
				field:  "Link",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStartedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "StartedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "StartedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionLinkStateValidationError{
				field:  "StartedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStoppedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "StoppedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "StoppedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStoppedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionLinkStateValidationError{
				field:  "StoppedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for StoppedReason

	if all {
		switch v := interface{}(m.GetFirstSuccessTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "FirstSuccessTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionLinkStateValidationError{
					field:  "FirstSuccessTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirstSuccessTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionLinkStateValidationError{
				field:  "FirstSuccessTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProtectionLinkStateMultiError(errors)
	}

	return nil
}

// ProtectionLinkStateMultiError is an error wrapping multiple validation
// errors returned by ProtectionLinkState.ValidateAll() if the designated
// constraints aren't met.
type ProtectionLinkStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProtectionLinkStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProtectionLinkStateMultiError) AllErrors() []error { return m }

// ProtectionLinkStateValidationError is the validation error returned by
// ProtectionLinkState.Validate if the designated constraints aren't met.
type ProtectionLinkStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProtectionLinkStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProtectionLinkStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProtectionLinkStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProtectionLinkStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProtectionLinkStateValidationError) ErrorName() string {
	return "ProtectionLinkStateValidationError"
}

// Error satisfies the builtin error interface
func (e ProtectionLinkStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProtectionLinkState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProtectionLinkStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProtectionLinkStateValidationError{}

// Validate checks the field values on ProtectionAttachment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProtectionAttachment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProtectionAttachment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProtectionAttachmentMultiError, or nil if none found.
func (m *ProtectionAttachment) ValidateAll() error {
	return m.validate(true)
}

func (m *ProtectionAttachment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionAttachmentValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionAttachmentValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionAttachmentValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProtectionAttachmentValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProtectionAttachmentValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProtectionAttachmentValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetLastCompletedVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProtectionAttachmentValidationError{
						field:  fmt.Sprintf("LastCompletedVersions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProtectionAttachmentValidationError{
						field:  fmt.Sprintf("LastCompletedVersions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProtectionAttachmentValidationError{
					field:  fmt.Sprintf("LastCompletedVersions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetLastCompletedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionAttachmentValidationError{
					field:  "LastCompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionAttachmentValidationError{
					field:  "LastCompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastCompletedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionAttachmentValidationError{
				field:  "LastCompletedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LastCompletedStatus

	for idx, item := range m.GetLastCompletedStatusExplanations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProtectionAttachmentValidationError{
						field:  fmt.Sprintf("LastCompletedStatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProtectionAttachmentValidationError{
						field:  fmt.Sprintf("LastCompletedStatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProtectionAttachmentValidationError{
					field:  fmt.Sprintf("LastCompletedStatusExplanations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for LastCompletedAppliedVersion

	// no validation rules for ProtectionId

	// no validation rules for AttachmentId

	if len(errors) > 0 {
		return ProtectionAttachmentMultiError(errors)
	}

	return nil
}

// ProtectionAttachmentMultiError is an error wrapping multiple validation
// errors returned by ProtectionAttachment.ValidateAll() if the designated
// constraints aren't met.
type ProtectionAttachmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProtectionAttachmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProtectionAttachmentMultiError) AllErrors() []error { return m }

// ProtectionAttachmentValidationError is the validation error returned by
// ProtectionAttachment.Validate if the designated constraints aren't met.
type ProtectionAttachmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProtectionAttachmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProtectionAttachmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProtectionAttachmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProtectionAttachmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProtectionAttachmentValidationError) ErrorName() string {
	return "ProtectionAttachmentValidationError"
}

// Error satisfies the builtin error interface
func (e ProtectionAttachmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProtectionAttachment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProtectionAttachmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProtectionAttachmentValidationError{}

// Validate checks the field values on DeliveryExtensionState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeliveryExtensionState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryExtensionState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeliveryExtensionStateMultiError, or nil if none found.
func (m *DeliveryExtensionState) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryExtensionState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryExtensionStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryExtensionStateValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryExtensionStateValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryExtensionStateValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryExtensionStateValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryExtensionStateValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ExtensionId

	// no validation rules for ExtensionInstanceId

	// no validation rules for Lifecycle

	if all {
		switch v := interface{}(m.GetLastCompletedTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryExtensionStateValidationError{
					field:  "LastCompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryExtensionStateValidationError{
					field:  "LastCompletedTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastCompletedTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryExtensionStateValidationError{
				field:  "LastCompletedTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LastCompletedStatus

	for idx, item := range m.GetLastCompletedStatusExplanations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryExtensionStateValidationError{
						field:  fmt.Sprintf("LastCompletedStatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryExtensionStateValidationError{
						field:  fmt.Sprintf("LastCompletedStatusExplanations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryExtensionStateValidationError{
					field:  fmt.Sprintf("LastCompletedStatusExplanations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for LastCompletedAppliedVersion

	for idx, item := range m.GetReferences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryExtensionStateValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryExtensionStateValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryExtensionStateValidationError{
					field:  fmt.Sprintf("References[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Status

	if len(errors) > 0 {
		return DeliveryExtensionStateMultiError(errors)
	}

	return nil
}

// DeliveryExtensionStateMultiError is an error wrapping multiple validation
// errors returned by DeliveryExtensionState.ValidateAll() if the designated
// constraints aren't met.
type DeliveryExtensionStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryExtensionStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryExtensionStateMultiError) AllErrors() []error { return m }

// DeliveryExtensionStateValidationError is the validation error returned by
// DeliveryExtensionState.Validate if the designated constraints aren't met.
type DeliveryExtensionStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryExtensionStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryExtensionStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryExtensionStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryExtensionStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryExtensionStateValidationError) ErrorName() string {
	return "DeliveryExtensionStateValidationError"
}

// Error satisfies the builtin error interface
func (e DeliveryExtensionStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryExtensionState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryExtensionStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryExtensionStateValidationError{}

// Validate checks the field values on Signal with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Signal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Signal with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SignalMultiError, or nil if none found.
func (m *Signal) ValidateAll() error {
	return m.validate(true)
}

func (m *Signal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	switch v := m.Config.(type) {
	case *Signal_DeliveryPromotion:
		if v == nil {
			err := SignalValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeliveryPromotion()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalValidationError{
						field:  "DeliveryPromotion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalValidationError{
						field:  "DeliveryPromotion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeliveryPromotion()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalValidationError{
					field:  "DeliveryPromotion",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Signal_ProtectionBypass_:
		if v == nil {
			err := SignalValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProtectionBypass()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalValidationError{
						field:  "ProtectionBypass",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalValidationError{
						field:  "ProtectionBypass",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProtectionBypass()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalValidationError{
					field:  "ProtectionBypass",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Signal_RuntimeExtensionApproval_:
		if v == nil {
			err := SignalValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRuntimeExtensionApproval()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalValidationError{
						field:  "RuntimeExtensionApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalValidationError{
						field:  "RuntimeExtensionApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRuntimeExtensionApproval()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalValidationError{
					field:  "RuntimeExtensionApproval",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SignalMultiError(errors)
	}

	return nil
}

// SignalMultiError is an error wrapping multiple validation errors returned by
// Signal.ValidateAll() if the designated constraints aren't met.
type SignalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalMultiError) AllErrors() []error { return m }

// SignalValidationError is the validation error returned by Signal.Validate if
// the designated constraints aren't met.
type SignalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalValidationError) ErrorName() string { return "SignalValidationError" }

// Error satisfies the builtin error interface
func (e SignalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalValidationError{}

// Validate checks the field values on DebugLog with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DebugLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebugLog with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DebugLogMultiError, or nil
// if none found.
func (m *DebugLog) ValidateAll() error {
	return m.validate(true)
}

func (m *DebugLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebugLogValidationError{
					field:  "Ts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebugLogValidationError{
					field:  "Ts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebugLogValidationError{
				field:  "Ts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Log

	if len(errors) > 0 {
		return DebugLogMultiError(errors)
	}

	return nil
}

// DebugLogMultiError is an error wrapping multiple validation errors returned
// by DebugLog.ValidateAll() if the designated constraints aren't met.
type DebugLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebugLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebugLogMultiError) AllErrors() []error { return m }

// DebugLogValidationError is the validation error returned by
// DebugLog.Validate if the designated constraints aren't met.
type DebugLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebugLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebugLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebugLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebugLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebugLogValidationError) ErrorName() string { return "DebugLogValidationError" }

// Error satisfies the builtin error interface
func (e DebugLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebugLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebugLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebugLogValidationError{}

// Validate checks the field values on MissingApproval with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MissingApproval) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MissingApproval with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MissingApprovalMultiError, or nil if none found.
func (m *MissingApproval) ValidateAll() error {
	return m.validate(true)
}

func (m *MissingApproval) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DesiredStateId

	// no validation rules for SignalType

	// no validation rules for Topic

	if len(errors) > 0 {
		return MissingApprovalMultiError(errors)
	}

	return nil
}

// MissingApprovalMultiError is an error wrapping multiple validation errors
// returned by MissingApproval.ValidateAll() if the designated constraints
// aren't met.
type MissingApprovalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MissingApprovalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MissingApprovalMultiError) AllErrors() []error { return m }

// MissingApprovalValidationError is the validation error returned by
// MissingApproval.Validate if the designated constraints aren't met.
type MissingApprovalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MissingApprovalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MissingApprovalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MissingApprovalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MissingApprovalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MissingApprovalValidationError) ErrorName() string { return "MissingApprovalValidationError" }

// Error satisfies the builtin error interface
func (e MissingApprovalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMissingApproval.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MissingApprovalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MissingApprovalValidationError{}

// Validate checks the field values on ApplyRejected with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ApplyRejected) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyRejected with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ApplyRejectedMultiError, or
// nil if none found.
func (m *ApplyRejected) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyRejected) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Reason.(type) {
	case *ApplyRejected_MissingApproval:
		if v == nil {
			err := ApplyRejectedValidationError{
				field:  "Reason",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMissingApproval()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplyRejectedValidationError{
						field:  "MissingApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplyRejectedValidationError{
						field:  "MissingApproval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMissingApproval()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplyRejectedValidationError{
					field:  "MissingApproval",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ApplyRejectedMultiError(errors)
	}

	return nil
}

// ApplyRejectedMultiError is an error wrapping multiple validation errors
// returned by ApplyRejected.ValidateAll() if the designated constraints
// aren't met.
type ApplyRejectedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyRejectedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyRejectedMultiError) AllErrors() []error { return m }

// ApplyRejectedValidationError is the validation error returned by
// ApplyRejected.Validate if the designated constraints aren't met.
type ApplyRejectedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyRejectedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyRejectedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyRejectedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyRejectedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyRejectedValidationError) ErrorName() string { return "ApplyRejectedValidationError" }

// Error satisfies the builtin error interface
func (e ApplyRejectedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyRejected.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyRejectedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyRejectedValidationError{}

// Validate checks the field values on Condition_ReleaseChannelStableCondition
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Condition_ReleaseChannelStableCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Condition_ReleaseChannelStableCondition with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// Condition_ReleaseChannelStableConditionMultiError, or nil if none found.
func (m *Condition_ReleaseChannelStableCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition_ReleaseChannelStableCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Application

	// no validation rules for Service

	// no validation rules for ServiceId

	// no validation rules for ReleaseChannel

	// no validation rules for ReleaseChannelId

	// no validation rules for ServiceVersion

	if len(errors) > 0 {
		return Condition_ReleaseChannelStableConditionMultiError(errors)
	}

	return nil
}

// Condition_ReleaseChannelStableConditionMultiError is an error wrapping
// multiple validation errors returned by
// Condition_ReleaseChannelStableCondition.ValidateAll() if the designated
// constraints aren't met.
type Condition_ReleaseChannelStableConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Condition_ReleaseChannelStableConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Condition_ReleaseChannelStableConditionMultiError) AllErrors() []error { return m }

// Condition_ReleaseChannelStableConditionValidationError is the validation
// error returned by Condition_ReleaseChannelStableCondition.Validate if the
// designated constraints aren't met.
type Condition_ReleaseChannelStableConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Condition_ReleaseChannelStableConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Condition_ReleaseChannelStableConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Condition_ReleaseChannelStableConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Condition_ReleaseChannelStableConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Condition_ReleaseChannelStableConditionValidationError) ErrorName() string {
	return "Condition_ReleaseChannelStableConditionValidationError"
}

// Error satisfies the builtin error interface
func (e Condition_ReleaseChannelStableConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition_ReleaseChannelStableCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Condition_ReleaseChannelStableConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Condition_ReleaseChannelStableConditionValidationError{}

// Validate checks the field values on Condition_ManualApproval with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Condition_ManualApproval) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Condition_ManualApproval with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Condition_ManualApprovalMultiError, or nil if none found.
func (m *Condition_ManualApproval) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition_ManualApproval) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Topic

	// no validation rules for Description

	if len(errors) > 0 {
		return Condition_ManualApprovalMultiError(errors)
	}

	return nil
}

// Condition_ManualApprovalMultiError is an error wrapping multiple validation
// errors returned by Condition_ManualApproval.ValidateAll() if the designated
// constraints aren't met.
type Condition_ManualApprovalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Condition_ManualApprovalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Condition_ManualApprovalMultiError) AllErrors() []error { return m }

// Condition_ManualApprovalValidationError is the validation error returned by
// Condition_ManualApproval.Validate if the designated constraints aren't met.
type Condition_ManualApprovalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Condition_ManualApprovalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Condition_ManualApprovalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Condition_ManualApprovalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Condition_ManualApprovalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Condition_ManualApprovalValidationError) ErrorName() string {
	return "Condition_ManualApprovalValidationError"
}

// Error satisfies the builtin error interface
func (e Condition_ManualApprovalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition_ManualApproval.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Condition_ManualApprovalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Condition_ManualApprovalValidationError{}

// Validate checks the field values on Condition_CustomTaskSuccessfulCondition
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Condition_CustomTaskSuccessfulCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Condition_CustomTaskSuccessfulCondition with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// Condition_CustomTaskSuccessfulConditionMultiError, or nil if none found.
func (m *Condition_CustomTaskSuccessfulCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition_CustomTaskSuccessfulCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CustomTaskName

	switch v := m.Source.(type) {
	case *Condition_CustomTaskSuccessfulCondition_Protection_:
		if v == nil {
			err := Condition_CustomTaskSuccessfulConditionValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProtection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Condition_CustomTaskSuccessfulConditionValidationError{
						field:  "Protection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Condition_CustomTaskSuccessfulConditionValidationError{
						field:  "Protection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProtection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Condition_CustomTaskSuccessfulConditionValidationError{
					field:  "Protection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return Condition_CustomTaskSuccessfulConditionMultiError(errors)
	}

	return nil
}

// Condition_CustomTaskSuccessfulConditionMultiError is an error wrapping
// multiple validation errors returned by
// Condition_CustomTaskSuccessfulCondition.ValidateAll() if the designated
// constraints aren't met.
type Condition_CustomTaskSuccessfulConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Condition_CustomTaskSuccessfulConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Condition_CustomTaskSuccessfulConditionMultiError) AllErrors() []error { return m }

// Condition_CustomTaskSuccessfulConditionValidationError is the validation
// error returned by Condition_CustomTaskSuccessfulCondition.Validate if the
// designated constraints aren't met.
type Condition_CustomTaskSuccessfulConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Condition_CustomTaskSuccessfulConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Condition_CustomTaskSuccessfulConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Condition_CustomTaskSuccessfulConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Condition_CustomTaskSuccessfulConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Condition_CustomTaskSuccessfulConditionValidationError) ErrorName() string {
	return "Condition_CustomTaskSuccessfulConditionValidationError"
}

// Error satisfies the builtin error interface
func (e Condition_CustomTaskSuccessfulConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition_CustomTaskSuccessfulCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Condition_CustomTaskSuccessfulConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Condition_CustomTaskSuccessfulConditionValidationError{}

// Validate checks the field values on
// Condition_CustomTaskSuccessfulCondition_Protection with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Condition_CustomTaskSuccessfulCondition_Protection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Condition_CustomTaskSuccessfulCondition_Protection with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// Condition_CustomTaskSuccessfulCondition_ProtectionMultiError, or nil if
// none found.
func (m *Condition_CustomTaskSuccessfulCondition_Protection) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition_CustomTaskSuccessfulCondition_Protection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for TaskType

	if len(errors) > 0 {
		return Condition_CustomTaskSuccessfulCondition_ProtectionMultiError(errors)
	}

	return nil
}

// Condition_CustomTaskSuccessfulCondition_ProtectionMultiError is an error
// wrapping multiple validation errors returned by
// Condition_CustomTaskSuccessfulCondition_Protection.ValidateAll() if the
// designated constraints aren't met.
type Condition_CustomTaskSuccessfulCondition_ProtectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Condition_CustomTaskSuccessfulCondition_ProtectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Condition_CustomTaskSuccessfulCondition_ProtectionMultiError) AllErrors() []error { return m }

// Condition_CustomTaskSuccessfulCondition_ProtectionValidationError is the
// validation error returned by
// Condition_CustomTaskSuccessfulCondition_Protection.Validate if the
// designated constraints aren't met.
type Condition_CustomTaskSuccessfulCondition_ProtectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Condition_CustomTaskSuccessfulCondition_ProtectionValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Condition_CustomTaskSuccessfulCondition_ProtectionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Condition_CustomTaskSuccessfulCondition_ProtectionValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Condition_CustomTaskSuccessfulCondition_ProtectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Condition_CustomTaskSuccessfulCondition_ProtectionValidationError) ErrorName() string {
	return "Condition_CustomTaskSuccessfulCondition_ProtectionValidationError"
}

// Error satisfies the builtin error interface
func (e Condition_CustomTaskSuccessfulCondition_ProtectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition_CustomTaskSuccessfulCondition_Protection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Condition_CustomTaskSuccessfulCondition_ProtectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Condition_CustomTaskSuccessfulCondition_ProtectionValidationError{}

// Validate checks the field values on RuntimeObject_RuntimeExtension with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeObject_RuntimeExtension) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeObject_RuntimeExtension with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// RuntimeObject_RuntimeExtensionMultiError, or nil if none found.
func (m *RuntimeObject_RuntimeExtension) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeObject_RuntimeExtension) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetApply()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "Apply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "Apply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApply()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "Apply",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFetch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "Fetch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "Fetch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFetch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "Fetch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFetchInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "FetchInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "FetchInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFetchInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "FetchInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFetchTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "FetchTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
					field:  "FetchTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFetchTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeObject_RuntimeExtensionValidationError{
				field:  "FetchTimeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ServiceId

	// no validation rules for ReleaseChannelId

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeObject_RuntimeExtensionValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetParameterValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
						field:  fmt.Sprintf("ParameterValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeObject_RuntimeExtensionValidationError{
						field:  fmt.Sprintf("ParameterValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeObject_RuntimeExtensionValidationError{
					field:  fmt.Sprintf("ParameterValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Type

	if len(errors) > 0 {
		return RuntimeObject_RuntimeExtensionMultiError(errors)
	}

	return nil
}

// RuntimeObject_RuntimeExtensionMultiError is an error wrapping multiple
// validation errors returned by RuntimeObject_RuntimeExtension.ValidateAll()
// if the designated constraints aren't met.
type RuntimeObject_RuntimeExtensionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeObject_RuntimeExtensionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeObject_RuntimeExtensionMultiError) AllErrors() []error { return m }

// RuntimeObject_RuntimeExtensionValidationError is the validation error
// returned by RuntimeObject_RuntimeExtension.Validate if the designated
// constraints aren't met.
type RuntimeObject_RuntimeExtensionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeObject_RuntimeExtensionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeObject_RuntimeExtensionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeObject_RuntimeExtensionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeObject_RuntimeExtensionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeObject_RuntimeExtensionValidationError) ErrorName() string {
	return "RuntimeObject_RuntimeExtensionValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeObject_RuntimeExtensionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeObject_RuntimeExtension.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeObject_RuntimeExtensionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeObject_RuntimeExtensionValidationError{}

// Validate checks the field values on Annotations_Annotation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Annotations_Annotation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Annotations_Annotation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Annotations_AnnotationMultiError, or nil if none found.
func (m *Annotations_Annotation) ValidateAll() error {
	return m.validate(true)
}

func (m *Annotations_Annotation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	if len(errors) > 0 {
		return Annotations_AnnotationMultiError(errors)
	}

	return nil
}

// Annotations_AnnotationMultiError is an error wrapping multiple validation
// errors returned by Annotations_Annotation.ValidateAll() if the designated
// constraints aren't met.
type Annotations_AnnotationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Annotations_AnnotationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Annotations_AnnotationMultiError) AllErrors() []error { return m }

// Annotations_AnnotationValidationError is the validation error returned by
// Annotations_Annotation.Validate if the designated constraints aren't met.
type Annotations_AnnotationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Annotations_AnnotationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Annotations_AnnotationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Annotations_AnnotationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Annotations_AnnotationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Annotations_AnnotationValidationError) ErrorName() string {
	return "Annotations_AnnotationValidationError"
}

// Error satisfies the builtin error interface
func (e Annotations_AnnotationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnnotations_Annotation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Annotations_AnnotationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Annotations_AnnotationValidationError{}

// Validate checks the field values on Signal_DeliveryPromotionConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Signal_DeliveryPromotionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Signal_DeliveryPromotionConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Signal_DeliveryPromotionConfigMultiError, or nil if none found.
func (m *Signal_DeliveryPromotionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *Signal_DeliveryPromotionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Stage

	// no validation rules for Full

	if len(errors) > 0 {
		return Signal_DeliveryPromotionConfigMultiError(errors)
	}

	return nil
}

// Signal_DeliveryPromotionConfigMultiError is an error wrapping multiple
// validation errors returned by Signal_DeliveryPromotionConfig.ValidateAll()
// if the designated constraints aren't met.
type Signal_DeliveryPromotionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Signal_DeliveryPromotionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Signal_DeliveryPromotionConfigMultiError) AllErrors() []error { return m }

// Signal_DeliveryPromotionConfigValidationError is the validation error
// returned by Signal_DeliveryPromotionConfig.Validate if the designated
// constraints aren't met.
type Signal_DeliveryPromotionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Signal_DeliveryPromotionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Signal_DeliveryPromotionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Signal_DeliveryPromotionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Signal_DeliveryPromotionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Signal_DeliveryPromotionConfigValidationError) ErrorName() string {
	return "Signal_DeliveryPromotionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e Signal_DeliveryPromotionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignal_DeliveryPromotionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Signal_DeliveryPromotionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Signal_DeliveryPromotionConfigValidationError{}

// Validate checks the field values on Signal_ProtectionBypass with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Signal_ProtectionBypass) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Signal_ProtectionBypass with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Signal_ProtectionBypassMultiError, or nil if none found.
func (m *Signal_ProtectionBypass) ValidateAll() error {
	return m.validate(true)
}

func (m *Signal_ProtectionBypass) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Signal_ProtectionBypassMultiError(errors)
	}

	return nil
}

// Signal_ProtectionBypassMultiError is an error wrapping multiple validation
// errors returned by Signal_ProtectionBypass.ValidateAll() if the designated
// constraints aren't met.
type Signal_ProtectionBypassMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Signal_ProtectionBypassMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Signal_ProtectionBypassMultiError) AllErrors() []error { return m }

// Signal_ProtectionBypassValidationError is the validation error returned by
// Signal_ProtectionBypass.Validate if the designated constraints aren't met.
type Signal_ProtectionBypassValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Signal_ProtectionBypassValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Signal_ProtectionBypassValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Signal_ProtectionBypassValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Signal_ProtectionBypassValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Signal_ProtectionBypassValidationError) ErrorName() string {
	return "Signal_ProtectionBypassValidationError"
}

// Error satisfies the builtin error interface
func (e Signal_ProtectionBypassValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignal_ProtectionBypass.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Signal_ProtectionBypassValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Signal_ProtectionBypassValidationError{}

// Validate checks the field values on Signal_RuntimeExtensionApproval with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Signal_RuntimeExtensionApproval) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Signal_RuntimeExtensionApproval with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Signal_RuntimeExtensionApprovalMultiError, or nil if none found.
func (m *Signal_RuntimeExtensionApproval) ValidateAll() error {
	return m.validate(true)
}

func (m *Signal_RuntimeExtensionApproval) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Signal_RuntimeExtensionApprovalValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Signal_RuntimeExtensionApprovalValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Signal_RuntimeExtensionApprovalValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reject

	if len(errors) > 0 {
		return Signal_RuntimeExtensionApprovalMultiError(errors)
	}

	return nil
}

// Signal_RuntimeExtensionApprovalMultiError is an error wrapping multiple
// validation errors returned by Signal_RuntimeExtensionApproval.ValidateAll()
// if the designated constraints aren't met.
type Signal_RuntimeExtensionApprovalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Signal_RuntimeExtensionApprovalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Signal_RuntimeExtensionApprovalMultiError) AllErrors() []error { return m }

// Signal_RuntimeExtensionApprovalValidationError is the validation error
// returned by Signal_RuntimeExtensionApproval.Validate if the designated
// constraints aren't met.
type Signal_RuntimeExtensionApprovalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Signal_RuntimeExtensionApprovalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Signal_RuntimeExtensionApprovalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Signal_RuntimeExtensionApprovalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Signal_RuntimeExtensionApprovalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Signal_RuntimeExtensionApprovalValidationError) ErrorName() string {
	return "Signal_RuntimeExtensionApprovalValidationError"
}

// Error satisfies the builtin error interface
func (e Signal_RuntimeExtensionApprovalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignal_RuntimeExtensionApproval.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Signal_RuntimeExtensionApprovalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Signal_RuntimeExtensionApprovalValidationError{}
