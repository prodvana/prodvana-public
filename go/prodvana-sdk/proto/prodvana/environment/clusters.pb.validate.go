// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: prodvana/environment/clusters.proto

package environment

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ClusterAuth with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterAuth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterAuth with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterAuthMultiError, or
// nil if none found.
func (m *ClusterAuth) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterAuth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Endpoint

	// no validation rules for CaCert

	// no validation rules for Token

	// no validation rules for ServiceAccount

	// no validation rules for K8SAgentAuth

	switch v := m.AuthOneof.(type) {
	case *ClusterAuth_Ecs:
		if v == nil {
			err := ClusterAuthValidationError{
				field:  "AuthOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEcs()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterAuthValidationError{
						field:  "Ecs",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterAuthValidationError{
						field:  "Ecs",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEcs()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterAuthValidationError{
					field:  "Ecs",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ClusterAuth_GenericDocker:
		if v == nil {
			err := ClusterAuthValidationError{
				field:  "AuthOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGenericDocker()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterAuthValidationError{
						field:  "GenericDocker",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterAuthValidationError{
						field:  "GenericDocker",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGenericDocker()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterAuthValidationError{
					field:  "GenericDocker",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ClusterAuthMultiError(errors)
	}

	return nil
}

// ClusterAuthMultiError is an error wrapping multiple validation errors
// returned by ClusterAuth.ValidateAll() if the designated constraints aren't met.
type ClusterAuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterAuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterAuthMultiError) AllErrors() []error { return m }

// ClusterAuthValidationError is the validation error returned by
// ClusterAuth.Validate if the designated constraints aren't met.
type ClusterAuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterAuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterAuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterAuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterAuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterAuthValidationError) ErrorName() string { return "ClusterAuthValidationError" }

// Error satisfies the builtin error interface
func (e ClusterAuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterAuth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterAuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterAuthValidationError{}

// Validate checks the field values on Cluster with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Cluster) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Cluster with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ClusterMultiError, or nil if none found.
func (m *Cluster) ValidateAll() error {
	return m.validate(true)
}

func (m *Cluster) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for ClusterId

	// no validation rules for Origin

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastHeartbeatTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "LastHeartbeatTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "LastHeartbeatTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastHeartbeatTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "LastHeartbeatTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClusterMultiError(errors)
	}

	return nil
}

// ClusterMultiError is an error wrapping multiple validation errors returned
// by Cluster.ValidateAll() if the designated constraints aren't met.
type ClusterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterMultiError) AllErrors() []error { return m }

// ClusterValidationError is the validation error returned by Cluster.Validate
// if the designated constraints aren't met.
type ClusterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterValidationError) ErrorName() string { return "ClusterValidationError" }

// Error satisfies the builtin error interface
func (e ClusterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCluster.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterValidationError{}

// Validate checks the field values on FakeClusterConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FakeClusterConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FakeClusterConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FakeClusterConfigMultiError, or nil if none found.
func (m *FakeClusterConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *FakeClusterConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCrashingPrograms() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FakeClusterConfigValidationError{
						field:  fmt.Sprintf("CrashingPrograms[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FakeClusterConfigValidationError{
						field:  fmt.Sprintf("CrashingPrograms[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FakeClusterConfigValidationError{
					field:  fmt.Sprintf("CrashingPrograms[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FakeClusterConfigMultiError(errors)
	}

	return nil
}

// FakeClusterConfigMultiError is an error wrapping multiple validation errors
// returned by FakeClusterConfig.ValidateAll() if the designated constraints
// aren't met.
type FakeClusterConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FakeClusterConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FakeClusterConfigMultiError) AllErrors() []error { return m }

// FakeClusterConfigValidationError is the validation error returned by
// FakeClusterConfig.Validate if the designated constraints aren't met.
type FakeClusterConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FakeClusterConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FakeClusterConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FakeClusterConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FakeClusterConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FakeClusterConfigValidationError) ErrorName() string {
	return "FakeClusterConfigValidationError"
}

// Error satisfies the builtin error interface
func (e FakeClusterConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFakeClusterConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FakeClusterConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FakeClusterConfigValidationError{}

// Validate checks the field values on GenericDockerCommand with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenericDockerCommand) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenericDockerCommand with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenericDockerCommandMultiError, or nil if none found.
func (m *GenericDockerCommand) ValidateAll() error {
	return m.validate(true)
}

func (m *GenericDockerCommand) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenericDockerCommandValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenericDockerCommandValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenericDockerCommandValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenericDockerCommandMultiError(errors)
	}

	return nil
}

// GenericDockerCommandMultiError is an error wrapping multiple validation
// errors returned by GenericDockerCommand.ValidateAll() if the designated
// constraints aren't met.
type GenericDockerCommandMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenericDockerCommandMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenericDockerCommandMultiError) AllErrors() []error { return m }

// GenericDockerCommandValidationError is the validation error returned by
// GenericDockerCommand.Validate if the designated constraints aren't met.
type GenericDockerCommandValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenericDockerCommandValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenericDockerCommandValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenericDockerCommandValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenericDockerCommandValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenericDockerCommandValidationError) ErrorName() string {
	return "GenericDockerCommandValidationError"
}

// Error satisfies the builtin error interface
func (e GenericDockerCommandValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenericDockerCommand.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenericDockerCommandValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenericDockerCommandValidationError{}

// Validate checks the field values on GenericDockerClusterConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenericDockerClusterConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenericDockerClusterConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenericDockerClusterConfigMultiError, or nil if none found.
func (m *GenericDockerClusterConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *GenericDockerClusterConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetApply()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenericDockerClusterConfigValidationError{
					field:  "Apply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenericDockerClusterConfigValidationError{
					field:  "Apply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApply()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenericDockerClusterConfigValidationError{
				field:  "Apply",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGetCurrentState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenericDockerClusterConfigValidationError{
					field:  "GetCurrentState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenericDockerClusterConfigValidationError{
					field:  "GetCurrentState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetCurrentState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenericDockerClusterConfigValidationError{
				field:  "GetCurrentState",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenericDockerClusterConfigMultiError(errors)
	}

	return nil
}

// GenericDockerClusterConfigMultiError is an error wrapping multiple
// validation errors returned by GenericDockerClusterConfig.ValidateAll() if
// the designated constraints aren't met.
type GenericDockerClusterConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenericDockerClusterConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenericDockerClusterConfigMultiError) AllErrors() []error { return m }

// GenericDockerClusterConfigValidationError is the validation error returned
// by GenericDockerClusterConfig.Validate if the designated constraints aren't met.
type GenericDockerClusterConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenericDockerClusterConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenericDockerClusterConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenericDockerClusterConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenericDockerClusterConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenericDockerClusterConfigValidationError) ErrorName() string {
	return "GenericDockerClusterConfigValidationError"
}

// Error satisfies the builtin error interface
func (e GenericDockerClusterConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenericDockerClusterConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenericDockerClusterConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenericDockerClusterConfigValidationError{}

// Validate checks the field values on ClusterConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterConfigMultiError, or
// nil if none found.
func (m *ClusterConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for DisableFlagger

	// no validation rules for DisableIstio

	if all {
		switch v := interface{}(m.GetKubecost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "Kubecost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "Kubecost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKubecost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterConfigValidationError{
				field:  "Kubecost",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDatadog()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "Datadog",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "Datadog",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatadog()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterConfigValidationError{
				field:  "Datadog",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAlbIngress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "AlbIngress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "AlbIngress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAlbIngress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterConfigValidationError{
				field:  "AlbIngress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetArgoRollouts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "ArgoRollouts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "ArgoRollouts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetArgoRollouts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterConfigValidationError{
				field:  "ArgoRollouts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGkeIngress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "GkeIngress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "GkeIngress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGkeIngress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterConfigValidationError{
				field:  "GkeIngress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSelfManagedGkeIngress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "SelfManagedGkeIngress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "SelfManagedGkeIngress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSelfManagedGkeIngress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterConfigValidationError{
				field:  "SelfManagedGkeIngress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CloudProvider

	switch v := m.ClusterOneof.(type) {
	case *ClusterConfig_Fake:
		if v == nil {
			err := ClusterConfigValidationError{
				field:  "ClusterOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFake()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterConfigValidationError{
						field:  "Fake",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterConfigValidationError{
						field:  "Fake",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFake()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterConfigValidationError{
					field:  "Fake",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ClusterConfig_GenericDocker:
		if v == nil {
			err := ClusterConfigValidationError{
				field:  "ClusterOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGenericDocker()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterConfigValidationError{
						field:  "GenericDocker",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterConfigValidationError{
						field:  "GenericDocker",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGenericDocker()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterConfigValidationError{
					field:  "GenericDocker",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ClusterConfigMultiError(errors)
	}

	return nil
}

// ClusterConfigMultiError is an error wrapping multiple validation errors
// returned by ClusterConfig.ValidateAll() if the designated constraints
// aren't met.
type ClusterConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConfigMultiError) AllErrors() []error { return m }

// ClusterConfigValidationError is the validation error returned by
// ClusterConfig.Validate if the designated constraints aren't met.
type ClusterConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConfigValidationError) ErrorName() string { return "ClusterConfigValidationError" }

// Error satisfies the builtin error interface
func (e ClusterConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConfigValidationError{}

// Validate checks the field values on ClusterAuth_ECSAuth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterAuth_ECSAuth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterAuth_ECSAuth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterAuth_ECSAuthMultiError, or nil if none found.
func (m *ClusterAuth_ECSAuth) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterAuth_ECSAuth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessKey

	// no validation rules for SecretKey

	// no validation rules for Region

	// no validation rules for AssumeRoleArn

	// no validation rules for ClusterArn

	if len(errors) > 0 {
		return ClusterAuth_ECSAuthMultiError(errors)
	}

	return nil
}

// ClusterAuth_ECSAuthMultiError is an error wrapping multiple validation
// errors returned by ClusterAuth_ECSAuth.ValidateAll() if the designated
// constraints aren't met.
type ClusterAuth_ECSAuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterAuth_ECSAuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterAuth_ECSAuthMultiError) AllErrors() []error { return m }

// ClusterAuth_ECSAuthValidationError is the validation error returned by
// ClusterAuth_ECSAuth.Validate if the designated constraints aren't met.
type ClusterAuth_ECSAuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterAuth_ECSAuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterAuth_ECSAuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterAuth_ECSAuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterAuth_ECSAuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterAuth_ECSAuthValidationError) ErrorName() string {
	return "ClusterAuth_ECSAuthValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterAuth_ECSAuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterAuth_ECSAuth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterAuth_ECSAuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterAuth_ECSAuthValidationError{}

// Validate checks the field values on ClusterAuth_GenericDockerAuth with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterAuth_GenericDockerAuth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterAuth_GenericDockerAuth with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ClusterAuth_GenericDockerAuthMultiError, or nil if none found.
func (m *ClusterAuth_GenericDockerAuth) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterAuth_GenericDockerAuth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProxyRuntime

	if len(errors) > 0 {
		return ClusterAuth_GenericDockerAuthMultiError(errors)
	}

	return nil
}

// ClusterAuth_GenericDockerAuthMultiError is an error wrapping multiple
// validation errors returned by ClusterAuth_GenericDockerAuth.ValidateAll()
// if the designated constraints aren't met.
type ClusterAuth_GenericDockerAuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterAuth_GenericDockerAuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterAuth_GenericDockerAuthMultiError) AllErrors() []error { return m }

// ClusterAuth_GenericDockerAuthValidationError is the validation error
// returned by ClusterAuth_GenericDockerAuth.Validate if the designated
// constraints aren't met.
type ClusterAuth_GenericDockerAuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterAuth_GenericDockerAuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterAuth_GenericDockerAuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterAuth_GenericDockerAuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterAuth_GenericDockerAuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterAuth_GenericDockerAuthValidationError) ErrorName() string {
	return "ClusterAuth_GenericDockerAuthValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterAuth_GenericDockerAuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterAuth_GenericDockerAuth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterAuth_GenericDockerAuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterAuth_GenericDockerAuthValidationError{}

// Validate checks the field values on
// FakeClusterConfig_CrashingProgramPatterns with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FakeClusterConfig_CrashingProgramPatterns) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// FakeClusterConfig_CrashingProgramPatterns with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// FakeClusterConfig_CrashingProgramPatternsMultiError, or nil if none found.
func (m *FakeClusterConfig_CrashingProgramPatterns) ValidateAll() error {
	return m.validate(true)
}

func (m *FakeClusterConfig_CrashingProgramPatterns) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ImageRegex

	// no validation rules for CmdRegex

	// no validation rules for LogOutput

	if len(errors) > 0 {
		return FakeClusterConfig_CrashingProgramPatternsMultiError(errors)
	}

	return nil
}

// FakeClusterConfig_CrashingProgramPatternsMultiError is an error wrapping
// multiple validation errors returned by
// FakeClusterConfig_CrashingProgramPatterns.ValidateAll() if the designated
// constraints aren't met.
type FakeClusterConfig_CrashingProgramPatternsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FakeClusterConfig_CrashingProgramPatternsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FakeClusterConfig_CrashingProgramPatternsMultiError) AllErrors() []error { return m }

// FakeClusterConfig_CrashingProgramPatternsValidationError is the validation
// error returned by FakeClusterConfig_CrashingProgramPatterns.Validate if the
// designated constraints aren't met.
type FakeClusterConfig_CrashingProgramPatternsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FakeClusterConfig_CrashingProgramPatternsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FakeClusterConfig_CrashingProgramPatternsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FakeClusterConfig_CrashingProgramPatternsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FakeClusterConfig_CrashingProgramPatternsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FakeClusterConfig_CrashingProgramPatternsValidationError) ErrorName() string {
	return "FakeClusterConfig_CrashingProgramPatternsValidationError"
}

// Error satisfies the builtin error interface
func (e FakeClusterConfig_CrashingProgramPatternsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFakeClusterConfig_CrashingProgramPatterns.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FakeClusterConfig_CrashingProgramPatternsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FakeClusterConfig_CrashingProgramPatternsValidationError{}

// Validate checks the field values on ClusterConfig_Kubecost with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterConfig_Kubecost) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterConfig_Kubecost with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterConfig_KubecostMultiError, or nil if none found.
func (m *ClusterConfig_Kubecost) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConfig_Kubecost) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	// no validation rules for Managed

	// no validation rules for KubecostNamespace

	if len(errors) > 0 {
		return ClusterConfig_KubecostMultiError(errors)
	}

	return nil
}

// ClusterConfig_KubecostMultiError is an error wrapping multiple validation
// errors returned by ClusterConfig_Kubecost.ValidateAll() if the designated
// constraints aren't met.
type ClusterConfig_KubecostMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConfig_KubecostMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConfig_KubecostMultiError) AllErrors() []error { return m }

// ClusterConfig_KubecostValidationError is the validation error returned by
// ClusterConfig_Kubecost.Validate if the designated constraints aren't met.
type ClusterConfig_KubecostValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConfig_KubecostValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConfig_KubecostValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConfig_KubecostValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConfig_KubecostValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConfig_KubecostValidationError) ErrorName() string {
	return "ClusterConfig_KubecostValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterConfig_KubecostValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConfig_Kubecost.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConfig_KubecostValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConfig_KubecostValidationError{}

// Validate checks the field values on ClusterConfig_Datadog with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterConfig_Datadog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterConfig_Datadog with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterConfig_DatadogMultiError, or nil if none found.
func (m *ClusterConfig_Datadog) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConfig_Datadog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	// no validation rules for Managed

	// no validation rules for DatadogNamespace

	// no validation rules for ApiKey

	// no validation rules for Site

	if len(errors) > 0 {
		return ClusterConfig_DatadogMultiError(errors)
	}

	return nil
}

// ClusterConfig_DatadogMultiError is an error wrapping multiple validation
// errors returned by ClusterConfig_Datadog.ValidateAll() if the designated
// constraints aren't met.
type ClusterConfig_DatadogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConfig_DatadogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConfig_DatadogMultiError) AllErrors() []error { return m }

// ClusterConfig_DatadogValidationError is the validation error returned by
// ClusterConfig_Datadog.Validate if the designated constraints aren't met.
type ClusterConfig_DatadogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConfig_DatadogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConfig_DatadogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConfig_DatadogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConfig_DatadogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConfig_DatadogValidationError) ErrorName() string {
	return "ClusterConfig_DatadogValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterConfig_DatadogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConfig_Datadog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConfig_DatadogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConfig_DatadogValidationError{}

// Validate checks the field values on ClusterConfig_ALBIngress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterConfig_ALBIngress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterConfig_ALBIngress with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterConfig_ALBIngressMultiError, or nil if none found.
func (m *ClusterConfig_ALBIngress) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConfig_ALBIngress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	if utf8.RuneCountInString(m.GetIngressClass()) < 1 {
		err := ClusterConfig_ALBIngressValidationError{
			field:  "IngressClass",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ClusterConfig_ALBIngressMultiError(errors)
	}

	return nil
}

// ClusterConfig_ALBIngressMultiError is an error wrapping multiple validation
// errors returned by ClusterConfig_ALBIngress.ValidateAll() if the designated
// constraints aren't met.
type ClusterConfig_ALBIngressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConfig_ALBIngressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConfig_ALBIngressMultiError) AllErrors() []error { return m }

// ClusterConfig_ALBIngressValidationError is the validation error returned by
// ClusterConfig_ALBIngress.Validate if the designated constraints aren't met.
type ClusterConfig_ALBIngressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConfig_ALBIngressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConfig_ALBIngressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConfig_ALBIngressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConfig_ALBIngressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConfig_ALBIngressValidationError) ErrorName() string {
	return "ClusterConfig_ALBIngressValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterConfig_ALBIngressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConfig_ALBIngress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConfig_ALBIngressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConfig_ALBIngressValidationError{}

// Validate checks the field values on ClusterConfig_ArgoRollouts with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterConfig_ArgoRollouts) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterConfig_ArgoRollouts with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterConfig_ArgoRolloutsMultiError, or nil if none found.
func (m *ClusterConfig_ArgoRollouts) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConfig_ArgoRollouts) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	for idx, item := range m.GetTemplates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterConfig_ArgoRolloutsValidationError{
						field:  fmt.Sprintf("Templates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterConfig_ArgoRolloutsValidationError{
						field:  fmt.Sprintf("Templates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterConfig_ArgoRolloutsValidationError{
					field:  fmt.Sprintf("Templates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ClusterConfig_ArgoRolloutsMultiError(errors)
	}

	return nil
}

// ClusterConfig_ArgoRolloutsMultiError is an error wrapping multiple
// validation errors returned by ClusterConfig_ArgoRollouts.ValidateAll() if
// the designated constraints aren't met.
type ClusterConfig_ArgoRolloutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConfig_ArgoRolloutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConfig_ArgoRolloutsMultiError) AllErrors() []error { return m }

// ClusterConfig_ArgoRolloutsValidationError is the validation error returned
// by ClusterConfig_ArgoRollouts.Validate if the designated constraints aren't met.
type ClusterConfig_ArgoRolloutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConfig_ArgoRolloutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConfig_ArgoRolloutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConfig_ArgoRolloutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConfig_ArgoRolloutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConfig_ArgoRolloutsValidationError) ErrorName() string {
	return "ClusterConfig_ArgoRolloutsValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterConfig_ArgoRolloutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConfig_ArgoRollouts.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConfig_ArgoRolloutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConfig_ArgoRolloutsValidationError{}

// Validate checks the field values on ClusterConfig_GKEIngress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterConfig_GKEIngress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterConfig_GKEIngress with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterConfig_GKEIngressMultiError, or nil if none found.
func (m *ClusterConfig_GKEIngress) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConfig_GKEIngress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	// no validation rules for ContainerNative

	if len(errors) > 0 {
		return ClusterConfig_GKEIngressMultiError(errors)
	}

	return nil
}

// ClusterConfig_GKEIngressMultiError is an error wrapping multiple validation
// errors returned by ClusterConfig_GKEIngress.ValidateAll() if the designated
// constraints aren't met.
type ClusterConfig_GKEIngressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConfig_GKEIngressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConfig_GKEIngressMultiError) AllErrors() []error { return m }

// ClusterConfig_GKEIngressValidationError is the validation error returned by
// ClusterConfig_GKEIngress.Validate if the designated constraints aren't met.
type ClusterConfig_GKEIngressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConfig_GKEIngressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConfig_GKEIngressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConfig_GKEIngressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConfig_GKEIngressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConfig_GKEIngressValidationError) ErrorName() string {
	return "ClusterConfig_GKEIngressValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterConfig_GKEIngressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConfig_GKEIngress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConfig_GKEIngressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConfig_GKEIngressValidationError{}

// Validate checks the field values on
// ClusterConfig_ArgoRollouts_AnalysisTemplate with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterConfig_ArgoRollouts_AnalysisTemplate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ClusterConfig_ArgoRollouts_AnalysisTemplate with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ClusterConfig_ArgoRollouts_AnalysisTemplateMultiError, or nil if none found.
func (m *ClusterConfig_ArgoRollouts_AnalysisTemplate) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConfig_ArgoRollouts_AnalysisTemplate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for ArgMapping

	if len(errors) > 0 {
		return ClusterConfig_ArgoRollouts_AnalysisTemplateMultiError(errors)
	}

	return nil
}

// ClusterConfig_ArgoRollouts_AnalysisTemplateMultiError is an error wrapping
// multiple validation errors returned by
// ClusterConfig_ArgoRollouts_AnalysisTemplate.ValidateAll() if the designated
// constraints aren't met.
type ClusterConfig_ArgoRollouts_AnalysisTemplateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConfig_ArgoRollouts_AnalysisTemplateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConfig_ArgoRollouts_AnalysisTemplateMultiError) AllErrors() []error { return m }

// ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError is the validation
// error returned by ClusterConfig_ArgoRollouts_AnalysisTemplate.Validate if
// the designated constraints aren't met.
type ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError) ErrorName() string {
	return "ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConfig_ArgoRollouts_AnalysisTemplate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError{}
