// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: prodvana/environment/clusters.proto

package environment

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ClusterAuth with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterAuth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterAuth with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterAuthMultiError, or
// nil if none found.
func (m *ClusterAuth) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterAuth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Endpoint

	// no validation rules for CaCert

	// no validation rules for Token

	// no validation rules for ServiceAccount

	// no validation rules for K8SAgentAuth

	switch v := m.AuthOneof.(type) {
	case *ClusterAuth_Ecs:
		if v == nil {
			err := ClusterAuthValidationError{
				field:  "AuthOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEcs()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterAuthValidationError{
						field:  "Ecs",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterAuthValidationError{
						field:  "Ecs",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEcs()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterAuthValidationError{
					field:  "Ecs",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ClusterAuth_K8S:
		if v == nil {
			err := ClusterAuthValidationError{
				field:  "AuthOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetK8S()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterAuthValidationError{
						field:  "K8S",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterAuthValidationError{
						field:  "K8S",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetK8S()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterAuthValidationError{
					field:  "K8S",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ClusterAuthMultiError(errors)
	}

	return nil
}

// ClusterAuthMultiError is an error wrapping multiple validation errors
// returned by ClusterAuth.ValidateAll() if the designated constraints aren't met.
type ClusterAuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterAuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterAuthMultiError) AllErrors() []error { return m }

// ClusterAuthValidationError is the validation error returned by
// ClusterAuth.Validate if the designated constraints aren't met.
type ClusterAuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterAuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterAuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterAuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterAuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterAuthValidationError) ErrorName() string { return "ClusterAuthValidationError" }

// Error satisfies the builtin error interface
func (e ClusterAuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterAuth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterAuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterAuthValidationError{}

// Validate checks the field values on Cluster with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Cluster) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Cluster with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ClusterMultiError, or nil if none found.
func (m *Cluster) ValidateAll() error {
	return m.validate(true)
}

func (m *Cluster) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for ClusterId

	// no validation rules for Origin

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastHeartbeatTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "LastHeartbeatTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "LastHeartbeatTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastHeartbeatTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "LastHeartbeatTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClusterMultiError(errors)
	}

	return nil
}

// ClusterMultiError is an error wrapping multiple validation errors returned
// by Cluster.ValidateAll() if the designated constraints aren't met.
type ClusterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterMultiError) AllErrors() []error { return m }

// ClusterValidationError is the validation error returned by Cluster.Validate
// if the designated constraints aren't met.
type ClusterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterValidationError) ErrorName() string { return "ClusterValidationError" }

// Error satisfies the builtin error interface
func (e ClusterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCluster.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterValidationError{}

// Validate checks the field values on FakeClusterConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FakeClusterConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FakeClusterConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FakeClusterConfigMultiError, or nil if none found.
func (m *FakeClusterConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *FakeClusterConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCrashingPrograms() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FakeClusterConfigValidationError{
						field:  fmt.Sprintf("CrashingPrograms[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FakeClusterConfigValidationError{
						field:  fmt.Sprintf("CrashingPrograms[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FakeClusterConfigValidationError{
					field:  fmt.Sprintf("CrashingPrograms[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FakeClusterConfigMultiError(errors)
	}

	return nil
}

// FakeClusterConfigMultiError is an error wrapping multiple validation errors
// returned by FakeClusterConfig.ValidateAll() if the designated constraints
// aren't met.
type FakeClusterConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FakeClusterConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FakeClusterConfigMultiError) AllErrors() []error { return m }

// FakeClusterConfigValidationError is the validation error returned by
// FakeClusterConfig.Validate if the designated constraints aren't met.
type FakeClusterConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FakeClusterConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FakeClusterConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FakeClusterConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FakeClusterConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FakeClusterConfigValidationError) ErrorName() string {
	return "FakeClusterConfigValidationError"
}

// Error satisfies the builtin error interface
func (e FakeClusterConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFakeClusterConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FakeClusterConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FakeClusterConfigValidationError{}

// Validate checks the field values on RetryPolicy with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RetryPolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetryPolicy with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RetryPolicyMultiError, or
// nil if none found.
func (m *RetryPolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *RetryPolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if d := m.GetBaseInterval(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = RetryPolicyValidationError{
				field:  "BaseInterval",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			gt := time.Duration(0*time.Second + 0*time.Nanosecond)

			if dur <= gt {
				err := RetryPolicyValidationError{
					field:  "BaseInterval",
					reason: "value must be greater than 0s",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if d := m.GetMaxInterval(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = RetryPolicyValidationError{
				field:  "MaxInterval",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			gt := time.Duration(0*time.Second + 0*time.Nanosecond)

			if dur <= gt {
				err := RetryPolicyValidationError{
					field:  "MaxInterval",
					reason: "value must be greater than 0s",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if len(errors) > 0 {
		return RetryPolicyMultiError(errors)
	}

	return nil
}

// RetryPolicyMultiError is an error wrapping multiple validation errors
// returned by RetryPolicy.ValidateAll() if the designated constraints aren't met.
type RetryPolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetryPolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetryPolicyMultiError) AllErrors() []error { return m }

// RetryPolicyValidationError is the validation error returned by
// RetryPolicy.Validate if the designated constraints aren't met.
type RetryPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetryPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetryPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetryPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetryPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetryPolicyValidationError) ErrorName() string { return "RetryPolicyValidationError" }

// Error satisfies the builtin error interface
func (e RetryPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetryPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetryPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetryPolicyValidationError{}

// Validate checks the field values on ExtensionFetchCommand with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExtensionFetchCommand) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExtensionFetchCommand with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExtensionFetchCommandMultiError, or nil if none found.
func (m *ExtensionFetchCommand) ValidateAll() error {
	return m.validate(true)
}

func (m *ExtensionFetchCommand) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPollInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtensionFetchCommandValidationError{
					field:  "PollInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtensionFetchCommandValidationError{
					field:  "PollInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPollInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtensionFetchCommandValidationError{
				field:  "PollInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSteadyStatePollInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtensionFetchCommandValidationError{
					field:  "SteadyStatePollInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtensionFetchCommandValidationError{
					field:  "SteadyStatePollInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSteadyStatePollInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtensionFetchCommandValidationError{
				field:  "SteadyStatePollInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtensionFetchCommandValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtensionFetchCommandValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtensionFetchCommandValidationError{
				field:  "Timeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRetryPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtensionFetchCommandValidationError{
					field:  "RetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtensionFetchCommandValidationError{
					field:  "RetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRetryPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtensionFetchCommandValidationError{
				field:  "RetryPolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetEnv()))
		i := 0
		for key := range m.GetEnv() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetEnv()[key]
			_ = val

			if val == nil {
				err := ExtensionFetchCommandValidationError{
					field:  fmt.Sprintf("Env[%v]", key),
					reason: "value cannot be sparse, all pairs must be non-nil",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_ExtensionFetchCommand_Env_Pattern.MatchString(key) {
				err := ExtensionFetchCommandValidationError{
					field:  fmt.Sprintf("Env[%v]", key),
					reason: "value does not match regex pattern \"^[a-zA-Z_]+[a-zA-Z0-9_]*$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ExtensionFetchCommandValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ExtensionFetchCommandValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ExtensionFetchCommandValidationError{
						field:  fmt.Sprintf("Env[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	oneofExecConfigPresent := false
	switch v := m.ExecConfig.(type) {
	case *ExtensionFetchCommand_TaskConfig:
		if v == nil {
			err := ExtensionFetchCommandValidationError{
				field:  "ExecConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofExecConfigPresent = true

		if all {
			switch v := interface{}(m.GetTaskConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExtensionFetchCommandValidationError{
						field:  "TaskConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExtensionFetchCommandValidationError{
						field:  "TaskConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTaskConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExtensionFetchCommandValidationError{
					field:  "TaskConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExtensionFetchCommand_KubernetesConfig:
		if v == nil {
			err := ExtensionFetchCommandValidationError{
				field:  "ExecConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofExecConfigPresent = true

		if all {
			switch v := interface{}(m.GetKubernetesConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExtensionFetchCommandValidationError{
						field:  "KubernetesConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExtensionFetchCommandValidationError{
						field:  "KubernetesConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKubernetesConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExtensionFetchCommandValidationError{
					field:  "KubernetesConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofExecConfigPresent {
		err := ExtensionFetchCommandValidationError{
			field:  "ExecConfig",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ExtensionFetchCommandMultiError(errors)
	}

	return nil
}

// ExtensionFetchCommandMultiError is an error wrapping multiple validation
// errors returned by ExtensionFetchCommand.ValidateAll() if the designated
// constraints aren't met.
type ExtensionFetchCommandMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtensionFetchCommandMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtensionFetchCommandMultiError) AllErrors() []error { return m }

// ExtensionFetchCommandValidationError is the validation error returned by
// ExtensionFetchCommand.Validate if the designated constraints aren't met.
type ExtensionFetchCommandValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtensionFetchCommandValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtensionFetchCommandValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtensionFetchCommandValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtensionFetchCommandValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtensionFetchCommandValidationError) ErrorName() string {
	return "ExtensionFetchCommandValidationError"
}

// Error satisfies the builtin error interface
func (e ExtensionFetchCommandValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtensionFetchCommand.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtensionFetchCommandValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtensionFetchCommandValidationError{}

var _ExtensionFetchCommand_Env_Pattern = regexp.MustCompile("^[a-zA-Z_]+[a-zA-Z0-9_]*$")

// Validate checks the field values on ExtensionApplyCommand with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExtensionApplyCommand) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExtensionApplyCommand with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExtensionApplyCommandMultiError, or nil if none found.
func (m *ExtensionApplyCommand) ValidateAll() error {
	return m.validate(true)
}

func (m *ExtensionApplyCommand) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtensionApplyCommandValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtensionApplyCommandValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtensionApplyCommandValidationError{
				field:  "Timeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetEnv()))
		i := 0
		for key := range m.GetEnv() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetEnv()[key]
			_ = val

			if val == nil {
				err := ExtensionApplyCommandValidationError{
					field:  fmt.Sprintf("Env[%v]", key),
					reason: "value cannot be sparse, all pairs must be non-nil",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_ExtensionApplyCommand_Env_Pattern.MatchString(key) {
				err := ExtensionApplyCommandValidationError{
					field:  fmt.Sprintf("Env[%v]", key),
					reason: "value does not match regex pattern \"^[a-zA-Z_]+[a-zA-Z0-9_]*$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ExtensionApplyCommandValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ExtensionApplyCommandValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ExtensionApplyCommandValidationError{
						field:  fmt.Sprintf("Env[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetRetryPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtensionApplyCommandValidationError{
					field:  "RetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtensionApplyCommandValidationError{
					field:  "RetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRetryPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtensionApplyCommandValidationError{
				field:  "RetryPolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	oneofExecConfigPresent := false
	switch v := m.ExecConfig.(type) {
	case *ExtensionApplyCommand_TaskConfig:
		if v == nil {
			err := ExtensionApplyCommandValidationError{
				field:  "ExecConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofExecConfigPresent = true

		if all {
			switch v := interface{}(m.GetTaskConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExtensionApplyCommandValidationError{
						field:  "TaskConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExtensionApplyCommandValidationError{
						field:  "TaskConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTaskConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExtensionApplyCommandValidationError{
					field:  "TaskConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExtensionApplyCommand_KubernetesConfig:
		if v == nil {
			err := ExtensionApplyCommandValidationError{
				field:  "ExecConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofExecConfigPresent = true

		if all {
			switch v := interface{}(m.GetKubernetesConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExtensionApplyCommandValidationError{
						field:  "KubernetesConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExtensionApplyCommandValidationError{
						field:  "KubernetesConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKubernetesConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExtensionApplyCommandValidationError{
					field:  "KubernetesConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofExecConfigPresent {
		err := ExtensionApplyCommandValidationError{
			field:  "ExecConfig",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ExtensionApplyCommandMultiError(errors)
	}

	return nil
}

// ExtensionApplyCommandMultiError is an error wrapping multiple validation
// errors returned by ExtensionApplyCommand.ValidateAll() if the designated
// constraints aren't met.
type ExtensionApplyCommandMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtensionApplyCommandMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtensionApplyCommandMultiError) AllErrors() []error { return m }

// ExtensionApplyCommandValidationError is the validation error returned by
// ExtensionApplyCommand.Validate if the designated constraints aren't met.
type ExtensionApplyCommandValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtensionApplyCommandValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtensionApplyCommandValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtensionApplyCommandValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtensionApplyCommandValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtensionApplyCommandValidationError) ErrorName() string {
	return "ExtensionApplyCommandValidationError"
}

// Error satisfies the builtin error interface
func (e ExtensionApplyCommandValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtensionApplyCommand.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtensionApplyCommandValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtensionApplyCommandValidationError{}

var _ExtensionApplyCommand_Env_Pattern = regexp.MustCompile("^[a-zA-Z_]+[a-zA-Z0-9_]*$")

// Validate checks the field values on ExtensionClusterConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExtensionClusterConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExtensionClusterConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExtensionClusterConfigMultiError, or nil if none found.
func (m *ExtensionClusterConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ExtensionClusterConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApply() == nil {
		err := ExtensionClusterConfigValidationError{
			field:  "Apply",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetApply()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtensionClusterConfigValidationError{
					field:  "Apply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtensionClusterConfigValidationError{
					field:  "Apply",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApply()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtensionClusterConfigValidationError{
				field:  "Apply",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFetch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtensionClusterConfigValidationError{
					field:  "Fetch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtensionClusterConfigValidationError{
					field:  "Fetch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFetch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtensionClusterConfigValidationError{
				field:  "Fetch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if item == nil {
			err := ExtensionClusterConfigValidationError{
				field:  fmt.Sprintf("Parameters[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExtensionClusterConfigValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExtensionClusterConfigValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExtensionClusterConfigValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GetProxyRuntime() == nil {
		err := ExtensionClusterConfigValidationError{
			field:  "ProxyRuntime",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProxyRuntime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtensionClusterConfigValidationError{
					field:  "ProxyRuntime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtensionClusterConfigValidationError{
					field:  "ProxyRuntime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProxyRuntime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtensionClusterConfigValidationError{
				field:  "ProxyRuntime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	// no validation rules for RequireApprovalBeforeApply

	if d := m.GetConvergenceGracePeriod(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = ExtensionClusterConfigValidationError{
				field:  "ConvergenceGracePeriod",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			gt := time.Duration(0*time.Second + 0*time.Nanosecond)

			if dur <= gt {
				err := ExtensionClusterConfigValidationError{
					field:  "ConvergenceGracePeriod",
					reason: "value must be greater than 0s",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if len(errors) > 0 {
		return ExtensionClusterConfigMultiError(errors)
	}

	return nil
}

// ExtensionClusterConfigMultiError is an error wrapping multiple validation
// errors returned by ExtensionClusterConfig.ValidateAll() if the designated
// constraints aren't met.
type ExtensionClusterConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtensionClusterConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtensionClusterConfigMultiError) AllErrors() []error { return m }

// ExtensionClusterConfigValidationError is the validation error returned by
// ExtensionClusterConfig.Validate if the designated constraints aren't met.
type ExtensionClusterConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtensionClusterConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtensionClusterConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtensionClusterConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtensionClusterConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtensionClusterConfigValidationError) ErrorName() string {
	return "ExtensionClusterConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ExtensionClusterConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtensionClusterConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtensionClusterConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtensionClusterConfigValidationError{}

// Validate checks the field values on CompiledExtensionCommand with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompiledExtensionCommand) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompiledExtensionCommand with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompiledExtensionCommandMultiError, or nil if none found.
func (m *CompiledExtensionCommand) ValidateAll() error {
	return m.validate(true)
}

func (m *CompiledExtensionCommand) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NamePrefix

	if all {
		switch v := interface{}(m.GetCommand()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompiledExtensionCommandValidationError{
					field:  "Command",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompiledExtensionCommandValidationError{
					field:  "Command",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommand()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompiledExtensionCommandValidationError{
				field:  "Command",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRuntimeExecution()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompiledExtensionCommandValidationError{
					field:  "RuntimeExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompiledExtensionCommandValidationError{
					field:  "RuntimeExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntimeExecution()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompiledExtensionCommandValidationError{
				field:  "RuntimeExecution",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetEnv()))
		i := 0
		for key := range m.GetEnv() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetEnv()[key]
			_ = val

			// no validation rules for Env[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CompiledExtensionCommandValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CompiledExtensionCommandValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CompiledExtensionCommandValidationError{
						field:  fmt.Sprintf("Env[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return CompiledExtensionCommandMultiError(errors)
	}

	return nil
}

// CompiledExtensionCommandMultiError is an error wrapping multiple validation
// errors returned by CompiledExtensionCommand.ValidateAll() if the designated
// constraints aren't met.
type CompiledExtensionCommandMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompiledExtensionCommandMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompiledExtensionCommandMultiError) AllErrors() []error { return m }

// CompiledExtensionCommandValidationError is the validation error returned by
// CompiledExtensionCommand.Validate if the designated constraints aren't met.
type CompiledExtensionCommandValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompiledExtensionCommandValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompiledExtensionCommandValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompiledExtensionCommandValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompiledExtensionCommandValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompiledExtensionCommandValidationError) ErrorName() string {
	return "CompiledExtensionCommandValidationError"
}

// Error satisfies the builtin error interface
func (e CompiledExtensionCommandValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompiledExtensionCommand.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompiledExtensionCommandValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompiledExtensionCommandValidationError{}

// Validate checks the field values on IacRunnerCommand with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IacRunnerCommand) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IacRunnerCommand with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IacRunnerCommandMultiError, or nil if none found.
func (m *IacRunnerCommand) ValidateAll() error {
	return m.validate(true)
}

func (m *IacRunnerCommand) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCmd()) < 1 {
		err := IacRunnerCommandValidationError{
			field:  "Cmd",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return IacRunnerCommandMultiError(errors)
	}

	return nil
}

// IacRunnerCommandMultiError is an error wrapping multiple validation errors
// returned by IacRunnerCommand.ValidateAll() if the designated constraints
// aren't met.
type IacRunnerCommandMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IacRunnerCommandMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IacRunnerCommandMultiError) AllErrors() []error { return m }

// IacRunnerCommandValidationError is the validation error returned by
// IacRunnerCommand.Validate if the designated constraints aren't met.
type IacRunnerCommandValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IacRunnerCommandValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IacRunnerCommandValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IacRunnerCommandValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IacRunnerCommandValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IacRunnerCommandValidationError) ErrorName() string { return "IacRunnerCommandValidationError" }

// Error satisfies the builtin error interface
func (e IacRunnerCommandValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIacRunnerCommand.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IacRunnerCommandValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IacRunnerCommandValidationError{}

// Validate checks the field values on TerraformRunnerConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TerraformRunnerConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TerraformRunnerConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TerraformRunnerConfigMultiError, or nil if none found.
func (m *TerraformRunnerConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TerraformRunnerConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProxyRuntime() == nil {
		err := TerraformRunnerConfigValidationError{
			field:  "ProxyRuntime",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProxyRuntime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TerraformRunnerConfigValidationError{
					field:  "ProxyRuntime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TerraformRunnerConfigValidationError{
					field:  "ProxyRuntime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProxyRuntime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TerraformRunnerConfigValidationError{
				field:  "ProxyRuntime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetEnv()))
		i := 0
		for key := range m.GetEnv() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetEnv()[key]
			_ = val

			// no validation rules for Env[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TerraformRunnerConfigValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TerraformRunnerConfigValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TerraformRunnerConfigValidationError{
						field:  fmt.Sprintf("Env[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetVolumes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TerraformRunnerConfigValidationError{
						field:  fmt.Sprintf("Volumes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TerraformRunnerConfigValidationError{
						field:  fmt.Sprintf("Volumes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TerraformRunnerConfigValidationError{
					field:  fmt.Sprintf("Volumes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPreRun() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TerraformRunnerConfigValidationError{
						field:  fmt.Sprintf("PreRun[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TerraformRunnerConfigValidationError{
						field:  fmt.Sprintf("PreRun[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TerraformRunnerConfigValidationError{
					field:  fmt.Sprintf("PreRun[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPollInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TerraformRunnerConfigValidationError{
					field:  "PollInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TerraformRunnerConfigValidationError{
					field:  "PollInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPollInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TerraformRunnerConfigValidationError{
				field:  "PollInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSteadyStatePollInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TerraformRunnerConfigValidationError{
					field:  "SteadyStatePollInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TerraformRunnerConfigValidationError{
					field:  "SteadyStatePollInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSteadyStatePollInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TerraformRunnerConfigValidationError{
				field:  "SteadyStatePollInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequireApprovalBeforeApply

	if d := m.GetConvergenceGracePeriod(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = TerraformRunnerConfigValidationError{
				field:  "ConvergenceGracePeriod",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			gt := time.Duration(0*time.Second + 0*time.Nanosecond)

			if dur <= gt {
				err := TerraformRunnerConfigValidationError{
					field:  "ConvergenceGracePeriod",
					reason: "value must be greater than 0s",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if all {
		switch v := interface{}(m.GetFetchRetryPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TerraformRunnerConfigValidationError{
					field:  "FetchRetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TerraformRunnerConfigValidationError{
					field:  "FetchRetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFetchRetryPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TerraformRunnerConfigValidationError{
				field:  "FetchRetryPolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetApplyRetryPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TerraformRunnerConfigValidationError{
					field:  "ApplyRetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TerraformRunnerConfigValidationError{
					field:  "ApplyRetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApplyRetryPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TerraformRunnerConfigValidationError{
				field:  "ApplyRetryPolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TerraformRunnerConfigMultiError(errors)
	}

	return nil
}

// TerraformRunnerConfigMultiError is an error wrapping multiple validation
// errors returned by TerraformRunnerConfig.ValidateAll() if the designated
// constraints aren't met.
type TerraformRunnerConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TerraformRunnerConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TerraformRunnerConfigMultiError) AllErrors() []error { return m }

// TerraformRunnerConfigValidationError is the validation error returned by
// TerraformRunnerConfig.Validate if the designated constraints aren't met.
type TerraformRunnerConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TerraformRunnerConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TerraformRunnerConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TerraformRunnerConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TerraformRunnerConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TerraformRunnerConfigValidationError) ErrorName() string {
	return "TerraformRunnerConfigValidationError"
}

// Error satisfies the builtin error interface
func (e TerraformRunnerConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTerraformRunnerConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TerraformRunnerConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TerraformRunnerConfigValidationError{}

// Validate checks the field values on PulumiRunnerConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PulumiRunnerConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PulumiRunnerConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PulumiRunnerConfigMultiError, or nil if none found.
func (m *PulumiRunnerConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *PulumiRunnerConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProxyRuntime() == nil {
		err := PulumiRunnerConfigValidationError{
			field:  "ProxyRuntime",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProxyRuntime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PulumiRunnerConfigValidationError{
					field:  "ProxyRuntime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PulumiRunnerConfigValidationError{
					field:  "ProxyRuntime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProxyRuntime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PulumiRunnerConfigValidationError{
				field:  "ProxyRuntime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetEnv()))
		i := 0
		for key := range m.GetEnv() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetEnv()[key]
			_ = val

			// no validation rules for Env[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, PulumiRunnerConfigValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, PulumiRunnerConfigValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return PulumiRunnerConfigValidationError{
						field:  fmt.Sprintf("Env[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetVolumes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PulumiRunnerConfigValidationError{
						field:  fmt.Sprintf("Volumes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PulumiRunnerConfigValidationError{
						field:  fmt.Sprintf("Volumes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PulumiRunnerConfigValidationError{
					field:  fmt.Sprintf("Volumes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPreRun() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PulumiRunnerConfigValidationError{
						field:  fmt.Sprintf("PreRun[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PulumiRunnerConfigValidationError{
						field:  fmt.Sprintf("PreRun[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PulumiRunnerConfigValidationError{
					field:  fmt.Sprintf("PreRun[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPollInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PulumiRunnerConfigValidationError{
					field:  "PollInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PulumiRunnerConfigValidationError{
					field:  "PollInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPollInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PulumiRunnerConfigValidationError{
				field:  "PollInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if d := m.GetConvergenceGracePeriod(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = PulumiRunnerConfigValidationError{
				field:  "ConvergenceGracePeriod",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			gt := time.Duration(0*time.Second + 0*time.Nanosecond)

			if dur <= gt {
				err := PulumiRunnerConfigValidationError{
					field:  "ConvergenceGracePeriod",
					reason: "value must be greater than 0s",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if all {
		switch v := interface{}(m.GetFetchRetryPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PulumiRunnerConfigValidationError{
					field:  "FetchRetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PulumiRunnerConfigValidationError{
					field:  "FetchRetryPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFetchRetryPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PulumiRunnerConfigValidationError{
				field:  "FetchRetryPolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PulumiRunnerConfigMultiError(errors)
	}

	return nil
}

// PulumiRunnerConfigMultiError is an error wrapping multiple validation errors
// returned by PulumiRunnerConfig.ValidateAll() if the designated constraints
// aren't met.
type PulumiRunnerConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PulumiRunnerConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PulumiRunnerConfigMultiError) AllErrors() []error { return m }

// PulumiRunnerConfigValidationError is the validation error returned by
// PulumiRunnerConfig.Validate if the designated constraints aren't met.
type PulumiRunnerConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PulumiRunnerConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PulumiRunnerConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PulumiRunnerConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PulumiRunnerConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PulumiRunnerConfigValidationError) ErrorName() string {
	return "PulumiRunnerConfigValidationError"
}

// Error satisfies the builtin error interface
func (e PulumiRunnerConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPulumiRunnerConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PulumiRunnerConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PulumiRunnerConfigValidationError{}

// Validate checks the field values on ClusterConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterConfigMultiError, or
// nil if none found.
func (m *ClusterConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetKubecost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "Kubecost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "Kubecost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKubecost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterConfigValidationError{
				field:  "Kubecost",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDatadog()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "Datadog",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "Datadog",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatadog()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterConfigValidationError{
				field:  "Datadog",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAlbIngress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "AlbIngress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "AlbIngress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAlbIngress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterConfigValidationError{
				field:  "AlbIngress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetArgoRollouts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "ArgoRollouts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "ArgoRollouts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetArgoRollouts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterConfigValidationError{
				field:  "ArgoRollouts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGkeIngress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "GkeIngress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "GkeIngress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGkeIngress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterConfigValidationError{
				field:  "GkeIngress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSelfManagedGkeIngress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "SelfManagedGkeIngress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterConfigValidationError{
					field:  "SelfManagedGkeIngress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSelfManagedGkeIngress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterConfigValidationError{
				field:  "SelfManagedGkeIngress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CloudProvider

	for idx, item := range m.GetLabels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterConfigValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterConfigValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterConfigValidationError{
					field:  fmt.Sprintf("Labels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.ClusterOneof.(type) {
	case *ClusterConfig_Fake:
		if v == nil {
			err := ClusterConfigValidationError{
				field:  "ClusterOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFake()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterConfigValidationError{
						field:  "Fake",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterConfigValidationError{
						field:  "Fake",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFake()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterConfigValidationError{
					field:  "Fake",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ClusterConfig_Extension:
		if v == nil {
			err := ClusterConfigValidationError{
				field:  "ClusterOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExtension()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterConfigValidationError{
						field:  "Extension",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterConfigValidationError{
						field:  "Extension",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExtension()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterConfigValidationError{
					field:  "Extension",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ClusterConfig_TerraformRunner:
		if v == nil {
			err := ClusterConfigValidationError{
				field:  "ClusterOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTerraformRunner()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterConfigValidationError{
						field:  "TerraformRunner",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterConfigValidationError{
						field:  "TerraformRunner",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTerraformRunner()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterConfigValidationError{
					field:  "TerraformRunner",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ClusterConfig_PulumiRunner:
		if v == nil {
			err := ClusterConfigValidationError{
				field:  "ClusterOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPulumiRunner()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterConfigValidationError{
						field:  "PulumiRunner",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterConfigValidationError{
						field:  "PulumiRunner",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPulumiRunner()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterConfigValidationError{
					field:  "PulumiRunner",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ClusterConfigMultiError(errors)
	}

	return nil
}

// ClusterConfigMultiError is an error wrapping multiple validation errors
// returned by ClusterConfig.ValidateAll() if the designated constraints
// aren't met.
type ClusterConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConfigMultiError) AllErrors() []error { return m }

// ClusterConfigValidationError is the validation error returned by
// ClusterConfig.Validate if the designated constraints aren't met.
type ClusterConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConfigValidationError) ErrorName() string { return "ClusterConfigValidationError" }

// Error satisfies the builtin error interface
func (e ClusterConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConfigValidationError{}

// Validate checks the field values on ClusterAuth_ECSAuth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterAuth_ECSAuth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterAuth_ECSAuth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterAuth_ECSAuthMultiError, or nil if none found.
func (m *ClusterAuth_ECSAuth) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterAuth_ECSAuth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessKey

	// no validation rules for SecretKey

	// no validation rules for Region

	// no validation rules for AssumeRoleArn

	// no validation rules for ClusterArn

	if len(errors) > 0 {
		return ClusterAuth_ECSAuthMultiError(errors)
	}

	return nil
}

// ClusterAuth_ECSAuthMultiError is an error wrapping multiple validation
// errors returned by ClusterAuth_ECSAuth.ValidateAll() if the designated
// constraints aren't met.
type ClusterAuth_ECSAuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterAuth_ECSAuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterAuth_ECSAuthMultiError) AllErrors() []error { return m }

// ClusterAuth_ECSAuthValidationError is the validation error returned by
// ClusterAuth_ECSAuth.Validate if the designated constraints aren't met.
type ClusterAuth_ECSAuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterAuth_ECSAuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterAuth_ECSAuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterAuth_ECSAuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterAuth_ECSAuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterAuth_ECSAuthValidationError) ErrorName() string {
	return "ClusterAuth_ECSAuthValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterAuth_ECSAuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterAuth_ECSAuth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterAuth_ECSAuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterAuth_ECSAuthValidationError{}

// Validate checks the field values on ClusterAuth_K8SAuth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterAuth_K8SAuth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterAuth_K8SAuth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterAuth_K8SAuthMultiError, or nil if none found.
func (m *ClusterAuth_K8SAuth) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterAuth_K8SAuth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AgentEnv

	// no validation rules for AgentExternallyManaged

	if len(errors) > 0 {
		return ClusterAuth_K8SAuthMultiError(errors)
	}

	return nil
}

// ClusterAuth_K8SAuthMultiError is an error wrapping multiple validation
// errors returned by ClusterAuth_K8SAuth.ValidateAll() if the designated
// constraints aren't met.
type ClusterAuth_K8SAuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterAuth_K8SAuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterAuth_K8SAuthMultiError) AllErrors() []error { return m }

// ClusterAuth_K8SAuthValidationError is the validation error returned by
// ClusterAuth_K8SAuth.Validate if the designated constraints aren't met.
type ClusterAuth_K8SAuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterAuth_K8SAuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterAuth_K8SAuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterAuth_K8SAuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterAuth_K8SAuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterAuth_K8SAuthValidationError) ErrorName() string {
	return "ClusterAuth_K8SAuthValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterAuth_K8SAuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterAuth_K8SAuth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterAuth_K8SAuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterAuth_K8SAuthValidationError{}

// Validate checks the field values on
// FakeClusterConfig_CrashingProgramPatterns with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FakeClusterConfig_CrashingProgramPatterns) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// FakeClusterConfig_CrashingProgramPatterns with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// FakeClusterConfig_CrashingProgramPatternsMultiError, or nil if none found.
func (m *FakeClusterConfig_CrashingProgramPatterns) ValidateAll() error {
	return m.validate(true)
}

func (m *FakeClusterConfig_CrashingProgramPatterns) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ImageRegex

	// no validation rules for CmdRegex

	// no validation rules for LogOutput

	if len(errors) > 0 {
		return FakeClusterConfig_CrashingProgramPatternsMultiError(errors)
	}

	return nil
}

// FakeClusterConfig_CrashingProgramPatternsMultiError is an error wrapping
// multiple validation errors returned by
// FakeClusterConfig_CrashingProgramPatterns.ValidateAll() if the designated
// constraints aren't met.
type FakeClusterConfig_CrashingProgramPatternsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FakeClusterConfig_CrashingProgramPatternsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FakeClusterConfig_CrashingProgramPatternsMultiError) AllErrors() []error { return m }

// FakeClusterConfig_CrashingProgramPatternsValidationError is the validation
// error returned by FakeClusterConfig_CrashingProgramPatterns.Validate if the
// designated constraints aren't met.
type FakeClusterConfig_CrashingProgramPatternsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FakeClusterConfig_CrashingProgramPatternsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FakeClusterConfig_CrashingProgramPatternsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FakeClusterConfig_CrashingProgramPatternsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FakeClusterConfig_CrashingProgramPatternsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FakeClusterConfig_CrashingProgramPatternsValidationError) ErrorName() string {
	return "FakeClusterConfig_CrashingProgramPatternsValidationError"
}

// Error satisfies the builtin error interface
func (e FakeClusterConfig_CrashingProgramPatternsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFakeClusterConfig_CrashingProgramPatterns.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FakeClusterConfig_CrashingProgramPatternsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FakeClusterConfig_CrashingProgramPatternsValidationError{}

// Validate checks the field values on
// CompiledExtensionCommand_CompiledExtensionCommandExec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompiledExtensionCommand_CompiledExtensionCommandExec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CompiledExtensionCommand_CompiledExtensionCommandExec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompiledExtensionCommand_CompiledExtensionCommandExecMultiError, or nil if
// none found.
func (m *CompiledExtensionCommand_CompiledExtensionCommandExec) ValidateAll() error {
	return m.validate(true)
}

func (m *CompiledExtensionCommand_CompiledExtensionCommandExec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofExecConfigPresent := false
	switch v := m.ExecConfig.(type) {
	case *CompiledExtensionCommand_CompiledExtensionCommandExec_TaskConfig:
		if v == nil {
			err := CompiledExtensionCommand_CompiledExtensionCommandExecValidationError{
				field:  "ExecConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofExecConfigPresent = true

		if all {
			switch v := interface{}(m.GetTaskConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompiledExtensionCommand_CompiledExtensionCommandExecValidationError{
						field:  "TaskConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompiledExtensionCommand_CompiledExtensionCommandExecValidationError{
						field:  "TaskConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTaskConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompiledExtensionCommand_CompiledExtensionCommandExecValidationError{
					field:  "TaskConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CompiledExtensionCommand_CompiledExtensionCommandExec_KubernetesConfig:
		if v == nil {
			err := CompiledExtensionCommand_CompiledExtensionCommandExecValidationError{
				field:  "ExecConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofExecConfigPresent = true

		if all {
			switch v := interface{}(m.GetKubernetesConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompiledExtensionCommand_CompiledExtensionCommandExecValidationError{
						field:  "KubernetesConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompiledExtensionCommand_CompiledExtensionCommandExecValidationError{
						field:  "KubernetesConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKubernetesConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompiledExtensionCommand_CompiledExtensionCommandExecValidationError{
					field:  "KubernetesConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofExecConfigPresent {
		err := CompiledExtensionCommand_CompiledExtensionCommandExecValidationError{
			field:  "ExecConfig",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CompiledExtensionCommand_CompiledExtensionCommandExecMultiError(errors)
	}

	return nil
}

// CompiledExtensionCommand_CompiledExtensionCommandExecMultiError is an error
// wrapping multiple validation errors returned by
// CompiledExtensionCommand_CompiledExtensionCommandExec.ValidateAll() if the
// designated constraints aren't met.
type CompiledExtensionCommand_CompiledExtensionCommandExecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompiledExtensionCommand_CompiledExtensionCommandExecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompiledExtensionCommand_CompiledExtensionCommandExecMultiError) AllErrors() []error {
	return m
}

// CompiledExtensionCommand_CompiledExtensionCommandExecValidationError is the
// validation error returned by
// CompiledExtensionCommand_CompiledExtensionCommandExec.Validate if the
// designated constraints aren't met.
type CompiledExtensionCommand_CompiledExtensionCommandExecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompiledExtensionCommand_CompiledExtensionCommandExecValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CompiledExtensionCommand_CompiledExtensionCommandExecValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CompiledExtensionCommand_CompiledExtensionCommandExecValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CompiledExtensionCommand_CompiledExtensionCommandExecValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e CompiledExtensionCommand_CompiledExtensionCommandExecValidationError) ErrorName() string {
	return "CompiledExtensionCommand_CompiledExtensionCommandExecValidationError"
}

// Error satisfies the builtin error interface
func (e CompiledExtensionCommand_CompiledExtensionCommandExecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompiledExtensionCommand_CompiledExtensionCommandExec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompiledExtensionCommand_CompiledExtensionCommandExecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompiledExtensionCommand_CompiledExtensionCommandExecValidationError{}

// Validate checks the field values on ClusterConfig_Kubecost with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterConfig_Kubecost) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterConfig_Kubecost with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterConfig_KubecostMultiError, or nil if none found.
func (m *ClusterConfig_Kubecost) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConfig_Kubecost) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	// no validation rules for Managed

	// no validation rules for KubecostNamespace

	if len(errors) > 0 {
		return ClusterConfig_KubecostMultiError(errors)
	}

	return nil
}

// ClusterConfig_KubecostMultiError is an error wrapping multiple validation
// errors returned by ClusterConfig_Kubecost.ValidateAll() if the designated
// constraints aren't met.
type ClusterConfig_KubecostMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConfig_KubecostMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConfig_KubecostMultiError) AllErrors() []error { return m }

// ClusterConfig_KubecostValidationError is the validation error returned by
// ClusterConfig_Kubecost.Validate if the designated constraints aren't met.
type ClusterConfig_KubecostValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConfig_KubecostValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConfig_KubecostValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConfig_KubecostValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConfig_KubecostValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConfig_KubecostValidationError) ErrorName() string {
	return "ClusterConfig_KubecostValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterConfig_KubecostValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConfig_Kubecost.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConfig_KubecostValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConfig_KubecostValidationError{}

// Validate checks the field values on ClusterConfig_Datadog with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterConfig_Datadog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterConfig_Datadog with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterConfig_DatadogMultiError, or nil if none found.
func (m *ClusterConfig_Datadog) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConfig_Datadog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	// no validation rules for Managed

	// no validation rules for DatadogNamespace

	// no validation rules for ApiKey

	// no validation rules for Site

	if len(errors) > 0 {
		return ClusterConfig_DatadogMultiError(errors)
	}

	return nil
}

// ClusterConfig_DatadogMultiError is an error wrapping multiple validation
// errors returned by ClusterConfig_Datadog.ValidateAll() if the designated
// constraints aren't met.
type ClusterConfig_DatadogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConfig_DatadogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConfig_DatadogMultiError) AllErrors() []error { return m }

// ClusterConfig_DatadogValidationError is the validation error returned by
// ClusterConfig_Datadog.Validate if the designated constraints aren't met.
type ClusterConfig_DatadogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConfig_DatadogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConfig_DatadogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConfig_DatadogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConfig_DatadogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConfig_DatadogValidationError) ErrorName() string {
	return "ClusterConfig_DatadogValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterConfig_DatadogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConfig_Datadog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConfig_DatadogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConfig_DatadogValidationError{}

// Validate checks the field values on ClusterConfig_ALBIngress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterConfig_ALBIngress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterConfig_ALBIngress with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterConfig_ALBIngressMultiError, or nil if none found.
func (m *ClusterConfig_ALBIngress) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConfig_ALBIngress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	if utf8.RuneCountInString(m.GetIngressClass()) < 1 {
		err := ClusterConfig_ALBIngressValidationError{
			field:  "IngressClass",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ClusterConfig_ALBIngressMultiError(errors)
	}

	return nil
}

// ClusterConfig_ALBIngressMultiError is an error wrapping multiple validation
// errors returned by ClusterConfig_ALBIngress.ValidateAll() if the designated
// constraints aren't met.
type ClusterConfig_ALBIngressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConfig_ALBIngressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConfig_ALBIngressMultiError) AllErrors() []error { return m }

// ClusterConfig_ALBIngressValidationError is the validation error returned by
// ClusterConfig_ALBIngress.Validate if the designated constraints aren't met.
type ClusterConfig_ALBIngressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConfig_ALBIngressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConfig_ALBIngressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConfig_ALBIngressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConfig_ALBIngressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConfig_ALBIngressValidationError) ErrorName() string {
	return "ClusterConfig_ALBIngressValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterConfig_ALBIngressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConfig_ALBIngress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConfig_ALBIngressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConfig_ALBIngressValidationError{}

// Validate checks the field values on ClusterConfig_ArgoRollouts with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterConfig_ArgoRollouts) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterConfig_ArgoRollouts with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterConfig_ArgoRolloutsMultiError, or nil if none found.
func (m *ClusterConfig_ArgoRollouts) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConfig_ArgoRollouts) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	for idx, item := range m.GetTemplates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterConfig_ArgoRolloutsValidationError{
						field:  fmt.Sprintf("Templates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterConfig_ArgoRolloutsValidationError{
						field:  fmt.Sprintf("Templates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterConfig_ArgoRolloutsValidationError{
					field:  fmt.Sprintf("Templates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ClusterConfig_ArgoRolloutsMultiError(errors)
	}

	return nil
}

// ClusterConfig_ArgoRolloutsMultiError is an error wrapping multiple
// validation errors returned by ClusterConfig_ArgoRollouts.ValidateAll() if
// the designated constraints aren't met.
type ClusterConfig_ArgoRolloutsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConfig_ArgoRolloutsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConfig_ArgoRolloutsMultiError) AllErrors() []error { return m }

// ClusterConfig_ArgoRolloutsValidationError is the validation error returned
// by ClusterConfig_ArgoRollouts.Validate if the designated constraints aren't met.
type ClusterConfig_ArgoRolloutsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConfig_ArgoRolloutsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConfig_ArgoRolloutsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConfig_ArgoRolloutsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConfig_ArgoRolloutsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConfig_ArgoRolloutsValidationError) ErrorName() string {
	return "ClusterConfig_ArgoRolloutsValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterConfig_ArgoRolloutsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConfig_ArgoRollouts.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConfig_ArgoRolloutsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConfig_ArgoRolloutsValidationError{}

// Validate checks the field values on ClusterConfig_GKEIngress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterConfig_GKEIngress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterConfig_GKEIngress with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterConfig_GKEIngressMultiError, or nil if none found.
func (m *ClusterConfig_GKEIngress) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConfig_GKEIngress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	// no validation rules for ContainerNative

	if len(errors) > 0 {
		return ClusterConfig_GKEIngressMultiError(errors)
	}

	return nil
}

// ClusterConfig_GKEIngressMultiError is an error wrapping multiple validation
// errors returned by ClusterConfig_GKEIngress.ValidateAll() if the designated
// constraints aren't met.
type ClusterConfig_GKEIngressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConfig_GKEIngressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConfig_GKEIngressMultiError) AllErrors() []error { return m }

// ClusterConfig_GKEIngressValidationError is the validation error returned by
// ClusterConfig_GKEIngress.Validate if the designated constraints aren't met.
type ClusterConfig_GKEIngressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConfig_GKEIngressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConfig_GKEIngressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConfig_GKEIngressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConfig_GKEIngressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConfig_GKEIngressValidationError) ErrorName() string {
	return "ClusterConfig_GKEIngressValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterConfig_GKEIngressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConfig_GKEIngress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConfig_GKEIngressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConfig_GKEIngressValidationError{}

// Validate checks the field values on
// ClusterConfig_ArgoRollouts_AnalysisTemplate with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterConfig_ArgoRollouts_AnalysisTemplate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ClusterConfig_ArgoRollouts_AnalysisTemplate with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ClusterConfig_ArgoRollouts_AnalysisTemplateMultiError, or nil if none found.
func (m *ClusterConfig_ArgoRollouts_AnalysisTemplate) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterConfig_ArgoRollouts_AnalysisTemplate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for ArgMapping

	if len(errors) > 0 {
		return ClusterConfig_ArgoRollouts_AnalysisTemplateMultiError(errors)
	}

	return nil
}

// ClusterConfig_ArgoRollouts_AnalysisTemplateMultiError is an error wrapping
// multiple validation errors returned by
// ClusterConfig_ArgoRollouts_AnalysisTemplate.ValidateAll() if the designated
// constraints aren't met.
type ClusterConfig_ArgoRollouts_AnalysisTemplateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterConfig_ArgoRollouts_AnalysisTemplateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterConfig_ArgoRollouts_AnalysisTemplateMultiError) AllErrors() []error { return m }

// ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError is the validation
// error returned by ClusterConfig_ArgoRollouts_AnalysisTemplate.Validate if
// the designated constraints aren't met.
type ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError) ErrorName() string {
	return "ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterConfig_ArgoRollouts_AnalysisTemplate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterConfig_ArgoRollouts_AnalysisTemplateValidationError{}
