// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.10
// source: prodvana/auth/auth_manager.proto

package auth

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	AuthManager_GetAuthToken_FullMethodName = "/prodvana.auth.AuthManager/GetAuthToken"
	AuthManager_GetAuthUrl_FullMethodName   = "/prodvana.auth.AuthManager/GetAuthUrl"
	AuthManager_RefreshToken_FullMethodName = "/prodvana.auth.AuthManager/RefreshToken"
	AuthManager_CliAuth_FullMethodName      = "/prodvana.auth.AuthManager/CliAuth"
)

// AuthManagerClient is the client API for AuthManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthManagerClient interface {
	// web auth flow
	// TODO(naphat) we should make this only available to our UI app
	GetAuthToken(ctx context.Context, in *GetTokenRequest, opts ...grpc.CallOption) (*GetAuthTokenResp, error)
	GetAuthUrl(ctx context.Context, in *GetAuthUrlRequest, opts ...grpc.CallOption) (*GetAuthUrlResponse, error)
	RefreshToken(ctx context.Context, in *RefreshTokenReq, opts ...grpc.CallOption) (*GetAuthTokenResp, error)
	// cli auth flow
	// This returns a streaming response with exactly two items:
	// 1. Immediately, a UserPrmopt will be returned which should then be conveyed to the user
	// 2. Once user authenticates via a browser, a Token will be returned
	CliAuth(ctx context.Context, in *CliAuthReq, opts ...grpc.CallOption) (AuthManager_CliAuthClient, error)
}

type authManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthManagerClient(cc grpc.ClientConnInterface) AuthManagerClient {
	return &authManagerClient{cc}
}

func (c *authManagerClient) GetAuthToken(ctx context.Context, in *GetTokenRequest, opts ...grpc.CallOption) (*GetAuthTokenResp, error) {
	out := new(GetAuthTokenResp)
	err := c.cc.Invoke(ctx, AuthManager_GetAuthToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerClient) GetAuthUrl(ctx context.Context, in *GetAuthUrlRequest, opts ...grpc.CallOption) (*GetAuthUrlResponse, error) {
	out := new(GetAuthUrlResponse)
	err := c.cc.Invoke(ctx, AuthManager_GetAuthUrl_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerClient) RefreshToken(ctx context.Context, in *RefreshTokenReq, opts ...grpc.CallOption) (*GetAuthTokenResp, error) {
	out := new(GetAuthTokenResp)
	err := c.cc.Invoke(ctx, AuthManager_RefreshToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerClient) CliAuth(ctx context.Context, in *CliAuthReq, opts ...grpc.CallOption) (AuthManager_CliAuthClient, error) {
	stream, err := c.cc.NewStream(ctx, &AuthManager_ServiceDesc.Streams[0], AuthManager_CliAuth_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &authManagerCliAuthClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuthManager_CliAuthClient interface {
	Recv() (*CliAuthResp, error)
	grpc.ClientStream
}

type authManagerCliAuthClient struct {
	grpc.ClientStream
}

func (x *authManagerCliAuthClient) Recv() (*CliAuthResp, error) {
	m := new(CliAuthResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AuthManagerServer is the server API for AuthManager service.
// All implementations must embed UnimplementedAuthManagerServer
// for forward compatibility
type AuthManagerServer interface {
	// web auth flow
	// TODO(naphat) we should make this only available to our UI app
	GetAuthToken(context.Context, *GetTokenRequest) (*GetAuthTokenResp, error)
	GetAuthUrl(context.Context, *GetAuthUrlRequest) (*GetAuthUrlResponse, error)
	RefreshToken(context.Context, *RefreshTokenReq) (*GetAuthTokenResp, error)
	// cli auth flow
	// This returns a streaming response with exactly two items:
	// 1. Immediately, a UserPrmopt will be returned which should then be conveyed to the user
	// 2. Once user authenticates via a browser, a Token will be returned
	CliAuth(*CliAuthReq, AuthManager_CliAuthServer) error
	mustEmbedUnimplementedAuthManagerServer()
}

// UnimplementedAuthManagerServer must be embedded to have forward compatible implementations.
type UnimplementedAuthManagerServer struct {
}

func (UnimplementedAuthManagerServer) GetAuthToken(context.Context, *GetTokenRequest) (*GetAuthTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthToken not implemented")
}
func (UnimplementedAuthManagerServer) GetAuthUrl(context.Context, *GetAuthUrlRequest) (*GetAuthUrlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthUrl not implemented")
}
func (UnimplementedAuthManagerServer) RefreshToken(context.Context, *RefreshTokenReq) (*GetAuthTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}
func (UnimplementedAuthManagerServer) CliAuth(*CliAuthReq, AuthManager_CliAuthServer) error {
	return status.Errorf(codes.Unimplemented, "method CliAuth not implemented")
}
func (UnimplementedAuthManagerServer) mustEmbedUnimplementedAuthManagerServer() {}

// UnsafeAuthManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthManagerServer will
// result in compilation errors.
type UnsafeAuthManagerServer interface {
	mustEmbedUnimplementedAuthManagerServer()
}

func RegisterAuthManagerServer(s grpc.ServiceRegistrar, srv AuthManagerServer) {
	s.RegisterService(&AuthManager_ServiceDesc, srv)
}

func _AuthManager_GetAuthToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServer).GetAuthToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthManager_GetAuthToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServer).GetAuthToken(ctx, req.(*GetTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManager_GetAuthUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAuthUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServer).GetAuthUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthManager_GetAuthUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServer).GetAuthUrl(ctx, req.(*GetAuthUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManager_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthManager_RefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServer).RefreshToken(ctx, req.(*RefreshTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManager_CliAuth_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CliAuthReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuthManagerServer).CliAuth(m, &authManagerCliAuthServer{stream})
}

type AuthManager_CliAuthServer interface {
	Send(*CliAuthResp) error
	grpc.ServerStream
}

type authManagerCliAuthServer struct {
	grpc.ServerStream
}

func (x *authManagerCliAuthServer) Send(m *CliAuthResp) error {
	return x.ServerStream.SendMsg(m)
}

// AuthManager_ServiceDesc is the grpc.ServiceDesc for AuthManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "prodvana.auth.AuthManager",
	HandlerType: (*AuthManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAuthToken",
			Handler:    _AuthManager_GetAuthToken_Handler,
		},
		{
			MethodName: "GetAuthUrl",
			Handler:    _AuthManager_GetAuthUrl_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _AuthManager_RefreshToken_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CliAuth",
			Handler:       _AuthManager_CliAuth_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "prodvana/auth/auth_manager.proto",
}

const (
	AuthSessionManager_Check_FullMethodName = "/prodvana.auth.AuthSessionManager/Check"
)

// AuthSessionManagerClient is the client API for AuthSessionManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthSessionManagerClient interface {
	// check if user is authenticated and token is still valid
	Check(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type authSessionManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthSessionManagerClient(cc grpc.ClientConnInterface) AuthSessionManagerClient {
	return &authSessionManagerClient{cc}
}

func (c *authSessionManagerClient) Check(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, AuthSessionManager_Check_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthSessionManagerServer is the server API for AuthSessionManager service.
// All implementations must embed UnimplementedAuthSessionManagerServer
// for forward compatibility
type AuthSessionManagerServer interface {
	// check if user is authenticated and token is still valid
	Check(context.Context, *Empty) (*Empty, error)
	mustEmbedUnimplementedAuthSessionManagerServer()
}

// UnimplementedAuthSessionManagerServer must be embedded to have forward compatible implementations.
type UnimplementedAuthSessionManagerServer struct {
}

func (UnimplementedAuthSessionManagerServer) Check(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Check not implemented")
}
func (UnimplementedAuthSessionManagerServer) mustEmbedUnimplementedAuthSessionManagerServer() {}

// UnsafeAuthSessionManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthSessionManagerServer will
// result in compilation errors.
type UnsafeAuthSessionManagerServer interface {
	mustEmbedUnimplementedAuthSessionManagerServer()
}

func RegisterAuthSessionManagerServer(s grpc.ServiceRegistrar, srv AuthSessionManagerServer) {
	s.RegisterService(&AuthSessionManager_ServiceDesc, srv)
}

func _AuthSessionManager_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthSessionManagerServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthSessionManager_Check_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthSessionManagerServer).Check(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthSessionManager_ServiceDesc is the grpc.ServiceDesc for AuthSessionManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthSessionManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "prodvana.auth.AuthSessionManager",
	HandlerType: (*AuthSessionManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Check",
			Handler:    _AuthSessionManager_Check_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "prodvana/auth/auth_manager.proto",
}

const (
	ApiTokenManager_CreateOrgApiToken_FullMethodName  = "/prodvana.auth.ApiTokenManager/CreateOrgApiToken"
	ApiTokenManager_CreateOrgApiToken2_FullMethodName = "/prodvana.auth.ApiTokenManager/CreateOrgApiToken2"
	ApiTokenManager_DeleteOrgApiToken_FullMethodName  = "/prodvana.auth.ApiTokenManager/DeleteOrgApiToken"
	ApiTokenManager_ListOrgApiTokens_FullMethodName   = "/prodvana.auth.ApiTokenManager/ListOrgApiTokens"
)

// ApiTokenManagerClient is the client API for ApiTokenManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ApiTokenManagerClient interface {
	// Create an api token tied to the organization. This api token is not tied to the user in anyway,
	// e.g. if the user is deleted, the token will continue to have access to the organization.
	// This token currently does not expire, so be very careful with storing them.
	CreateOrgApiToken(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CreateOrgApiTokenResp, error)
	CreateOrgApiToken2(ctx context.Context, in *CreateOrgApiTokenReq, opts ...grpc.CallOption) (*CreateOrgApiTokenResp, error)
	DeleteOrgApiToken(ctx context.Context, in *DeleteOrgApiTokenReq, opts ...grpc.CallOption) (*DeleteOrgApiTokenResp, error)
	ListOrgApiTokens(ctx context.Context, in *ListOrgApiTokensReq, opts ...grpc.CallOption) (*ListOrgApiTokensResp, error)
}

type apiTokenManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewApiTokenManagerClient(cc grpc.ClientConnInterface) ApiTokenManagerClient {
	return &apiTokenManagerClient{cc}
}

func (c *apiTokenManagerClient) CreateOrgApiToken(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CreateOrgApiTokenResp, error) {
	out := new(CreateOrgApiTokenResp)
	err := c.cc.Invoke(ctx, ApiTokenManager_CreateOrgApiToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiTokenManagerClient) CreateOrgApiToken2(ctx context.Context, in *CreateOrgApiTokenReq, opts ...grpc.CallOption) (*CreateOrgApiTokenResp, error) {
	out := new(CreateOrgApiTokenResp)
	err := c.cc.Invoke(ctx, ApiTokenManager_CreateOrgApiToken2_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiTokenManagerClient) DeleteOrgApiToken(ctx context.Context, in *DeleteOrgApiTokenReq, opts ...grpc.CallOption) (*DeleteOrgApiTokenResp, error) {
	out := new(DeleteOrgApiTokenResp)
	err := c.cc.Invoke(ctx, ApiTokenManager_DeleteOrgApiToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiTokenManagerClient) ListOrgApiTokens(ctx context.Context, in *ListOrgApiTokensReq, opts ...grpc.CallOption) (*ListOrgApiTokensResp, error) {
	out := new(ListOrgApiTokensResp)
	err := c.cc.Invoke(ctx, ApiTokenManager_ListOrgApiTokens_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiTokenManagerServer is the server API for ApiTokenManager service.
// All implementations must embed UnimplementedApiTokenManagerServer
// for forward compatibility
type ApiTokenManagerServer interface {
	// Create an api token tied to the organization. This api token is not tied to the user in anyway,
	// e.g. if the user is deleted, the token will continue to have access to the organization.
	// This token currently does not expire, so be very careful with storing them.
	CreateOrgApiToken(context.Context, *Empty) (*CreateOrgApiTokenResp, error)
	CreateOrgApiToken2(context.Context, *CreateOrgApiTokenReq) (*CreateOrgApiTokenResp, error)
	DeleteOrgApiToken(context.Context, *DeleteOrgApiTokenReq) (*DeleteOrgApiTokenResp, error)
	ListOrgApiTokens(context.Context, *ListOrgApiTokensReq) (*ListOrgApiTokensResp, error)
	mustEmbedUnimplementedApiTokenManagerServer()
}

// UnimplementedApiTokenManagerServer must be embedded to have forward compatible implementations.
type UnimplementedApiTokenManagerServer struct {
}

func (UnimplementedApiTokenManagerServer) CreateOrgApiToken(context.Context, *Empty) (*CreateOrgApiTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrgApiToken not implemented")
}
func (UnimplementedApiTokenManagerServer) CreateOrgApiToken2(context.Context, *CreateOrgApiTokenReq) (*CreateOrgApiTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrgApiToken2 not implemented")
}
func (UnimplementedApiTokenManagerServer) DeleteOrgApiToken(context.Context, *DeleteOrgApiTokenReq) (*DeleteOrgApiTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOrgApiToken not implemented")
}
func (UnimplementedApiTokenManagerServer) ListOrgApiTokens(context.Context, *ListOrgApiTokensReq) (*ListOrgApiTokensResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOrgApiTokens not implemented")
}
func (UnimplementedApiTokenManagerServer) mustEmbedUnimplementedApiTokenManagerServer() {}

// UnsafeApiTokenManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ApiTokenManagerServer will
// result in compilation errors.
type UnsafeApiTokenManagerServer interface {
	mustEmbedUnimplementedApiTokenManagerServer()
}

func RegisterApiTokenManagerServer(s grpc.ServiceRegistrar, srv ApiTokenManagerServer) {
	s.RegisterService(&ApiTokenManager_ServiceDesc, srv)
}

func _ApiTokenManager_CreateOrgApiToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiTokenManagerServer).CreateOrgApiToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiTokenManager_CreateOrgApiToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiTokenManagerServer).CreateOrgApiToken(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiTokenManager_CreateOrgApiToken2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOrgApiTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiTokenManagerServer).CreateOrgApiToken2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiTokenManager_CreateOrgApiToken2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiTokenManagerServer).CreateOrgApiToken2(ctx, req.(*CreateOrgApiTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiTokenManager_DeleteOrgApiToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteOrgApiTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiTokenManagerServer).DeleteOrgApiToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiTokenManager_DeleteOrgApiToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiTokenManagerServer).DeleteOrgApiToken(ctx, req.(*DeleteOrgApiTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiTokenManager_ListOrgApiTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrgApiTokensReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiTokenManagerServer).ListOrgApiTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiTokenManager_ListOrgApiTokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiTokenManagerServer).ListOrgApiTokens(ctx, req.(*ListOrgApiTokensReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ApiTokenManager_ServiceDesc is the grpc.ServiceDesc for ApiTokenManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ApiTokenManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "prodvana.auth.ApiTokenManager",
	HandlerType: (*ApiTokenManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateOrgApiToken",
			Handler:    _ApiTokenManager_CreateOrgApiToken_Handler,
		},
		{
			MethodName: "CreateOrgApiToken2",
			Handler:    _ApiTokenManager_CreateOrgApiToken2_Handler,
		},
		{
			MethodName: "DeleteOrgApiToken",
			Handler:    _ApiTokenManager_DeleteOrgApiToken_Handler,
		},
		{
			MethodName: "ListOrgApiTokens",
			Handler:    _ApiTokenManager_ListOrgApiTokens_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "prodvana/auth/auth_manager.proto",
}
