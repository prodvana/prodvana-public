// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: prodvana/deployment/manager.proto

package deployment

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on RecordDeploymentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RecordDeploymentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecordDeploymentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RecordDeploymentReqMultiError, or nil if none found.
func (m *RecordDeploymentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RecordDeploymentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetConfig() == nil {
		err := RecordDeploymentReqValidationError{
			field:  "Config",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RecordDeploymentReqValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RecordDeploymentReqValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RecordDeploymentReqValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Pending

	if len(errors) > 0 {
		return RecordDeploymentReqMultiError(errors)
	}

	return nil
}

// RecordDeploymentReqMultiError is an error wrapping multiple validation
// errors returned by RecordDeploymentReq.ValidateAll() if the designated
// constraints aren't met.
type RecordDeploymentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecordDeploymentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecordDeploymentReqMultiError) AllErrors() []error { return m }

// RecordDeploymentReqValidationError is the validation error returned by
// RecordDeploymentReq.Validate if the designated constraints aren't met.
type RecordDeploymentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecordDeploymentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecordDeploymentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecordDeploymentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecordDeploymentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecordDeploymentReqValidationError) ErrorName() string {
	return "RecordDeploymentReqValidationError"
}

// Error satisfies the builtin error interface
func (e RecordDeploymentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecordDeploymentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecordDeploymentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecordDeploymentReqValidationError{}

// Validate checks the field values on RecordDeploymentResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RecordDeploymentResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecordDeploymentResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RecordDeploymentRespMultiError, or nil if none found.
func (m *RecordDeploymentResp) ValidateAll() error {
	return m.validate(true)
}

func (m *RecordDeploymentResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RecordDeploymentRespValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RecordDeploymentRespValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RecordDeploymentRespValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RecordDeploymentRespMultiError(errors)
	}

	return nil
}

// RecordDeploymentRespMultiError is an error wrapping multiple validation
// errors returned by RecordDeploymentResp.ValidateAll() if the designated
// constraints aren't met.
type RecordDeploymentRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecordDeploymentRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecordDeploymentRespMultiError) AllErrors() []error { return m }

// RecordDeploymentRespValidationError is the validation error returned by
// RecordDeploymentResp.Validate if the designated constraints aren't met.
type RecordDeploymentRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecordDeploymentRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecordDeploymentRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecordDeploymentRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecordDeploymentRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecordDeploymentRespValidationError) ErrorName() string {
	return "RecordDeploymentRespValidationError"
}

// Error satisfies the builtin error interface
func (e RecordDeploymentRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecordDeploymentResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecordDeploymentRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecordDeploymentRespValidationError{}

// Validate checks the field values on UpdateDeploymentStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDeploymentStatusReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDeploymentStatusReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDeploymentStatusReqMultiError, or nil if none found.
func (m *UpdateDeploymentStatusReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDeploymentStatusReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeploymentId

	// no validation rules for Status

	if len(errors) > 0 {
		return UpdateDeploymentStatusReqMultiError(errors)
	}

	return nil
}

// UpdateDeploymentStatusReqMultiError is an error wrapping multiple validation
// errors returned by UpdateDeploymentStatusReq.ValidateAll() if the
// designated constraints aren't met.
type UpdateDeploymentStatusReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeploymentStatusReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeploymentStatusReqMultiError) AllErrors() []error { return m }

// UpdateDeploymentStatusReqValidationError is the validation error returned by
// UpdateDeploymentStatusReq.Validate if the designated constraints aren't met.
type UpdateDeploymentStatusReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeploymentStatusReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeploymentStatusReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeploymentStatusReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeploymentStatusReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeploymentStatusReqValidationError) ErrorName() string {
	return "UpdateDeploymentStatusReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDeploymentStatusReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeploymentStatusReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeploymentStatusReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeploymentStatusReqValidationError{}

// Validate checks the field values on UpdateDeploymentStatusResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDeploymentStatusResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDeploymentStatusResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDeploymentStatusRespMultiError, or nil if none found.
func (m *UpdateDeploymentStatusResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDeploymentStatusResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if len(errors) > 0 {
		return UpdateDeploymentStatusRespMultiError(errors)
	}

	return nil
}

// UpdateDeploymentStatusRespMultiError is an error wrapping multiple
// validation errors returned by UpdateDeploymentStatusResp.ValidateAll() if
// the designated constraints aren't met.
type UpdateDeploymentStatusRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeploymentStatusRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeploymentStatusRespMultiError) AllErrors() []error { return m }

// UpdateDeploymentStatusRespValidationError is the validation error returned
// by UpdateDeploymentStatusResp.Validate if the designated constraints aren't met.
type UpdateDeploymentStatusRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeploymentStatusRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeploymentStatusRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeploymentStatusRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeploymentStatusRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeploymentStatusRespValidationError) ErrorName() string {
	return "UpdateDeploymentStatusRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDeploymentStatusRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeploymentStatusResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeploymentStatusRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeploymentStatusRespValidationError{}

// Validate checks the field values on DeploymentFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeploymentFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeploymentFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeploymentFilterMultiError, or nil if none found.
func (m *DeploymentFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *DeploymentFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Application

	// no validation rules for DesiredStateId

	// no validation rules for ReleaseId

	if len(errors) > 0 {
		return DeploymentFilterMultiError(errors)
	}

	return nil
}

// DeploymentFilterMultiError is an error wrapping multiple validation errors
// returned by DeploymentFilter.ValidateAll() if the designated constraints
// aren't met.
type DeploymentFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeploymentFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeploymentFilterMultiError) AllErrors() []error { return m }

// DeploymentFilterValidationError is the validation error returned by
// DeploymentFilter.Validate if the designated constraints aren't met.
type DeploymentFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeploymentFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeploymentFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeploymentFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeploymentFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeploymentFilterValidationError) ErrorName() string { return "DeploymentFilterValidationError" }

// Error satisfies the builtin error interface
func (e DeploymentFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeploymentFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeploymentFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeploymentFilterValidationError{}

// Validate checks the field values on ListDeploymentsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDeploymentsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDeploymentsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDeploymentsReqMultiError, or nil if none found.
func (m *ListDeploymentsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDeploymentsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFilters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDeploymentsReqValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDeploymentsReqValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDeploymentsReqValidationError{
					field:  fmt.Sprintf("Filters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListDeploymentsReqValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListDeploymentsReqValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListDeploymentsReqValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for StartingDeploymentId

	// no validation rules for EndingDeploymentId

	// no validation rules for PageToken

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListDeploymentsReqMultiError(errors)
	}

	return nil
}

// ListDeploymentsReqMultiError is an error wrapping multiple validation errors
// returned by ListDeploymentsReq.ValidateAll() if the designated constraints
// aren't met.
type ListDeploymentsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDeploymentsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDeploymentsReqMultiError) AllErrors() []error { return m }

// ListDeploymentsReqValidationError is the validation error returned by
// ListDeploymentsReq.Validate if the designated constraints aren't met.
type ListDeploymentsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDeploymentsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDeploymentsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDeploymentsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDeploymentsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDeploymentsReqValidationError) ErrorName() string {
	return "ListDeploymentsReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListDeploymentsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDeploymentsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDeploymentsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDeploymentsReqValidationError{}

// Validate checks the field values on ListDeploymentsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDeploymentsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDeploymentsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDeploymentsRespMultiError, or nil if none found.
func (m *ListDeploymentsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDeploymentsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDeployments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDeploymentsRespValidationError{
						field:  fmt.Sprintf("Deployments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDeploymentsRespValidationError{
						field:  fmt.Sprintf("Deployments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDeploymentsRespValidationError{
					field:  fmt.Sprintf("Deployments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListDeploymentsRespMultiError(errors)
	}

	return nil
}

// ListDeploymentsRespMultiError is an error wrapping multiple validation
// errors returned by ListDeploymentsResp.ValidateAll() if the designated
// constraints aren't met.
type ListDeploymentsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDeploymentsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDeploymentsRespMultiError) AllErrors() []error { return m }

// ListDeploymentsRespValidationError is the validation error returned by
// ListDeploymentsResp.Validate if the designated constraints aren't met.
type ListDeploymentsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDeploymentsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDeploymentsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDeploymentsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDeploymentsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDeploymentsRespValidationError) ErrorName() string {
	return "ListDeploymentsRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListDeploymentsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDeploymentsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDeploymentsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDeploymentsRespValidationError{}

// Validate checks the field values on DeploymentRef with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeploymentRef) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeploymentRef with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeploymentRefMultiError, or
// nil if none found.
func (m *DeploymentRef) ValidateAll() error {
	return m.validate(true)
}

func (m *DeploymentRef) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofRefPresent := false
	switch v := m.Ref.(type) {
	case *DeploymentRef_DeploymentId:
		if v == nil {
			err := DeploymentRefValidationError{
				field:  "Ref",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRefPresent = true
		// no validation rules for DeploymentId
	case *DeploymentRef_Config:
		if v == nil {
			err := DeploymentRefValidationError{
				field:  "Ref",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRefPresent = true

		if all {
			switch v := interface{}(m.GetConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeploymentRefValidationError{
						field:  "Config",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeploymentRefValidationError{
						field:  "Config",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeploymentRefValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofRefPresent {
		err := DeploymentRefValidationError{
			field:  "Ref",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeploymentRefMultiError(errors)
	}

	return nil
}

// DeploymentRefMultiError is an error wrapping multiple validation errors
// returned by DeploymentRef.ValidateAll() if the designated constraints
// aren't met.
type DeploymentRefMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeploymentRefMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeploymentRefMultiError) AllErrors() []error { return m }

// DeploymentRefValidationError is the validation error returned by
// DeploymentRef.Validate if the designated constraints aren't met.
type DeploymentRefValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeploymentRefValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeploymentRefValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeploymentRefValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeploymentRefValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeploymentRefValidationError) ErrorName() string { return "DeploymentRefValidationError" }

// Error satisfies the builtin error interface
func (e DeploymentRefValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeploymentRef.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeploymentRefValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeploymentRefValidationError{}

// Validate checks the field values on CompareDeploymentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompareDeploymentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompareDeploymentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompareDeploymentReqMultiError, or nil if none found.
func (m *CompareDeploymentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CompareDeploymentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetNewDeployment() == nil {
		err := CompareDeploymentReqValidationError{
			field:  "NewDeployment",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNewDeployment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompareDeploymentReqValidationError{
					field:  "NewDeployment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompareDeploymentReqValidationError{
					field:  "NewDeployment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNewDeployment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompareDeploymentReqValidationError{
				field:  "NewDeployment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrevDeployment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompareDeploymentReqValidationError{
					field:  "PrevDeployment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompareDeploymentReqValidationError{
					field:  "PrevDeployment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrevDeployment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompareDeploymentReqValidationError{
				field:  "PrevDeployment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CompareDeploymentReqMultiError(errors)
	}

	return nil
}

// CompareDeploymentReqMultiError is an error wrapping multiple validation
// errors returned by CompareDeploymentReq.ValidateAll() if the designated
// constraints aren't met.
type CompareDeploymentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompareDeploymentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompareDeploymentReqMultiError) AllErrors() []error { return m }

// CompareDeploymentReqValidationError is the validation error returned by
// CompareDeploymentReq.Validate if the designated constraints aren't met.
type CompareDeploymentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompareDeploymentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompareDeploymentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompareDeploymentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompareDeploymentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompareDeploymentReqValidationError) ErrorName() string {
	return "CompareDeploymentReqValidationError"
}

// Error satisfies the builtin error interface
func (e CompareDeploymentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompareDeploymentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompareDeploymentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompareDeploymentReqValidationError{}

// Validate checks the field values on CompareDeploymentResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompareDeploymentResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompareDeploymentResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompareDeploymentRespMultiError, or nil if none found.
func (m *CompareDeploymentResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CompareDeploymentResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetComparison()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompareDeploymentRespValidationError{
					field:  "Comparison",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompareDeploymentRespValidationError{
					field:  "Comparison",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetComparison()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompareDeploymentRespValidationError{
				field:  "Comparison",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CompareDeploymentRespMultiError(errors)
	}

	return nil
}

// CompareDeploymentRespMultiError is an error wrapping multiple validation
// errors returned by CompareDeploymentResp.ValidateAll() if the designated
// constraints aren't met.
type CompareDeploymentRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompareDeploymentRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompareDeploymentRespMultiError) AllErrors() []error { return m }

// CompareDeploymentRespValidationError is the validation error returned by
// CompareDeploymentResp.Validate if the designated constraints aren't met.
type CompareDeploymentRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompareDeploymentRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompareDeploymentRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompareDeploymentRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompareDeploymentRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompareDeploymentRespValidationError) ErrorName() string {
	return "CompareDeploymentRespValidationError"
}

// Error satisfies the builtin error interface
func (e CompareDeploymentRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompareDeploymentResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompareDeploymentRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompareDeploymentRespValidationError{}

// Validate checks the field values on PreviewDeploymentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PreviewDeploymentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PreviewDeploymentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PreviewDeploymentReqMultiError, or nil if none found.
func (m *PreviewDeploymentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PreviewDeploymentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetConfig() == nil {
		err := PreviewDeploymentReqValidationError{
			field:  "Config",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PreviewDeploymentReqValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PreviewDeploymentReqValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PreviewDeploymentReqValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrevDeployment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PreviewDeploymentReqValidationError{
					field:  "PrevDeployment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PreviewDeploymentReqValidationError{
					field:  "PrevDeployment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrevDeployment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PreviewDeploymentReqValidationError{
				field:  "PrevDeployment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PreviewDeploymentReqMultiError(errors)
	}

	return nil
}

// PreviewDeploymentReqMultiError is an error wrapping multiple validation
// errors returned by PreviewDeploymentReq.ValidateAll() if the designated
// constraints aren't met.
type PreviewDeploymentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PreviewDeploymentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PreviewDeploymentReqMultiError) AllErrors() []error { return m }

// PreviewDeploymentReqValidationError is the validation error returned by
// PreviewDeploymentReq.Validate if the designated constraints aren't met.
type PreviewDeploymentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PreviewDeploymentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PreviewDeploymentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PreviewDeploymentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PreviewDeploymentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PreviewDeploymentReqValidationError) ErrorName() string {
	return "PreviewDeploymentReqValidationError"
}

// Error satisfies the builtin error interface
func (e PreviewDeploymentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPreviewDeploymentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PreviewDeploymentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PreviewDeploymentReqValidationError{}

// Validate checks the field values on PreviewDeploymentResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PreviewDeploymentResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PreviewDeploymentResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PreviewDeploymentRespMultiError, or nil if none found.
func (m *PreviewDeploymentResp) ValidateAll() error {
	return m.validate(true)
}

func (m *PreviewDeploymentResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDeployment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PreviewDeploymentRespValidationError{
					field:  "Deployment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PreviewDeploymentRespValidationError{
					field:  "Deployment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeployment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PreviewDeploymentRespValidationError{
				field:  "Deployment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PreviewDeploymentRespMultiError(errors)
	}

	return nil
}

// PreviewDeploymentRespMultiError is an error wrapping multiple validation
// errors returned by PreviewDeploymentResp.ValidateAll() if the designated
// constraints aren't met.
type PreviewDeploymentRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PreviewDeploymentRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PreviewDeploymentRespMultiError) AllErrors() []error { return m }

// PreviewDeploymentRespValidationError is the validation error returned by
// PreviewDeploymentResp.Validate if the designated constraints aren't met.
type PreviewDeploymentRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PreviewDeploymentRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PreviewDeploymentRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PreviewDeploymentRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PreviewDeploymentRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PreviewDeploymentRespValidationError) ErrorName() string {
	return "PreviewDeploymentRespValidationError"
}

// Error satisfies the builtin error interface
func (e PreviewDeploymentRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPreviewDeploymentResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PreviewDeploymentRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PreviewDeploymentRespValidationError{}

// Validate checks the field values on GetLatestDeploymentsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLatestDeploymentsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLatestDeploymentsReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLatestDeploymentsReqMultiError, or nil if none found.
func (m *GetLatestDeploymentsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLatestDeploymentsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFilters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetLatestDeploymentsReqValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetLatestDeploymentsReqValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetLatestDeploymentsReqValidationError{
					field:  fmt.Sprintf("Filters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLatestDeploymentsReqValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLatestDeploymentsReqValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLatestDeploymentsReqValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	// no validation rules for PageToken

	// no validation rules for PageSize

	if len(errors) > 0 {
		return GetLatestDeploymentsReqMultiError(errors)
	}

	return nil
}

// GetLatestDeploymentsReqMultiError is an error wrapping multiple validation
// errors returned by GetLatestDeploymentsReq.ValidateAll() if the designated
// constraints aren't met.
type GetLatestDeploymentsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLatestDeploymentsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLatestDeploymentsReqMultiError) AllErrors() []error { return m }

// GetLatestDeploymentsReqValidationError is the validation error returned by
// GetLatestDeploymentsReq.Validate if the designated constraints aren't met.
type GetLatestDeploymentsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLatestDeploymentsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLatestDeploymentsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLatestDeploymentsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLatestDeploymentsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLatestDeploymentsReqValidationError) ErrorName() string {
	return "GetLatestDeploymentsReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetLatestDeploymentsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLatestDeploymentsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLatestDeploymentsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLatestDeploymentsReqValidationError{}

// Validate checks the field values on GetLatestDeploymentsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLatestDeploymentsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLatestDeploymentsResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLatestDeploymentsRespMultiError, or nil if none found.
func (m *GetLatestDeploymentsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLatestDeploymentsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDeployments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetLatestDeploymentsRespValidationError{
						field:  fmt.Sprintf("Deployments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetLatestDeploymentsRespValidationError{
						field:  fmt.Sprintf("Deployments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetLatestDeploymentsRespValidationError{
					field:  fmt.Sprintf("Deployments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return GetLatestDeploymentsRespMultiError(errors)
	}

	return nil
}

// GetLatestDeploymentsRespMultiError is an error wrapping multiple validation
// errors returned by GetLatestDeploymentsResp.ValidateAll() if the designated
// constraints aren't met.
type GetLatestDeploymentsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLatestDeploymentsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLatestDeploymentsRespMultiError) AllErrors() []error { return m }

// GetLatestDeploymentsRespValidationError is the validation error returned by
// GetLatestDeploymentsResp.Validate if the designated constraints aren't met.
type GetLatestDeploymentsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLatestDeploymentsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLatestDeploymentsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLatestDeploymentsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLatestDeploymentsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLatestDeploymentsRespValidationError) ErrorName() string {
	return "GetLatestDeploymentsRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetLatestDeploymentsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLatestDeploymentsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLatestDeploymentsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLatestDeploymentsRespValidationError{}

// Validate checks the field values on DeploymentServiceInstance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeploymentServiceInstance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeploymentServiceInstance with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeploymentServiceInstanceMultiError, or nil if none found.
func (m *DeploymentServiceInstance) ValidateAll() error {
	return m.validate(true)
}

func (m *DeploymentServiceInstance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := DeploymentServiceInstanceValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := DeploymentServiceInstanceValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetReleaseChannel()) < 1 {
		err := DeploymentServiceInstanceValidationError{
			field:  "ReleaseChannel",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeploymentServiceInstanceMultiError(errors)
	}

	return nil
}

// DeploymentServiceInstanceMultiError is an error wrapping multiple validation
// errors returned by DeploymentServiceInstance.ValidateAll() if the
// designated constraints aren't met.
type DeploymentServiceInstanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeploymentServiceInstanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeploymentServiceInstanceMultiError) AllErrors() []error { return m }

// DeploymentServiceInstanceValidationError is the validation error returned by
// DeploymentServiceInstance.Validate if the designated constraints aren't met.
type DeploymentServiceInstanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeploymentServiceInstanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeploymentServiceInstanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeploymentServiceInstanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeploymentServiceInstanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeploymentServiceInstanceValidationError) ErrorName() string {
	return "DeploymentServiceInstanceValidationError"
}

// Error satisfies the builtin error interface
func (e DeploymentServiceInstanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeploymentServiceInstance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeploymentServiceInstanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeploymentServiceInstanceValidationError{}

// Validate checks the field values on CheckCommitInDeploymentReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckCommitInDeploymentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckCommitInDeploymentReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckCommitInDeploymentReqMultiError, or nil if none found.
func (m *CheckCommitInDeploymentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckCommitInDeploymentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetRepository()) < 1 {
		err := CheckCommitInDeploymentReqValidationError{
			field:  "Repository",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCommit()) < 1 {
		err := CheckCommitInDeploymentReqValidationError{
			field:  "Commit",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	oneofDeploymentOneofPresent := false
	switch v := m.DeploymentOneof.(type) {
	case *CheckCommitInDeploymentReq_DeploymentId:
		if v == nil {
			err := CheckCommitInDeploymentReqValidationError{
				field:  "DeploymentOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofDeploymentOneofPresent = true

		if utf8.RuneCountInString(m.GetDeploymentId()) < 1 {
			err := CheckCommitInDeploymentReqValidationError{
				field:  "DeploymentId",
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *CheckCommitInDeploymentReq_DeploymentServiceInstance:
		if v == nil {
			err := CheckCommitInDeploymentReqValidationError{
				field:  "DeploymentOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofDeploymentOneofPresent = true

		if m.GetDeploymentServiceInstance() == nil {
			err := CheckCommitInDeploymentReqValidationError{
				field:  "DeploymentServiceInstance",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeploymentServiceInstance()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CheckCommitInDeploymentReqValidationError{
						field:  "DeploymentServiceInstance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CheckCommitInDeploymentReqValidationError{
						field:  "DeploymentServiceInstance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeploymentServiceInstance()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CheckCommitInDeploymentReqValidationError{
					field:  "DeploymentServiceInstance",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofDeploymentOneofPresent {
		err := CheckCommitInDeploymentReqValidationError{
			field:  "DeploymentOneof",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CheckCommitInDeploymentReqMultiError(errors)
	}

	return nil
}

// CheckCommitInDeploymentReqMultiError is an error wrapping multiple
// validation errors returned by CheckCommitInDeploymentReq.ValidateAll() if
// the designated constraints aren't met.
type CheckCommitInDeploymentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckCommitInDeploymentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckCommitInDeploymentReqMultiError) AllErrors() []error { return m }

// CheckCommitInDeploymentReqValidationError is the validation error returned
// by CheckCommitInDeploymentReq.Validate if the designated constraints aren't met.
type CheckCommitInDeploymentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckCommitInDeploymentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckCommitInDeploymentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckCommitInDeploymentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckCommitInDeploymentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckCommitInDeploymentReqValidationError) ErrorName() string {
	return "CheckCommitInDeploymentReqValidationError"
}

// Error satisfies the builtin error interface
func (e CheckCommitInDeploymentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckCommitInDeploymentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckCommitInDeploymentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckCommitInDeploymentReqValidationError{}

// Validate checks the field values on CheckCommitInDeploymentResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckCommitInDeploymentResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckCommitInDeploymentResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckCommitInDeploymentRespMultiError, or nil if none found.
func (m *CheckCommitInDeploymentResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckCommitInDeploymentResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if len(errors) > 0 {
		return CheckCommitInDeploymentRespMultiError(errors)
	}

	return nil
}

// CheckCommitInDeploymentRespMultiError is an error wrapping multiple
// validation errors returned by CheckCommitInDeploymentResp.ValidateAll() if
// the designated constraints aren't met.
type CheckCommitInDeploymentRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckCommitInDeploymentRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckCommitInDeploymentRespMultiError) AllErrors() []error { return m }

// CheckCommitInDeploymentRespValidationError is the validation error returned
// by CheckCommitInDeploymentResp.Validate if the designated constraints
// aren't met.
type CheckCommitInDeploymentRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckCommitInDeploymentRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckCommitInDeploymentRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckCommitInDeploymentRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckCommitInDeploymentRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckCommitInDeploymentRespValidationError) ErrorName() string {
	return "CheckCommitInDeploymentRespValidationError"
}

// Error satisfies the builtin error interface
func (e CheckCommitInDeploymentRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckCommitInDeploymentResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckCommitInDeploymentRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckCommitInDeploymentRespValidationError{}
