// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: prodvana/service/service_config.proto

package service

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	common_config "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/common_config"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = common_config.Maturity(0)
)

// Validate checks the field values on ReplicasConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReplicasConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReplicasConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReplicasConfigMultiError,
// or nil if none found.
func (m *ReplicasConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ReplicasConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.ConfigOneof.(type) {
	case *ReplicasConfig_Fixed:
		if v == nil {
			err := ReplicasConfigValidationError{
				field:  "ConfigOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Fixed
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ReplicasConfigMultiError(errors)
	}

	return nil
}

// ReplicasConfigMultiError is an error wrapping multiple validation errors
// returned by ReplicasConfig.ValidateAll() if the designated constraints
// aren't met.
type ReplicasConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReplicasConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReplicasConfigMultiError) AllErrors() []error { return m }

// ReplicasConfigValidationError is the validation error returned by
// ReplicasConfig.Validate if the designated constraints aren't met.
type ReplicasConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReplicasConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReplicasConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReplicasConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReplicasConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReplicasConfigValidationError) ErrorName() string { return "ReplicasConfigValidationError" }

// Error satisfies the builtin error interface
func (e ReplicasConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReplicasConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReplicasConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReplicasConfigValidationError{}

// Validate checks the field values on MetricAnalysis with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetricAnalysis) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricAnalysis with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetricAnalysisMultiError,
// or nil if none found.
func (m *MetricAnalysis) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricAnalysis) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.AnalysisOneof.(type) {
	case *MetricAnalysis_SuccessRate:
		if v == nil {
			err := MetricAnalysisValidationError{
				field:  "AnalysisOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSuccessRate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricAnalysisValidationError{
						field:  "SuccessRate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricAnalysisValidationError{
						field:  "SuccessRate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSuccessRate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricAnalysisValidationError{
					field:  "SuccessRate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetricAnalysis_LatencyP95:
		if v == nil {
			err := MetricAnalysisValidationError{
				field:  "AnalysisOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLatencyP95()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricAnalysisValidationError{
						field:  "LatencyP95",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricAnalysisValidationError{
						field:  "LatencyP95",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLatencyP95()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricAnalysisValidationError{
					field:  "LatencyP95",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return MetricAnalysisMultiError(errors)
	}

	return nil
}

// MetricAnalysisMultiError is an error wrapping multiple validation errors
// returned by MetricAnalysis.ValidateAll() if the designated constraints
// aren't met.
type MetricAnalysisMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricAnalysisMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricAnalysisMultiError) AllErrors() []error { return m }

// MetricAnalysisValidationError is the validation error returned by
// MetricAnalysis.Validate if the designated constraints aren't met.
type MetricAnalysisValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricAnalysisValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricAnalysisValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricAnalysisValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricAnalysisValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricAnalysisValidationError) ErrorName() string { return "MetricAnalysisValidationError" }

// Error satisfies the builtin error interface
func (e MetricAnalysisValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricAnalysis.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricAnalysisValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricAnalysisValidationError{}

// Validate checks the field values on ReleaseStrategyConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReleaseStrategyConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseStrategyConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReleaseStrategyConfigMultiError, or nil if none found.
func (m *ReleaseStrategyConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseStrategyConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIndividualStageDeadline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReleaseStrategyConfigValidationError{
					field:  "IndividualStageDeadline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReleaseStrategyConfigValidationError{
					field:  "IndividualStageDeadline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIndividualStageDeadline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReleaseStrategyConfigValidationError{
				field:  "IndividualStageDeadline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAutomatedTestingDuration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReleaseStrategyConfigValidationError{
					field:  "AutomatedTestingDuration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReleaseStrategyConfigValidationError{
					field:  "AutomatedTestingDuration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAutomatedTestingDuration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReleaseStrategyConfigValidationError{
				field:  "AutomatedTestingDuration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetMetricsAnalysis() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReleaseStrategyConfigValidationError{
						field:  fmt.Sprintf("MetricsAnalysis[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReleaseStrategyConfigValidationError{
						field:  fmt.Sprintf("MetricsAnalysis[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReleaseStrategyConfigValidationError{
					field:  fmt.Sprintf("MetricsAnalysis[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ManualApproval

	if all {
		switch v := interface{}(m.GetCheckInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReleaseStrategyConfigValidationError{
					field:  "CheckInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReleaseStrategyConfigValidationError{
					field:  "CheckInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheckInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReleaseStrategyConfigValidationError{
				field:  "CheckInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FailureThreshold

	if len(errors) > 0 {
		return ReleaseStrategyConfigMultiError(errors)
	}

	return nil
}

// ReleaseStrategyConfigMultiError is an error wrapping multiple validation
// errors returned by ReleaseStrategyConfig.ValidateAll() if the designated
// constraints aren't met.
type ReleaseStrategyConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseStrategyConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseStrategyConfigMultiError) AllErrors() []error { return m }

// ReleaseStrategyConfigValidationError is the validation error returned by
// ReleaseStrategyConfig.Validate if the designated constraints aren't met.
type ReleaseStrategyConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseStrategyConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseStrategyConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseStrategyConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseStrategyConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseStrategyConfigValidationError) ErrorName() string {
	return "ReleaseStrategyConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ReleaseStrategyConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseStrategyConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseStrategyConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseStrategyConfigValidationError{}

// Validate checks the field values on TLSSecret with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TLSSecret) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSSecret with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TLSSecretMultiError, or nil
// if none found.
func (m *TLSSecret) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSSecret) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofTlsSecretPresent := false
	switch v := m.TlsSecret.(type) {
	case *TLSSecret_RawSecret:
		if v == nil {
			err := TLSSecretValidationError{
				field:  "TlsSecret",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTlsSecretPresent = true
		// no validation rules for RawSecret
	case *TLSSecret_Secret:
		if v == nil {
			err := TLSSecretValidationError{
				field:  "TlsSecret",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTlsSecretPresent = true

		if all {
			switch v := interface{}(m.GetSecret()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TLSSecretValidationError{
						field:  "Secret",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TLSSecretValidationError{
						field:  "Secret",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TLSSecretValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofTlsSecretPresent {
		err := TLSSecretValidationError{
			field:  "TlsSecret",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TLSSecretMultiError(errors)
	}

	return nil
}

// TLSSecretMultiError is an error wrapping multiple validation errors returned
// by TLSSecret.ValidateAll() if the designated constraints aren't met.
type TLSSecretMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSSecretMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSSecretMultiError) AllErrors() []error { return m }

// TLSSecretValidationError is the validation error returned by
// TLSSecret.Validate if the designated constraints aren't met.
type TLSSecretValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSSecretValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSSecretValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSSecretValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSSecretValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSSecretValidationError) ErrorName() string { return "TLSSecretValidationError" }

// Error satisfies the builtin error interface
func (e TLSSecretValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSSecret.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSSecretValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSSecretValidationError{}

// Validate checks the field values on TLSCertificate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TLSCertificate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLSCertificate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TLSCertificateMultiError,
// or nil if none found.
func (m *TLSCertificate) ValidateAll() error {
	return m.validate(true)
}

func (m *TLSCertificate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTlsCert() == nil {
		err := TLSCertificateValidationError{
			field:  "TlsCert",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTlsCert()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSCertificateValidationError{
					field:  "TlsCert",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSCertificateValidationError{
					field:  "TlsCert",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTlsCert()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSCertificateValidationError{
				field:  "TlsCert",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetTlsKey() == nil {
		err := TLSCertificateValidationError{
			field:  "TlsKey",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTlsKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TLSCertificateValidationError{
					field:  "TlsKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TLSCertificateValidationError{
					field:  "TlsKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTlsKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TLSCertificateValidationError{
				field:  "TlsKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TLSCertificateMultiError(errors)
	}

	return nil
}

// TLSCertificateMultiError is an error wrapping multiple validation errors
// returned by TLSCertificate.ValidateAll() if the designated constraints
// aren't met.
type TLSCertificateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSCertificateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSCertificateMultiError) AllErrors() []error { return m }

// TLSCertificateValidationError is the validation error returned by
// TLSCertificate.Validate if the designated constraints aren't met.
type TLSCertificateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSCertificateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSCertificateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSCertificateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSCertificateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSCertificateValidationError) ErrorName() string { return "TLSCertificateValidationError" }

// Error satisfies the builtin error interface
func (e TLSCertificateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSCertificate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSCertificateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSCertificateValidationError{}

// Validate checks the field values on Certificate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Certificate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Certificate with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CertificateMultiError, or
// nil if none found.
func (m *Certificate) ValidateAll() error {
	return m.validate(true)
}

func (m *Certificate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofCertificatePresent := false
	switch v := m.Certificate.(type) {
	case *Certificate_Tls:
		if v == nil {
			err := CertificateValidationError{
				field:  "Certificate",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofCertificatePresent = true

		if all {
			switch v := interface{}(m.GetTls()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CertificateValidationError{
						field:  "Tls",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CertificateValidationError{
						field:  "Tls",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTls()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CertificateValidationError{
					field:  "Tls",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Certificate_AwsAcmCert:
		if v == nil {
			err := CertificateValidationError{
				field:  "Certificate",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofCertificatePresent = true
		// no validation rules for AwsAcmCert
	default:
		_ = v // ensures v is used
	}
	if !oneofCertificatePresent {
		err := CertificateValidationError{
			field:  "Certificate",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CertificateMultiError(errors)
	}

	return nil
}

// CertificateMultiError is an error wrapping multiple validation errors
// returned by Certificate.ValidateAll() if the designated constraints aren't met.
type CertificateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CertificateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CertificateMultiError) AllErrors() []error { return m }

// CertificateValidationError is the validation error returned by
// Certificate.Validate if the designated constraints aren't met.
type CertificateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CertificateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CertificateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CertificateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CertificateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CertificateValidationError) ErrorName() string { return "CertificateValidationError" }

// Error satisfies the builtin error interface
func (e CertificateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCertificate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CertificateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CertificateValidationError{}

// Validate checks the field values on PerReleaseChannelConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PerReleaseChannelConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PerReleaseChannelConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PerReleaseChannelConfigMultiError, or nil if none found.
func (m *PerReleaseChannelConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *PerReleaseChannelConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetReleaseChannel()) < 1 {
		err := PerReleaseChannelConfigValidationError{
			field:  "ReleaseChannel",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetCustomHostnames() {
		_, _ = idx, item

		if err := m._validateHostname(item); err != nil {
			err = PerReleaseChannelConfigValidationError{
				field:  fmt.Sprintf("CustomHostnames[%v]", idx),
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetPrograms() {
		_, _ = idx, item

		if item == nil {
			err := PerReleaseChannelConfigValidationError{
				field:  fmt.Sprintf("Programs[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  fmt.Sprintf("Programs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  fmt.Sprintf("Programs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PerReleaseChannelConfigValidationError{
					field:  fmt.Sprintf("Programs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCert()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PerReleaseChannelConfigValidationError{
					field:  "Cert",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PerReleaseChannelConfigValidationError{
					field:  "Cert",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCert()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PerReleaseChannelConfigValidationError{
				field:  "Cert",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeliveryConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PerReleaseChannelConfigValidationError{
					field:  "DeliveryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PerReleaseChannelConfigValidationError{
					field:  "DeliveryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PerReleaseChannelConfigValidationError{
				field:  "DeliveryConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetVolumes() {
		_, _ = idx, item

		if item == nil {
			err := PerReleaseChannelConfigValidationError{
				field:  fmt.Sprintf("Volumes[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  fmt.Sprintf("Volumes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  fmt.Sprintf("Volumes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PerReleaseChannelConfigValidationError{
					field:  fmt.Sprintf("Volumes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReplicas()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PerReleaseChannelConfigValidationError{
					field:  "Replicas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PerReleaseChannelConfigValidationError{
					field:  "Replicas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReplicas()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PerReleaseChannelConfigValidationError{
				field:  "Replicas",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPrePushTasks() {
		_, _ = idx, item

		if item == nil {
			err := PerReleaseChannelConfigValidationError{
				field:  fmt.Sprintf("PrePushTasks[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  fmt.Sprintf("PrePushTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  fmt.Sprintf("PrePushTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PerReleaseChannelConfigValidationError{
					field:  fmt.Sprintf("PrePushTasks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDeliveryExtensions() {
		_, _ = idx, item

		if item == nil {
			err := PerReleaseChannelConfigValidationError{
				field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PerReleaseChannelConfigValidationError{
					field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRuntimeSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PerReleaseChannelConfigValidationError{
					field:  "RuntimeSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PerReleaseChannelConfigValidationError{
					field:  "RuntimeSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntimeSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PerReleaseChannelConfigValidationError{
				field:  "RuntimeSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RuntimeConnection

	{
		sorted_keys := make([]string, len(m.GetEnv()))
		i := 0
		for key := range m.GetEnv() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetEnv()[key]
			_ = val

			if val == nil {
				err := PerReleaseChannelConfigValidationError{
					field:  fmt.Sprintf("Env[%v]", key),
					reason: "value cannot be sparse, all pairs must be non-nil",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_PerReleaseChannelConfig_Env_Pattern.MatchString(key) {
				err := PerReleaseChannelConfigValidationError{
					field:  fmt.Sprintf("Env[%v]", key),
					reason: "value does not match regex pattern \"^[a-zA-Z_]+[a-zA-Z0-9_]*$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, PerReleaseChannelConfigValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, PerReleaseChannelConfigValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return PerReleaseChannelConfigValidationError{
						field:  fmt.Sprintf("Env[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	switch v := m.ConfigOneof.(type) {
	case *PerReleaseChannelConfig_RuntimeExtension:
		if v == nil {
			err := PerReleaseChannelConfigValidationError{
				field:  "ConfigOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRuntimeExtension()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  "RuntimeExtension",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  "RuntimeExtension",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRuntimeExtension()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PerReleaseChannelConfigValidationError{
					field:  "RuntimeExtension",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PerReleaseChannelConfig_KubernetesConfig:
		if v == nil {
			err := PerReleaseChannelConfigValidationError{
				field:  "ConfigOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKubernetesConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  "KubernetesConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  "KubernetesConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKubernetesConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PerReleaseChannelConfigValidationError{
					field:  "KubernetesConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PerReleaseChannelConfig_ExternalConfig:
		if v == nil {
			err := PerReleaseChannelConfigValidationError{
				field:  "ConfigOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExternalConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  "ExternalConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  "ExternalConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExternalConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PerReleaseChannelConfigValidationError{
					field:  "ExternalConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PerReleaseChannelConfig_Helm:
		if v == nil {
			err := PerReleaseChannelConfigValidationError{
				field:  "ConfigOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHelm()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  "Helm",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PerReleaseChannelConfigValidationError{
						field:  "Helm",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHelm()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PerReleaseChannelConfigValidationError{
					field:  "Helm",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return PerReleaseChannelConfigMultiError(errors)
	}

	return nil
}

func (m *PerReleaseChannelConfig) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

// PerReleaseChannelConfigMultiError is an error wrapping multiple validation
// errors returned by PerReleaseChannelConfig.ValidateAll() if the designated
// constraints aren't met.
type PerReleaseChannelConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PerReleaseChannelConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PerReleaseChannelConfigMultiError) AllErrors() []error { return m }

// PerReleaseChannelConfigValidationError is the validation error returned by
// PerReleaseChannelConfig.Validate if the designated constraints aren't met.
type PerReleaseChannelConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PerReleaseChannelConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PerReleaseChannelConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PerReleaseChannelConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PerReleaseChannelConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PerReleaseChannelConfigValidationError) ErrorName() string {
	return "PerReleaseChannelConfigValidationError"
}

// Error satisfies the builtin error interface
func (e PerReleaseChannelConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPerReleaseChannelConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PerReleaseChannelConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PerReleaseChannelConfigValidationError{}

var _PerReleaseChannelConfig_Env_Pattern = regexp.MustCompile("^[a-zA-Z_]+[a-zA-Z0-9_]*$")

// Validate checks the field values on CapabilityReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CapabilityReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CapabilityReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CapabilityReferenceMultiError, or nil if none found.
func (m *CapabilityReference) ValidateAll() error {
	return m.validate(true)
}

func (m *CapabilityReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := CapabilityReferenceValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CapabilityReferenceMultiError(errors)
	}

	return nil
}

// CapabilityReferenceMultiError is an error wrapping multiple validation
// errors returned by CapabilityReference.ValidateAll() if the designated
// constraints aren't met.
type CapabilityReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CapabilityReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CapabilityReferenceMultiError) AllErrors() []error { return m }

// CapabilityReferenceValidationError is the validation error returned by
// CapabilityReference.Validate if the designated constraints aren't met.
type CapabilityReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CapabilityReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CapabilityReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CapabilityReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CapabilityReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CapabilityReferenceValidationError) ErrorName() string {
	return "CapabilityReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e CapabilityReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCapabilityReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CapabilityReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CapabilityReferenceValidationError{}

// Validate checks the field values on CompiledCapabilityConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompiledCapabilityConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompiledCapabilityConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompiledCapabilityConfigMultiError, or nil if none found.
func (m *CompiledCapabilityConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *CompiledCapabilityConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCapability()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompiledCapabilityConfigValidationError{
					field:  "Capability",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompiledCapabilityConfigValidationError{
					field:  "Capability",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCapability()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompiledCapabilityConfigValidationError{
				field:  "Capability",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CompiledCapabilityConfigMultiError(errors)
	}

	return nil
}

// CompiledCapabilityConfigMultiError is an error wrapping multiple validation
// errors returned by CompiledCapabilityConfig.ValidateAll() if the designated
// constraints aren't met.
type CompiledCapabilityConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompiledCapabilityConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompiledCapabilityConfigMultiError) AllErrors() []error { return m }

// CompiledCapabilityConfigValidationError is the validation error returned by
// CompiledCapabilityConfig.Validate if the designated constraints aren't met.
type CompiledCapabilityConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompiledCapabilityConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompiledCapabilityConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompiledCapabilityConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompiledCapabilityConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompiledCapabilityConfigValidationError) ErrorName() string {
	return "CompiledCapabilityConfigValidationError"
}

// Error satisfies the builtin error interface
func (e CompiledCapabilityConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompiledCapabilityConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompiledCapabilityConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompiledCapabilityConfigValidationError{}

// Validate checks the field values on ProgramReference with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProgramReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgramReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProgramReferenceMultiError, or nil if none found.
func (m *ProgramReference) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgramReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofRefPresent := false
	switch v := m.Ref.(type) {
	case *ProgramReference_Name:
		if v == nil {
			err := ProgramReferenceValidationError{
				field:  "Ref",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRefPresent = true
		// no validation rules for Name
	default:
		_ = v // ensures v is used
	}
	if !oneofRefPresent {
		err := ProgramReferenceValidationError{
			field:  "Ref",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ProgramReferenceMultiError(errors)
	}

	return nil
}

// ProgramReferenceMultiError is an error wrapping multiple validation errors
// returned by ProgramReference.ValidateAll() if the designated constraints
// aren't met.
type ProgramReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgramReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgramReferenceMultiError) AllErrors() []error { return m }

// ProgramReferenceValidationError is the validation error returned by
// ProgramReference.Validate if the designated constraints aren't met.
type ProgramReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgramReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgramReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgramReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgramReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgramReferenceValidationError) ErrorName() string { return "ProgramReferenceValidationError" }

// Error satisfies the builtin error interface
func (e ProgramReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgramReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgramReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgramReferenceValidationError{}

// Validate checks the field values on TaskReference with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaskReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskReference with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaskReferenceMultiError, or
// nil if none found.
func (m *TaskReference) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofRefPresent := false
	switch v := m.Ref.(type) {
	case *TaskReference_ReleaseChannel:
		if v == nil {
			err := TaskReferenceValidationError{
				field:  "Ref",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRefPresent = true
		// no validation rules for ReleaseChannel
	default:
		_ = v // ensures v is used
	}
	if !oneofRefPresent {
		err := TaskReferenceValidationError{
			field:  "Ref",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TaskReferenceMultiError(errors)
	}

	return nil
}

// TaskReferenceMultiError is an error wrapping multiple validation errors
// returned by TaskReference.ValidateAll() if the designated constraints
// aren't met.
type TaskReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskReferenceMultiError) AllErrors() []error { return m }

// TaskReferenceValidationError is the validation error returned by
// TaskReference.Validate if the designated constraints aren't met.
type TaskReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskReferenceValidationError) ErrorName() string { return "TaskReferenceValidationError" }

// Error satisfies the builtin error interface
func (e TaskReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskReferenceValidationError{}

// Validate checks the field values on TaskConfig with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaskConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaskConfigMultiError, or
// nil if none found.
func (m *TaskConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProgram() == nil {
		err := TaskConfigValidationError{
			field:  "Program",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProgram()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskConfigValidationError{
					field:  "Program",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskConfigValidationError{
					field:  "Program",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProgram()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskConfigValidationError{
				field:  "Program",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBaseProgram()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskConfigValidationError{
					field:  "BaseProgram",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskConfigValidationError{
					field:  "BaseProgram",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseProgram()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskConfigValidationError{
				field:  "BaseProgram",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRetryConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskConfigValidationError{
					field:  "RetryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskConfigValidationError{
					field:  "RetryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRetryConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskConfigValidationError{
				field:  "RetryConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRef()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskConfigValidationError{
					field:  "Ref",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskConfigValidationError{
					field:  "Ref",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRef()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskConfigValidationError{
				field:  "Ref",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TaskConfigMultiError(errors)
	}

	return nil
}

// TaskConfigMultiError is an error wrapping multiple validation errors
// returned by TaskConfig.ValidateAll() if the designated constraints aren't met.
type TaskConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskConfigMultiError) AllErrors() []error { return m }

// TaskConfigValidationError is the validation error returned by
// TaskConfig.Validate if the designated constraints aren't met.
type TaskConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskConfigValidationError) ErrorName() string { return "TaskConfigValidationError" }

// Error satisfies the builtin error interface
func (e TaskConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskConfigValidationError{}

// Validate checks the field values on ProtectionLink with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProtectionLink) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProtectionLink with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProtectionLinkMultiError,
// or nil if none found.
func (m *ProtectionLink) ValidateAll() error {
	return m.validate(true)
}

func (m *ProtectionLink) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLifecycle()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionLinkValidationError{
					field:  "Lifecycle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionLinkValidationError{
					field:  "Lifecycle",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLifecycle()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionLinkValidationError{
				field:  "Lifecycle",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AttachmentId

	if len(errors) > 0 {
		return ProtectionLinkMultiError(errors)
	}

	return nil
}

// ProtectionLinkMultiError is an error wrapping multiple validation errors
// returned by ProtectionLink.ValidateAll() if the designated constraints
// aren't met.
type ProtectionLinkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProtectionLinkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProtectionLinkMultiError) AllErrors() []error { return m }

// ProtectionLinkValidationError is the validation error returned by
// ProtectionLink.Validate if the designated constraints aren't met.
type ProtectionLinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProtectionLinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProtectionLinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProtectionLinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProtectionLinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProtectionLinkValidationError) ErrorName() string { return "ProtectionLinkValidationError" }

// Error satisfies the builtin error interface
func (e ProtectionLinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProtectionLink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProtectionLinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProtectionLinkValidationError{}

// Validate checks the field values on DeliveryExtensionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeliveryExtensionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryExtensionConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeliveryExtensionConfigMultiError, or nil if none found.
func (m *DeliveryExtensionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryExtensionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _DeliveryExtensionConfig_Lifecycle_NotInLookup[m.GetLifecycle()]; ok {
		err := DeliveryExtensionConfigValidationError{
			field:  "Lifecycle",
			reason: "value must not be in list [0 1]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	oneofDefinitionPresent := false
	switch v := m.Definition.(type) {
	case *DeliveryExtensionConfig_Inlined:
		if v == nil {
			err := DeliveryExtensionConfigValidationError{
				field:  "Definition",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofDefinitionPresent = true

		if all {
			switch v := interface{}(m.GetInlined()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryExtensionConfigValidationError{
						field:  "Inlined",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryExtensionConfigValidationError{
						field:  "Inlined",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInlined()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryExtensionConfigValidationError{
					field:  "Inlined",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DeliveryExtensionConfig_Instance:
		if v == nil {
			err := DeliveryExtensionConfigValidationError{
				field:  "Definition",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofDefinitionPresent = true

		if utf8.RuneCountInString(m.GetInstance()) < 1 {
			err := DeliveryExtensionConfigValidationError{
				field:  "Instance",
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *DeliveryExtensionConfig_Ref:
		if v == nil {
			err := DeliveryExtensionConfigValidationError{
				field:  "Definition",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofDefinitionPresent = true

		if all {
			switch v := interface{}(m.GetRef()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryExtensionConfigValidationError{
						field:  "Ref",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryExtensionConfigValidationError{
						field:  "Ref",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRef()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryExtensionConfigValidationError{
					field:  "Ref",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofDefinitionPresent {
		err := DeliveryExtensionConfigValidationError{
			field:  "Definition",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeliveryExtensionConfigMultiError(errors)
	}

	return nil
}

// DeliveryExtensionConfigMultiError is an error wrapping multiple validation
// errors returned by DeliveryExtensionConfig.ValidateAll() if the designated
// constraints aren't met.
type DeliveryExtensionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryExtensionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryExtensionConfigMultiError) AllErrors() []error { return m }

// DeliveryExtensionConfigValidationError is the validation error returned by
// DeliveryExtensionConfig.Validate if the designated constraints aren't met.
type DeliveryExtensionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryExtensionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryExtensionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryExtensionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryExtensionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryExtensionConfigValidationError) ErrorName() string {
	return "DeliveryExtensionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e DeliveryExtensionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryExtensionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryExtensionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryExtensionConfigValidationError{}

var _DeliveryExtensionConfig_Lifecycle_NotInLookup = map[common_config.TaskLifecycle]struct{}{
	0: {},
	1: {},
}

// Validate checks the field values on DeliveryExtensionInstance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeliveryExtensionInstance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryExtensionInstance with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeliveryExtensionInstanceMultiError, or nil if none found.
func (m *DeliveryExtensionInstance) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryExtensionInstance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := DeliveryExtensionInstanceValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _DeliveryExtensionInstance_Lifecycle_NotInLookup[m.GetLifecycle()]; ok {
		err := DeliveryExtensionInstanceValidationError{
			field:  "Lifecycle",
			reason: "value must not be in list [0 1]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	oneofDefinitionPresent := false
	switch v := m.Definition.(type) {
	case *DeliveryExtensionInstance_Inlined:
		if v == nil {
			err := DeliveryExtensionInstanceValidationError{
				field:  "Definition",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofDefinitionPresent = true

		if all {
			switch v := interface{}(m.GetInlined()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryExtensionInstanceValidationError{
						field:  "Inlined",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryExtensionInstanceValidationError{
						field:  "Inlined",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInlined()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryExtensionInstanceValidationError{
					field:  "Inlined",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DeliveryExtensionInstance_Ref:
		if v == nil {
			err := DeliveryExtensionInstanceValidationError{
				field:  "Definition",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofDefinitionPresent = true

		if all {
			switch v := interface{}(m.GetRef()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryExtensionInstanceValidationError{
						field:  "Ref",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryExtensionInstanceValidationError{
						field:  "Ref",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRef()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryExtensionInstanceValidationError{
					field:  "Ref",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofDefinitionPresent {
		err := DeliveryExtensionInstanceValidationError{
			field:  "Definition",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeliveryExtensionInstanceMultiError(errors)
	}

	return nil
}

// DeliveryExtensionInstanceMultiError is an error wrapping multiple validation
// errors returned by DeliveryExtensionInstance.ValidateAll() if the
// designated constraints aren't met.
type DeliveryExtensionInstanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryExtensionInstanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryExtensionInstanceMultiError) AllErrors() []error { return m }

// DeliveryExtensionInstanceValidationError is the validation error returned by
// DeliveryExtensionInstance.Validate if the designated constraints aren't met.
type DeliveryExtensionInstanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryExtensionInstanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryExtensionInstanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryExtensionInstanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryExtensionInstanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryExtensionInstanceValidationError) ErrorName() string {
	return "DeliveryExtensionInstanceValidationError"
}

// Error satisfies the builtin error interface
func (e DeliveryExtensionInstanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryExtensionInstance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryExtensionInstanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryExtensionInstanceValidationError{}

var _DeliveryExtensionInstance_Lifecycle_NotInLookup = map[common_config.TaskLifecycle]struct{}{
	0: {},
	1: {},
}

// Validate checks the field values on RuntimeSpecificConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeSpecificConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeSpecificConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RuntimeSpecificConfigMultiError, or nil if none found.
func (m *RuntimeSpecificConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeSpecificConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.RuntimeConfig.(type) {
	case *RuntimeSpecificConfig_K8S:
		if v == nil {
			err := RuntimeSpecificConfigValidationError{
				field:  "RuntimeConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetK8S()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeSpecificConfigValidationError{
						field:  "K8S",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeSpecificConfigValidationError{
						field:  "K8S",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetK8S()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeSpecificConfigValidationError{
					field:  "K8S",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RuntimeSpecificConfigMultiError(errors)
	}

	return nil
}

// RuntimeSpecificConfigMultiError is an error wrapping multiple validation
// errors returned by RuntimeSpecificConfig.ValidateAll() if the designated
// constraints aren't met.
type RuntimeSpecificConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeSpecificConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeSpecificConfigMultiError) AllErrors() []error { return m }

// RuntimeSpecificConfigValidationError is the validation error returned by
// RuntimeSpecificConfig.Validate if the designated constraints aren't met.
type RuntimeSpecificConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeSpecificConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeSpecificConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeSpecificConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeSpecificConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeSpecificConfigValidationError) ErrorName() string {
	return "RuntimeSpecificConfigValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeSpecificConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeSpecificConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeSpecificConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeSpecificConfigValidationError{}

// Validate checks the field values on RuntimeExtensionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeExtensionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeExtensionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RuntimeExtensionConfigMultiError, or nil if none found.
func (m *RuntimeExtensionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeExtensionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetParameterValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeExtensionConfigValidationError{
						field:  fmt.Sprintf("ParameterValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeExtensionConfigValidationError{
						field:  fmt.Sprintf("ParameterValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeExtensionConfigValidationError{
					field:  fmt.Sprintf("ParameterValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RuntimeExtensionConfigMultiError(errors)
	}

	return nil
}

// RuntimeExtensionConfigMultiError is an error wrapping multiple validation
// errors returned by RuntimeExtensionConfig.ValidateAll() if the designated
// constraints aren't met.
type RuntimeExtensionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeExtensionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeExtensionConfigMultiError) AllErrors() []error { return m }

// RuntimeExtensionConfigValidationError is the validation error returned by
// RuntimeExtensionConfig.Validate if the designated constraints aren't met.
type RuntimeExtensionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeExtensionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeExtensionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeExtensionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeExtensionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeExtensionConfigValidationError) ErrorName() string {
	return "RuntimeExtensionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeExtensionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeExtensionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeExtensionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeExtensionConfigValidationError{}

// Validate checks the field values on AutoRollbackConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AutoRollbackConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AutoRollbackConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AutoRollbackConfigMultiError, or nil if none found.
func (m *AutoRollbackConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AutoRollbackConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Disabled

	if len(errors) > 0 {
		return AutoRollbackConfigMultiError(errors)
	}

	return nil
}

// AutoRollbackConfigMultiError is an error wrapping multiple validation errors
// returned by AutoRollbackConfig.ValidateAll() if the designated constraints
// aren't met.
type AutoRollbackConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AutoRollbackConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AutoRollbackConfigMultiError) AllErrors() []error { return m }

// AutoRollbackConfigValidationError is the validation error returned by
// AutoRollbackConfig.Validate if the designated constraints aren't met.
type AutoRollbackConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AutoRollbackConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AutoRollbackConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AutoRollbackConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AutoRollbackConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AutoRollbackConfigValidationError) ErrorName() string {
	return "AutoRollbackConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AutoRollbackConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAutoRollbackConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AutoRollbackConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AutoRollbackConfigValidationError{}

// Validate checks the field values on ProtectionConvergenceAttachment with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProtectionConvergenceAttachment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProtectionConvergenceAttachment with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ProtectionConvergenceAttachmentMultiError, or nil if none found.
func (m *ProtectionConvergenceAttachment) ValidateAll() error {
	return m.validate(true)
}

func (m *ProtectionConvergenceAttachment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 0 || l > 63 {
		err := ProtectionConvergenceAttachmentValidationError{
			field:  "Name",
			reason: "value length must be between 0 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProtectionConvergenceAttachment_Name_Pattern.MatchString(m.GetName()) {
		err := ProtectionConvergenceAttachmentValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z]?([a-z0-9-]*[a-z0-9]){0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetRef() == nil {
		err := ProtectionConvergenceAttachmentValidationError{
			field:  "Ref",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRef()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProtectionConvergenceAttachmentValidationError{
					field:  "Ref",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProtectionConvergenceAttachmentValidationError{
					field:  "Ref",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRef()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProtectionConvergenceAttachmentValidationError{
				field:  "Ref",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetLifecycle()) < 1 {
		err := ProtectionConvergenceAttachmentValidationError{
			field:  "Lifecycle",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetLifecycle() {
		_, _ = idx, item

		if item == nil {
			err := ProtectionConvergenceAttachmentValidationError{
				field:  fmt.Sprintf("Lifecycle[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProtectionConvergenceAttachmentValidationError{
						field:  fmt.Sprintf("Lifecycle[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProtectionConvergenceAttachmentValidationError{
						field:  fmt.Sprintf("Lifecycle[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProtectionConvergenceAttachmentValidationError{
					field:  fmt.Sprintf("Lifecycle[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ProtectionConvergenceAttachmentMultiError(errors)
	}

	return nil
}

// ProtectionConvergenceAttachmentMultiError is an error wrapping multiple
// validation errors returned by ProtectionConvergenceAttachment.ValidateAll()
// if the designated constraints aren't met.
type ProtectionConvergenceAttachmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProtectionConvergenceAttachmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProtectionConvergenceAttachmentMultiError) AllErrors() []error { return m }

// ProtectionConvergenceAttachmentValidationError is the validation error
// returned by ProtectionConvergenceAttachment.Validate if the designated
// constraints aren't met.
type ProtectionConvergenceAttachmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProtectionConvergenceAttachmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProtectionConvergenceAttachmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProtectionConvergenceAttachmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProtectionConvergenceAttachmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProtectionConvergenceAttachmentValidationError) ErrorName() string {
	return "ProtectionConvergenceAttachmentValidationError"
}

// Error satisfies the builtin error interface
func (e ProtectionConvergenceAttachmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProtectionConvergenceAttachment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProtectionConvergenceAttachmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProtectionConvergenceAttachmentValidationError{}

var _ProtectionConvergenceAttachment_Name_Pattern = regexp.MustCompile("^[a-z]?([a-z0-9-]*[a-z0-9]){0,1}$")

// Validate checks the field values on ServiceConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServiceConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServiceConfigMultiError, or
// nil if none found.
func (m *ServiceConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 63 {
		err := ServiceConfigValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceConfig_Name_Pattern.MatchString(m.GetName()) {
		err := ServiceConfigValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z]([a-z0-9-]*[a-z0-9]){0,1}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Application

	for idx, item := range m.GetPrograms() {
		_, _ = idx, item

		if item == nil {
			err := ServiceConfigValidationError{
				field:  fmt.Sprintf("Programs[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("Programs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("Programs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceConfigValidationError{
					field:  fmt.Sprintf("Programs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReplicas()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "Replicas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "Replicas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReplicas()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceConfigValidationError{
				field:  "Replicas",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReleaseStrategy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "ReleaseStrategy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "ReleaseStrategy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReleaseStrategy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceConfigValidationError{
				field:  "ReleaseStrategy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPerReleaseChannel() {
		_, _ = idx, item

		if item == nil {
			err := ServiceConfigValidationError{
				field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceConfigValidationError{
					field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCapabilities() {
		_, _ = idx, item

		if item == nil {
			err := ServiceConfigValidationError{
				field:  fmt.Sprintf("Capabilities[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("Capabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("Capabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceConfigValidationError{
					field:  fmt.Sprintf("Capabilities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetDeliveryConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "DeliveryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "DeliveryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceConfigValidationError{
				field:  "DeliveryConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetVolumes() {
		_, _ = idx, item

		if item == nil {
			err := ServiceConfigValidationError{
				field:  fmt.Sprintf("Volumes[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("Volumes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("Volumes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceConfigValidationError{
					field:  fmt.Sprintf("Volumes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetDeployAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "DeployAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "DeployAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeployAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceConfigValidationError{
				field:  "DeployAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBaseTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "BaseTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "BaseTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceConfigValidationError{
				field:  "BaseTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPrePushTasks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("PrePushTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("PrePushTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceConfigValidationError{
					field:  fmt.Sprintf("PrePushTasks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDeliveryExtensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceConfigValidationError{
					field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDeliveryExtensionInstances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("DeliveryExtensionInstances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("DeliveryExtensionInstances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceConfigValidationError{
					field:  fmt.Sprintf("DeliveryExtensionInstances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRuntimeSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "RuntimeSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "RuntimeSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntimeSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceConfigValidationError{
				field:  "RuntimeSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RuntimeConnection

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if item == nil {
			err := ServiceConfigValidationError{
				field:  fmt.Sprintf("Parameters[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceConfigValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetParameterValues()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "ParameterValues",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "ParameterValues",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameterValues()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceConfigValidationError{
				field:  "ParameterValues",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetProgressDeadline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "ProgressDeadline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "ProgressDeadline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProgressDeadline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceConfigValidationError{
				field:  "ProgressDeadline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ParametersAutogen

	if all {
		switch v := interface{}(m.GetAutoRollback()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "AutoRollback",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceConfigValidationError{
					field:  "AutoRollback",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAutoRollback()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceConfigValidationError{
				field:  "AutoRollback",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NoCleanupOnDelete

	{
		sorted_keys := make([]string, len(m.GetEnv()))
		i := 0
		for key := range m.GetEnv() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetEnv()[key]
			_ = val

			if val == nil {
				err := ServiceConfigValidationError{
					field:  fmt.Sprintf("Env[%v]", key),
					reason: "value cannot be sparse, all pairs must be non-nil",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_ServiceConfig_Env_Pattern.MatchString(key) {
				err := ServiceConfigValidationError{
					field:  fmt.Sprintf("Env[%v]", key),
					reason: "value does not match regex pattern \"^[a-zA-Z_]+[a-zA-Z0-9_]*$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ServiceConfigValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ServiceConfigValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ServiceConfigValidationError{
						field:  fmt.Sprintf("Env[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	switch v := m.ConfigOneof.(type) {
	case *ServiceConfig_RuntimeExtension:
		if v == nil {
			err := ServiceConfigValidationError{
				field:  "ConfigOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRuntimeExtension()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  "RuntimeExtension",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  "RuntimeExtension",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRuntimeExtension()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceConfigValidationError{
					field:  "RuntimeExtension",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceConfig_KubernetesConfig:
		if v == nil {
			err := ServiceConfigValidationError{
				field:  "ConfigOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKubernetesConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  "KubernetesConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  "KubernetesConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKubernetesConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceConfigValidationError{
					field:  "KubernetesConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceConfig_ExternalConfig:
		if v == nil {
			err := ServiceConfigValidationError{
				field:  "ConfigOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExternalConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  "ExternalConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  "ExternalConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExternalConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceConfigValidationError{
					field:  "ExternalConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceConfig_Helm:
		if v == nil {
			err := ServiceConfigValidationError{
				field:  "ConfigOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHelm()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  "Helm",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceConfigValidationError{
						field:  "Helm",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHelm()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceConfigValidationError{
					field:  "Helm",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ServiceConfigMultiError(errors)
	}

	return nil
}

// ServiceConfigMultiError is an error wrapping multiple validation errors
// returned by ServiceConfig.ValidateAll() if the designated constraints
// aren't met.
type ServiceConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceConfigMultiError) AllErrors() []error { return m }

// ServiceConfigValidationError is the validation error returned by
// ServiceConfig.Validate if the designated constraints aren't met.
type ServiceConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceConfigValidationError) ErrorName() string { return "ServiceConfigValidationError" }

// Error satisfies the builtin error interface
func (e ServiceConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceConfigValidationError{}

var _ServiceConfig_Name_Pattern = regexp.MustCompile("^[a-z]([a-z0-9-]*[a-z0-9]){0,1}$")

var _ServiceConfig_Env_Pattern = regexp.MustCompile("^[a-zA-Z_]+[a-zA-Z0-9_]*$")

// Validate checks the field values on CompiledServiceInstanceConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompiledServiceInstanceConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompiledServiceInstanceConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CompiledServiceInstanceConfigMultiError, or nil if none found.
func (m *CompiledServiceInstanceConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *CompiledServiceInstanceConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Service

	// no validation rules for Application

	// no validation rules for ReleaseChannel

	for idx, item := range m.GetPrograms() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("Programs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("Programs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompiledServiceInstanceConfigValidationError{
					field:  fmt.Sprintf("Programs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReplicas()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "Replicas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "Replicas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReplicas()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompiledServiceInstanceConfigValidationError{
				field:  "Replicas",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Maturity

	if all {
		switch v := interface{}(m.GetReleaseStrategy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "ReleaseStrategy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "ReleaseStrategy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReleaseStrategy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompiledServiceInstanceConfigValidationError{
				field:  "ReleaseStrategy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCert()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "Cert",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "Cert",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCert()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompiledServiceInstanceConfigValidationError{
				field:  "Cert",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRuntime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompiledServiceInstanceConfigValidationError{
				field:  "Runtime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRuntimeExecution()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "RuntimeExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "RuntimeExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntimeExecution()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompiledServiceInstanceConfigValidationError{
				field:  "RuntimeExecution",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCapabilities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("Capabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("Capabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompiledServiceInstanceConfigValidationError{
					field:  fmt.Sprintf("Capabilities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetDeliveryConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "DeliveryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "DeliveryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompiledServiceInstanceConfigValidationError{
				field:  "DeliveryConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetVolumes() {
		_, _ = idx, item

		if item == nil {
			err := CompiledServiceInstanceConfigValidationError{
				field:  fmt.Sprintf("Volumes[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("Volumes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("Volumes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompiledServiceInstanceConfigValidationError{
					field:  fmt.Sprintf("Volumes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetDeployAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "DeployAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "DeployAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeployAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompiledServiceInstanceConfigValidationError{
				field:  "DeployAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBaseTemplate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "BaseTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "BaseTemplate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseTemplate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompiledServiceInstanceConfigValidationError{
				field:  "BaseTemplate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPrePushTasks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("PrePushTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("PrePushTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompiledServiceInstanceConfigValidationError{
					field:  fmt.Sprintf("PrePushTasks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDeliveryExtensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompiledServiceInstanceConfigValidationError{
					field:  fmt.Sprintf("DeliveryExtensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDeliveryExtensionInstances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("DeliveryExtensionInstances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("DeliveryExtensionInstances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompiledServiceInstanceConfigValidationError{
					field:  fmt.Sprintf("DeliveryExtensionInstances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRuntimeSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "RuntimeSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "RuntimeSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntimeSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompiledServiceInstanceConfigValidationError{
				field:  "RuntimeSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompiledServiceInstanceConfigValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetParameterValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("ParameterValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("ParameterValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompiledServiceInstanceConfigValidationError{
					field:  fmt.Sprintf("ParameterValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetProgressDeadline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "ProgressDeadline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompiledServiceInstanceConfigValidationError{
					field:  "ProgressDeadline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProgressDeadline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompiledServiceInstanceConfigValidationError{
				field:  "ProgressDeadline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetEnv()))
		i := 0
		for key := range m.GetEnv() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetEnv()[key]
			_ = val

			if val == nil {
				err := CompiledServiceInstanceConfigValidationError{
					field:  fmt.Sprintf("Env[%v]", key),
					reason: "value cannot be sparse, all pairs must be non-nil",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_CompiledServiceInstanceConfig_Env_Pattern.MatchString(key) {
				err := CompiledServiceInstanceConfigValidationError{
					field:  fmt.Sprintf("Env[%v]", key),
					reason: "value does not match regex pattern \"^[a-zA-Z_]+[a-zA-Z0-9_]*$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CompiledServiceInstanceConfigValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CompiledServiceInstanceConfigValidationError{
							field:  fmt.Sprintf("Env[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CompiledServiceInstanceConfigValidationError{
						field:  fmt.Sprintf("Env[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for NoCleanupOnDelete

	switch v := m.ConfigOneof.(type) {
	case *CompiledServiceInstanceConfig_RuntimeExtension:
		if v == nil {
			err := CompiledServiceInstanceConfigValidationError{
				field:  "ConfigOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRuntimeExtension()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  "RuntimeExtension",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  "RuntimeExtension",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRuntimeExtension()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompiledServiceInstanceConfigValidationError{
					field:  "RuntimeExtension",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CompiledServiceInstanceConfig_KubernetesConfig:
		if v == nil {
			err := CompiledServiceInstanceConfigValidationError{
				field:  "ConfigOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKubernetesConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  "KubernetesConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  "KubernetesConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKubernetesConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompiledServiceInstanceConfigValidationError{
					field:  "KubernetesConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CompiledServiceInstanceConfig_Helm:
		if v == nil {
			err := CompiledServiceInstanceConfigValidationError{
				field:  "ConfigOneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHelm()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  "Helm",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompiledServiceInstanceConfigValidationError{
						field:  "Helm",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHelm()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompiledServiceInstanceConfigValidationError{
					field:  "Helm",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return CompiledServiceInstanceConfigMultiError(errors)
	}

	return nil
}

// CompiledServiceInstanceConfigMultiError is an error wrapping multiple
// validation errors returned by CompiledServiceInstanceConfig.ValidateAll()
// if the designated constraints aren't met.
type CompiledServiceInstanceConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompiledServiceInstanceConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompiledServiceInstanceConfigMultiError) AllErrors() []error { return m }

// CompiledServiceInstanceConfigValidationError is the validation error
// returned by CompiledServiceInstanceConfig.Validate if the designated
// constraints aren't met.
type CompiledServiceInstanceConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompiledServiceInstanceConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompiledServiceInstanceConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompiledServiceInstanceConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompiledServiceInstanceConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompiledServiceInstanceConfigValidationError) ErrorName() string {
	return "CompiledServiceInstanceConfigValidationError"
}

// Error satisfies the builtin error interface
func (e CompiledServiceInstanceConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompiledServiceInstanceConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompiledServiceInstanceConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompiledServiceInstanceConfigValidationError{}

var _CompiledServiceInstanceConfig_Env_Pattern = regexp.MustCompile("^[a-zA-Z_]+[a-zA-Z0-9_]*$")

// Validate checks the field values on CompiledJobConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CompiledJobConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompiledJobConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompiledJobConfigMultiError, or nil if none found.
func (m *CompiledJobConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *CompiledJobConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NamePrefix

	// no validation rules for ReleaseChannel

	for idx, item := range m.GetPrograms() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompiledJobConfigValidationError{
						field:  fmt.Sprintf("Programs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompiledJobConfigValidationError{
						field:  fmt.Sprintf("Programs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompiledJobConfigValidationError{
					field:  fmt.Sprintf("Programs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRuntime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompiledJobConfigValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompiledJobConfigValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompiledJobConfigValidationError{
				field:  "Runtime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRuntimeExecution()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompiledJobConfigValidationError{
					field:  "RuntimeExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompiledJobConfigValidationError{
					field:  "RuntimeExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntimeExecution()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompiledJobConfigValidationError{
				field:  "RuntimeExecution",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CompiledJobConfigMultiError(errors)
	}

	return nil
}

// CompiledJobConfigMultiError is an error wrapping multiple validation errors
// returned by CompiledJobConfig.ValidateAll() if the designated constraints
// aren't met.
type CompiledJobConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompiledJobConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompiledJobConfigMultiError) AllErrors() []error { return m }

// CompiledJobConfigValidationError is the validation error returned by
// CompiledJobConfig.Validate if the designated constraints aren't met.
type CompiledJobConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompiledJobConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompiledJobConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompiledJobConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompiledJobConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompiledJobConfigValidationError) ErrorName() string {
	return "CompiledJobConfigValidationError"
}

// Error satisfies the builtin error interface
func (e CompiledJobConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompiledJobConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompiledJobConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompiledJobConfigValidationError{}

// Validate checks the field values on MetricAnalysis_SuccessRateConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *MetricAnalysis_SuccessRateConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricAnalysis_SuccessRateConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// MetricAnalysis_SuccessRateConfigMultiError, or nil if none found.
func (m *MetricAnalysis_SuccessRateConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricAnalysis_SuccessRateConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MinThresholdPercent

	if len(errors) > 0 {
		return MetricAnalysis_SuccessRateConfigMultiError(errors)
	}

	return nil
}

// MetricAnalysis_SuccessRateConfigMultiError is an error wrapping multiple
// validation errors returned by
// MetricAnalysis_SuccessRateConfig.ValidateAll() if the designated
// constraints aren't met.
type MetricAnalysis_SuccessRateConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricAnalysis_SuccessRateConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricAnalysis_SuccessRateConfigMultiError) AllErrors() []error { return m }

// MetricAnalysis_SuccessRateConfigValidationError is the validation error
// returned by MetricAnalysis_SuccessRateConfig.Validate if the designated
// constraints aren't met.
type MetricAnalysis_SuccessRateConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricAnalysis_SuccessRateConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricAnalysis_SuccessRateConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricAnalysis_SuccessRateConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricAnalysis_SuccessRateConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricAnalysis_SuccessRateConfigValidationError) ErrorName() string {
	return "MetricAnalysis_SuccessRateConfigValidationError"
}

// Error satisfies the builtin error interface
func (e MetricAnalysis_SuccessRateConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricAnalysis_SuccessRateConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricAnalysis_SuccessRateConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricAnalysis_SuccessRateConfigValidationError{}

// Validate checks the field values on MetricAnalysis_LatencyConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricAnalysis_LatencyConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricAnalysis_LatencyConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricAnalysis_LatencyConfigMultiError, or nil if none found.
func (m *MetricAnalysis_LatencyConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricAnalysis_LatencyConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMaxLatency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricAnalysis_LatencyConfigValidationError{
					field:  "MaxLatency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricAnalysis_LatencyConfigValidationError{
					field:  "MaxLatency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxLatency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricAnalysis_LatencyConfigValidationError{
				field:  "MaxLatency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricAnalysis_LatencyConfigMultiError(errors)
	}

	return nil
}

// MetricAnalysis_LatencyConfigMultiError is an error wrapping multiple
// validation errors returned by MetricAnalysis_LatencyConfig.ValidateAll() if
// the designated constraints aren't met.
type MetricAnalysis_LatencyConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricAnalysis_LatencyConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricAnalysis_LatencyConfigMultiError) AllErrors() []error { return m }

// MetricAnalysis_LatencyConfigValidationError is the validation error returned
// by MetricAnalysis_LatencyConfig.Validate if the designated constraints
// aren't met.
type MetricAnalysis_LatencyConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricAnalysis_LatencyConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricAnalysis_LatencyConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricAnalysis_LatencyConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricAnalysis_LatencyConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricAnalysis_LatencyConfigValidationError) ErrorName() string {
	return "MetricAnalysis_LatencyConfigValidationError"
}

// Error satisfies the builtin error interface
func (e MetricAnalysis_LatencyConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricAnalysis_LatencyConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricAnalysis_LatencyConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricAnalysis_LatencyConfigValidationError{}

// Validate checks the field values on RuntimeSpecificConfig_K8SConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeSpecificConfig_K8SConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeSpecificConfig_K8SConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// RuntimeSpecificConfig_K8SConfigMultiError, or nil if none found.
func (m *RuntimeSpecificConfig_K8SConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeSpecificConfig_K8SConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceAnnotations

	if len(errors) > 0 {
		return RuntimeSpecificConfig_K8SConfigMultiError(errors)
	}

	return nil
}

// RuntimeSpecificConfig_K8SConfigMultiError is an error wrapping multiple
// validation errors returned by RuntimeSpecificConfig_K8SConfig.ValidateAll()
// if the designated constraints aren't met.
type RuntimeSpecificConfig_K8SConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeSpecificConfig_K8SConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeSpecificConfig_K8SConfigMultiError) AllErrors() []error { return m }

// RuntimeSpecificConfig_K8SConfigValidationError is the validation error
// returned by RuntimeSpecificConfig_K8SConfig.Validate if the designated
// constraints aren't met.
type RuntimeSpecificConfig_K8SConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeSpecificConfig_K8SConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeSpecificConfig_K8SConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeSpecificConfig_K8SConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeSpecificConfig_K8SConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeSpecificConfig_K8SConfigValidationError) ErrorName() string {
	return "RuntimeSpecificConfig_K8SConfigValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeSpecificConfig_K8SConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeSpecificConfig_K8SConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeSpecificConfig_K8SConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeSpecificConfig_K8SConfigValidationError{}
