// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: prodvana/service/service_manager.proto

package service

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	insights "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/insights"

	version "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/version"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = insights.Class(0)

	_ = version.Source(0)
)

// Validate checks the field values on ServiceConfigVersionReference with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceConfigVersionReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceConfigVersionReference with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ServiceConfigVersionReferenceMultiError, or nil if none found.
func (m *ServiceConfigVersionReference) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceConfigVersionReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Application

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := ServiceConfigVersionReferenceValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetServiceConfigVersion()) < 1 {
		err := ServiceConfigVersionReferenceValidationError{
			field:  "ServiceConfigVersion",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ServiceConfigVersionReferenceMultiError(errors)
	}

	return nil
}

// ServiceConfigVersionReferenceMultiError is an error wrapping multiple
// validation errors returned by ServiceConfigVersionReference.ValidateAll()
// if the designated constraints aren't met.
type ServiceConfigVersionReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceConfigVersionReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceConfigVersionReferenceMultiError) AllErrors() []error { return m }

// ServiceConfigVersionReferenceValidationError is the validation error
// returned by ServiceConfigVersionReference.Validate if the designated
// constraints aren't met.
type ServiceConfigVersionReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceConfigVersionReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceConfigVersionReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceConfigVersionReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceConfigVersionReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceConfigVersionReferenceValidationError) ErrorName() string {
	return "ServiceConfigVersionReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceConfigVersionReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceConfigVersionReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceConfigVersionReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceConfigVersionReferenceValidationError{}

// Validate checks the field values on ConfigureServiceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigureServiceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigureServiceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigureServiceReqMultiError, or nil if none found.
func (m *ConfigureServiceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigureServiceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if item == nil {
			err := ConfigureServiceReqValidationError{
				field:  fmt.Sprintf("Parameters[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigureServiceReqValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigureServiceReqValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigureServiceReqValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPerReleaseChannel() {
		_, _ = idx, item

		if item == nil {
			err := ConfigureServiceReqValidationError{
				field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigureServiceReqValidationError{
						field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigureServiceReqValidationError{
						field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigureServiceReqValidationError{
					field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TestOnlySkipRegistryCheck

	// no validation rules for Application

	// no validation rules for Source

	if all {
		switch v := interface{}(m.GetSourceMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigureServiceReqValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigureServiceReqValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigureServiceReqValidationError{
				field:  "SourceMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	oneofOneofPresent := false
	switch v := m.Oneof.(type) {
	case *ConfigureServiceReq_ServiceConfig:
		if v == nil {
			err := ConfigureServiceReqValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofOneofPresent = true

		if all {
			switch v := interface{}(m.GetServiceConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigureServiceReqValidationError{
						field:  "ServiceConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigureServiceReqValidationError{
						field:  "ServiceConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServiceConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigureServiceReqValidationError{
					field:  "ServiceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigureServiceReq_ServiceConfigVersion:
		if v == nil {
			err := ConfigureServiceReqValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofOneofPresent = true

		if all {
			switch v := interface{}(m.GetServiceConfigVersion()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigureServiceReqValidationError{
						field:  "ServiceConfigVersion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigureServiceReqValidationError{
						field:  "ServiceConfigVersion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServiceConfigVersion()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigureServiceReqValidationError{
					field:  "ServiceConfigVersion",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofOneofPresent {
		err := ConfigureServiceReqValidationError{
			field:  "Oneof",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConfigureServiceReqMultiError(errors)
	}

	return nil
}

// ConfigureServiceReqMultiError is an error wrapping multiple validation
// errors returned by ConfigureServiceReq.ValidateAll() if the designated
// constraints aren't met.
type ConfigureServiceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigureServiceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigureServiceReqMultiError) AllErrors() []error { return m }

// ConfigureServiceReqValidationError is the validation error returned by
// ConfigureServiceReq.Validate if the designated constraints aren't met.
type ConfigureServiceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigureServiceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigureServiceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigureServiceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigureServiceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigureServiceReqValidationError) ErrorName() string {
	return "ConfigureServiceReqValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigureServiceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigureServiceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigureServiceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigureServiceReqValidationError{}

// Validate checks the field values on ConfigureServiceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigureServiceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigureServiceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigureServiceRespMultiError, or nil if none found.
func (m *ConfigureServiceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigureServiceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceId

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetEfficiencyStat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigureServiceRespValidationError{
					field:  "EfficiencyStat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigureServiceRespValidationError{
					field:  "EfficiencyStat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEfficiencyStat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigureServiceRespValidationError{
				field:  "EfficiencyStat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConfigureServiceRespMultiError(errors)
	}

	return nil
}

// ConfigureServiceRespMultiError is an error wrapping multiple validation
// errors returned by ConfigureServiceResp.ValidateAll() if the designated
// constraints aren't met.
type ConfigureServiceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigureServiceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigureServiceRespMultiError) AllErrors() []error { return m }

// ConfigureServiceRespValidationError is the validation error returned by
// ConfigureServiceResp.Validate if the designated constraints aren't met.
type ConfigureServiceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigureServiceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigureServiceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigureServiceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigureServiceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigureServiceRespValidationError) ErrorName() string {
	return "ConfigureServiceRespValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigureServiceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigureServiceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigureServiceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigureServiceRespValidationError{}

// Validate checks the field values on ValidateConfigureServiceResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ValidateConfigureServiceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValidateConfigureServiceResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ValidateConfigureServiceRespMultiError, or nil if none found.
func (m *ValidateConfigureServiceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ValidateConfigureServiceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ValidateConfigureServiceRespValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ValidateConfigureServiceRespValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ValidateConfigureServiceRespValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCompiledConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ValidateConfigureServiceRespValidationError{
					field:  "CompiledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ValidateConfigureServiceRespValidationError{
					field:  "CompiledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompiledConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ValidateConfigureServiceRespValidationError{
				field:  "CompiledConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AppVersion

	for idx, item := range m.GetCompiledServiceInstanceConfigs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ValidateConfigureServiceRespValidationError{
						field:  fmt.Sprintf("CompiledServiceInstanceConfigs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ValidateConfigureServiceRespValidationError{
						field:  fmt.Sprintf("CompiledServiceInstanceConfigs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ValidateConfigureServiceRespValidationError{
					field:  fmt.Sprintf("CompiledServiceInstanceConfigs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ValidateConfigureServiceRespMultiError(errors)
	}

	return nil
}

// ValidateConfigureServiceRespMultiError is an error wrapping multiple
// validation errors returned by ValidateConfigureServiceResp.ValidateAll() if
// the designated constraints aren't met.
type ValidateConfigureServiceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidateConfigureServiceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidateConfigureServiceRespMultiError) AllErrors() []error { return m }

// ValidateConfigureServiceRespValidationError is the validation error returned
// by ValidateConfigureServiceResp.Validate if the designated constraints
// aren't met.
type ValidateConfigureServiceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidateConfigureServiceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidateConfigureServiceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidateConfigureServiceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidateConfigureServiceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidateConfigureServiceRespValidationError) ErrorName() string {
	return "ValidateConfigureServiceRespValidationError"
}

// Error satisfies the builtin error interface
func (e ValidateConfigureServiceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidateConfigureServiceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidateConfigureServiceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidateConfigureServiceRespValidationError{}

// Validate checks the field values on GetServiceConfigReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceConfigReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceConfigReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceConfigReqMultiError, or nil if none found.
func (m *GetServiceConfigReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceConfigReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GetServiceConfigReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Version

	// no validation rules for Application

	if len(errors) > 0 {
		return GetServiceConfigReqMultiError(errors)
	}

	return nil
}

// GetServiceConfigReqMultiError is an error wrapping multiple validation
// errors returned by GetServiceConfigReq.ValidateAll() if the designated
// constraints aren't met.
type GetServiceConfigReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceConfigReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceConfigReqMultiError) AllErrors() []error { return m }

// GetServiceConfigReqValidationError is the validation error returned by
// GetServiceConfigReq.Validate if the designated constraints aren't met.
type GetServiceConfigReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceConfigReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceConfigReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceConfigReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceConfigReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceConfigReqValidationError) ErrorName() string {
	return "GetServiceConfigReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceConfigReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceConfigReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceConfigReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceConfigReqValidationError{}

// Validate checks the field values on GetServiceConfigResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceConfigResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceConfigResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceConfigRespMultiError, or nil if none found.
func (m *GetServiceConfigResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceConfigResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceConfigRespValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceConfigRespValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceConfigRespValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetCompiledConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceConfigRespValidationError{
					field:  "CompiledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceConfigRespValidationError{
					field:  "CompiledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompiledConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceConfigRespValidationError{
				field:  "CompiledConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCompiledServiceInstanceConfigs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetServiceConfigRespValidationError{
						field:  fmt.Sprintf("CompiledServiceInstanceConfigs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetServiceConfigRespValidationError{
						field:  fmt.Sprintf("CompiledServiceInstanceConfigs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetServiceConfigRespValidationError{
					field:  fmt.Sprintf("CompiledServiceInstanceConfigs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetVersionMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceConfigRespValidationError{
					field:  "VersionMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceConfigRespValidationError{
					field:  "VersionMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVersionMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceConfigRespValidationError{
				field:  "VersionMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetServiceConfigRespMultiError(errors)
	}

	return nil
}

// GetServiceConfigRespMultiError is an error wrapping multiple validation
// errors returned by GetServiceConfigResp.ValidateAll() if the designated
// constraints aren't met.
type GetServiceConfigRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceConfigRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceConfigRespMultiError) AllErrors() []error { return m }

// GetServiceConfigRespValidationError is the validation error returned by
// GetServiceConfigResp.Validate if the designated constraints aren't met.
type GetServiceConfigRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceConfigRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceConfigRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceConfigRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceConfigRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceConfigRespValidationError) ErrorName() string {
	return "GetServiceConfigRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceConfigRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceConfigResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceConfigRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceConfigRespValidationError{}

// Validate checks the field values on DeleteServiceReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteServiceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteServiceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteServiceReqMultiError, or nil if none found.
func (m *DeleteServiceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteServiceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := DeleteServiceReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Application

	if len(errors) > 0 {
		return DeleteServiceReqMultiError(errors)
	}

	return nil
}

// DeleteServiceReqMultiError is an error wrapping multiple validation errors
// returned by DeleteServiceReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteServiceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteServiceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteServiceReqMultiError) AllErrors() []error { return m }

// DeleteServiceReqValidationError is the validation error returned by
// DeleteServiceReq.Validate if the designated constraints aren't met.
type DeleteServiceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteServiceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteServiceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteServiceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteServiceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteServiceReqValidationError) ErrorName() string { return "DeleteServiceReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteServiceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteServiceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteServiceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteServiceReqValidationError{}

// Validate checks the field values on DeleteServiceResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteServiceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteServiceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteServiceRespMultiError, or nil if none found.
func (m *DeleteServiceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteServiceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteServiceRespMultiError(errors)
	}

	return nil
}

// DeleteServiceRespMultiError is an error wrapping multiple validation errors
// returned by DeleteServiceResp.ValidateAll() if the designated constraints
// aren't met.
type DeleteServiceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteServiceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteServiceRespMultiError) AllErrors() []error { return m }

// DeleteServiceRespValidationError is the validation error returned by
// DeleteServiceResp.Validate if the designated constraints aren't met.
type DeleteServiceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteServiceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteServiceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteServiceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteServiceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteServiceRespValidationError) ErrorName() string {
	return "DeleteServiceRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteServiceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteServiceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteServiceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteServiceRespValidationError{}

// Validate checks the field values on ListServicesReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListServicesReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServicesReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListServicesReqMultiError, or nil if none found.
func (m *ListServicesReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServicesReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := ListServicesReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Detailed

	if len(errors) > 0 {
		return ListServicesReqMultiError(errors)
	}

	return nil
}

// ListServicesReqMultiError is an error wrapping multiple validation errors
// returned by ListServicesReq.ValidateAll() if the designated constraints
// aren't met.
type ListServicesReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServicesReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServicesReqMultiError) AllErrors() []error { return m }

// ListServicesReqValidationError is the validation error returned by
// ListServicesReq.Validate if the designated constraints aren't met.
type ListServicesReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServicesReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServicesReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServicesReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServicesReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServicesReqValidationError) ErrorName() string { return "ListServicesReqValidationError" }

// Error satisfies the builtin error interface
func (e ListServicesReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServicesReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServicesReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServicesReqValidationError{}

// Validate checks the field values on ListServicesResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListServicesResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServicesResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListServicesRespMultiError, or nil if none found.
func (m *ListServicesResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServicesResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetServices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListServicesRespValidationError{
						field:  fmt.Sprintf("Services[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListServicesRespValidationError{
						field:  fmt.Sprintf("Services[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListServicesRespValidationError{
					field:  fmt.Sprintf("Services[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListServicesRespMultiError(errors)
	}

	return nil
}

// ListServicesRespMultiError is an error wrapping multiple validation errors
// returned by ListServicesResp.ValidateAll() if the designated constraints
// aren't met.
type ListServicesRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServicesRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServicesRespMultiError) AllErrors() []error { return m }

// ListServicesRespValidationError is the validation error returned by
// ListServicesResp.Validate if the designated constraints aren't met.
type ListServicesRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServicesRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServicesRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServicesRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServicesRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServicesRespValidationError) ErrorName() string { return "ListServicesRespValidationError" }

// Error satisfies the builtin error interface
func (e ListServicesRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServicesResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServicesRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServicesRespValidationError{}

// Validate checks the field values on GetServiceReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetServiceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetServiceReqMultiError, or
// nil if none found.
func (m *GetServiceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := GetServiceReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GetServiceReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetServiceReqMultiError(errors)
	}

	return nil
}

// GetServiceReqMultiError is an error wrapping multiple validation errors
// returned by GetServiceReq.ValidateAll() if the designated constraints
// aren't met.
type GetServiceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceReqMultiError) AllErrors() []error { return m }

// GetServiceReqValidationError is the validation error returned by
// GetServiceReq.Validate if the designated constraints aren't met.
type GetServiceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceReqValidationError) ErrorName() string { return "GetServiceReqValidationError" }

// Error satisfies the builtin error interface
func (e GetServiceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceReqValidationError{}

// Validate checks the field values on GetServiceResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetServiceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetServiceRespMultiError,
// or nil if none found.
func (m *GetServiceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetService()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceRespValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceRespValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetService()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceRespValidationError{
				field:  "Service",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetServiceRespMultiError(errors)
	}

	return nil
}

// GetServiceRespMultiError is an error wrapping multiple validation errors
// returned by GetServiceResp.ValidateAll() if the designated constraints
// aren't met.
type GetServiceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceRespMultiError) AllErrors() []error { return m }

// GetServiceRespValidationError is the validation error returned by
// GetServiceResp.Validate if the designated constraints aren't met.
type GetServiceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceRespValidationError) ErrorName() string { return "GetServiceRespValidationError" }

// Error satisfies the builtin error interface
func (e GetServiceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceRespValidationError{}

// Validate checks the field values on ListServiceInstancesReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListServiceInstancesReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServiceInstancesReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListServiceInstancesReqMultiError, or nil if none found.
func (m *ListServiceInstancesReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServiceInstancesReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := ListServiceInstancesReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := ListServiceInstancesReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListServiceInstancesReqMultiError(errors)
	}

	return nil
}

// ListServiceInstancesReqMultiError is an error wrapping multiple validation
// errors returned by ListServiceInstancesReq.ValidateAll() if the designated
// constraints aren't met.
type ListServiceInstancesReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServiceInstancesReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServiceInstancesReqMultiError) AllErrors() []error { return m }

// ListServiceInstancesReqValidationError is the validation error returned by
// ListServiceInstancesReq.Validate if the designated constraints aren't met.
type ListServiceInstancesReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServiceInstancesReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServiceInstancesReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServiceInstancesReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServiceInstancesReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServiceInstancesReqValidationError) ErrorName() string {
	return "ListServiceInstancesReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListServiceInstancesReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServiceInstancesReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServiceInstancesReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServiceInstancesReqValidationError{}

// Validate checks the field values on ListServiceInstancesResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListServiceInstancesResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServiceInstancesResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListServiceInstancesRespMultiError, or nil if none found.
func (m *ListServiceInstancesResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServiceInstancesResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetServiceInstances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListServiceInstancesRespValidationError{
						field:  fmt.Sprintf("ServiceInstances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListServiceInstancesRespValidationError{
						field:  fmt.Sprintf("ServiceInstances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListServiceInstancesRespValidationError{
					field:  fmt.Sprintf("ServiceInstances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListServiceInstancesRespMultiError(errors)
	}

	return nil
}

// ListServiceInstancesRespMultiError is an error wrapping multiple validation
// errors returned by ListServiceInstancesResp.ValidateAll() if the designated
// constraints aren't met.
type ListServiceInstancesRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServiceInstancesRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServiceInstancesRespMultiError) AllErrors() []error { return m }

// ListServiceInstancesRespValidationError is the validation error returned by
// ListServiceInstancesResp.Validate if the designated constraints aren't met.
type ListServiceInstancesRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServiceInstancesRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServiceInstancesRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServiceInstancesRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServiceInstancesRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServiceInstancesRespValidationError) ErrorName() string {
	return "ListServiceInstancesRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListServiceInstancesRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServiceInstancesResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServiceInstancesRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServiceInstancesRespValidationError{}

// Validate checks the field values on GetServiceInstanceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceInstanceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceInstanceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceInstanceReqMultiError, or nil if none found.
func (m *GetServiceInstanceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceInstanceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := GetServiceInstanceReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GetServiceInstanceReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetReleaseChannel()) < 1 {
		err := GetServiceInstanceReqValidationError{
			field:  "ReleaseChannel",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetServiceInstanceReqMultiError(errors)
	}

	return nil
}

// GetServiceInstanceReqMultiError is an error wrapping multiple validation
// errors returned by GetServiceInstanceReq.ValidateAll() if the designated
// constraints aren't met.
type GetServiceInstanceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceInstanceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceInstanceReqMultiError) AllErrors() []error { return m }

// GetServiceInstanceReqValidationError is the validation error returned by
// GetServiceInstanceReq.Validate if the designated constraints aren't met.
type GetServiceInstanceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceInstanceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceInstanceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceInstanceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceInstanceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceInstanceReqValidationError) ErrorName() string {
	return "GetServiceInstanceReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceInstanceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceInstanceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceInstanceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceInstanceReqValidationError{}

// Validate checks the field values on GetServiceInstanceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceInstanceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceInstanceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceInstanceRespMultiError, or nil if none found.
func (m *GetServiceInstanceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceInstanceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetServiceInstance()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceInstanceRespValidationError{
					field:  "ServiceInstance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceInstanceRespValidationError{
					field:  "ServiceInstance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServiceInstance()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceInstanceRespValidationError{
				field:  "ServiceInstance",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetServiceInstanceRespMultiError(errors)
	}

	return nil
}

// GetServiceInstanceRespMultiError is an error wrapping multiple validation
// errors returned by GetServiceInstanceResp.ValidateAll() if the designated
// constraints aren't met.
type GetServiceInstanceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceInstanceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceInstanceRespMultiError) AllErrors() []error { return m }

// GetServiceInstanceRespValidationError is the validation error returned by
// GetServiceInstanceResp.Validate if the designated constraints aren't met.
type GetServiceInstanceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceInstanceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceInstanceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceInstanceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceInstanceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceInstanceRespValidationError) ErrorName() string {
	return "GetServiceInstanceRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceInstanceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceInstanceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceInstanceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceInstanceRespValidationError{}

// Validate checks the field values on GetServiceMetricsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceMetricsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceMetricsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceMetricsReqMultiError, or nil if none found.
func (m *GetServiceMetricsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceMetricsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := GetServiceMetricsReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GetServiceMetricsReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetStartTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceMetricsReqValidationError{
					field:  "StartTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceMetricsReqValidationError{
					field:  "StartTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceMetricsReqValidationError{
				field:  "StartTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceMetricsReqValidationError{
					field:  "EndTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceMetricsReqValidationError{
					field:  "EndTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceMetricsReqValidationError{
				field:  "EndTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IncludeCost

	if len(errors) > 0 {
		return GetServiceMetricsReqMultiError(errors)
	}

	return nil
}

// GetServiceMetricsReqMultiError is an error wrapping multiple validation
// errors returned by GetServiceMetricsReq.ValidateAll() if the designated
// constraints aren't met.
type GetServiceMetricsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceMetricsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceMetricsReqMultiError) AllErrors() []error { return m }

// GetServiceMetricsReqValidationError is the validation error returned by
// GetServiceMetricsReq.Validate if the designated constraints aren't met.
type GetServiceMetricsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceMetricsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceMetricsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceMetricsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceMetricsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceMetricsReqValidationError) ErrorName() string {
	return "GetServiceMetricsReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceMetricsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceMetricsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceMetricsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceMetricsReqValidationError{}

// Validate checks the field values on GetServiceMetricsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceMetricsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceMetricsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceMetricsRespMultiError, or nil if none found.
func (m *GetServiceMetricsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceMetricsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDeploymentMetrics()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceMetricsRespValidationError{
					field:  "DeploymentMetrics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceMetricsRespValidationError{
					field:  "DeploymentMetrics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeploymentMetrics()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceMetricsRespValidationError{
				field:  "DeploymentMetrics",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceMetricsRespValidationError{
					field:  "Cost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceMetricsRespValidationError{
					field:  "Cost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceMetricsRespValidationError{
				field:  "Cost",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetServiceMetricsRespMultiError(errors)
	}

	return nil
}

// GetServiceMetricsRespMultiError is an error wrapping multiple validation
// errors returned by GetServiceMetricsResp.ValidateAll() if the designated
// constraints aren't met.
type GetServiceMetricsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceMetricsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceMetricsRespMultiError) AllErrors() []error { return m }

// GetServiceMetricsRespValidationError is the validation error returned by
// GetServiceMetricsResp.Validate if the designated constraints aren't met.
type GetServiceMetricsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceMetricsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceMetricsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceMetricsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceMetricsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceMetricsRespValidationError) ErrorName() string {
	return "GetServiceMetricsRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceMetricsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceMetricsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceMetricsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceMetricsRespValidationError{}

// Validate checks the field values on GetServiceInsightsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceInsightsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceInsightsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceInsightsReqMultiError, or nil if none found.
func (m *GetServiceInsightsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceInsightsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := GetServiceInsightsReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GetServiceInsightsReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetServiceInsightsReqMultiError(errors)
	}

	return nil
}

// GetServiceInsightsReqMultiError is an error wrapping multiple validation
// errors returned by GetServiceInsightsReq.ValidateAll() if the designated
// constraints aren't met.
type GetServiceInsightsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceInsightsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceInsightsReqMultiError) AllErrors() []error { return m }

// GetServiceInsightsReqValidationError is the validation error returned by
// GetServiceInsightsReq.Validate if the designated constraints aren't met.
type GetServiceInsightsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceInsightsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceInsightsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceInsightsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceInsightsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceInsightsReqValidationError) ErrorName() string {
	return "GetServiceInsightsReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceInsightsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceInsightsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceInsightsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceInsightsReqValidationError{}

// Validate checks the field values on ListCommitsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListCommitsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCommitsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListCommitsReqMultiError,
// or nil if none found.
func (m *ListCommitsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCommitsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := ListCommitsReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := ListCommitsReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageToken

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListCommitsReqMultiError(errors)
	}

	return nil
}

// ListCommitsReqMultiError is an error wrapping multiple validation errors
// returned by ListCommitsReq.ValidateAll() if the designated constraints
// aren't met.
type ListCommitsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCommitsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCommitsReqMultiError) AllErrors() []error { return m }

// ListCommitsReqValidationError is the validation error returned by
// ListCommitsReq.Validate if the designated constraints aren't met.
type ListCommitsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCommitsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCommitsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCommitsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCommitsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCommitsReqValidationError) ErrorName() string { return "ListCommitsReqValidationError" }

// Error satisfies the builtin error interface
func (e ListCommitsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCommitsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCommitsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCommitsReqValidationError{}

// Validate checks the field values on ListCommitsResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListCommitsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCommitsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCommitsRespMultiError, or nil if none found.
func (m *ListCommitsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCommitsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCommits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCommitsRespValidationError{
						field:  fmt.Sprintf("Commits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCommitsRespValidationError{
						field:  fmt.Sprintf("Commits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCommitsRespValidationError{
					field:  fmt.Sprintf("Commits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListCommitsRespMultiError(errors)
	}

	return nil
}

// ListCommitsRespMultiError is an error wrapping multiple validation errors
// returned by ListCommitsResp.ValidateAll() if the designated constraints
// aren't met.
type ListCommitsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCommitsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCommitsRespMultiError) AllErrors() []error { return m }

// ListCommitsRespValidationError is the validation error returned by
// ListCommitsResp.Validate if the designated constraints aren't met.
type ListCommitsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCommitsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCommitsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCommitsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCommitsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCommitsRespValidationError) ErrorName() string { return "ListCommitsRespValidationError" }

// Error satisfies the builtin error interface
func (e ListCommitsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCommitsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCommitsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCommitsRespValidationError{}

// Validate checks the field values on GetServiceInsightsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceInsightsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceInsightsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceInsightsRespMultiError, or nil if none found.
func (m *GetServiceInsightsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceInsightsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInsights() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetServiceInsightsRespValidationError{
						field:  fmt.Sprintf("Insights[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetServiceInsightsRespValidationError{
						field:  fmt.Sprintf("Insights[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetServiceInsightsRespValidationError{
					field:  fmt.Sprintf("Insights[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetServiceInsightsRespMultiError(errors)
	}

	return nil
}

// GetServiceInsightsRespMultiError is an error wrapping multiple validation
// errors returned by GetServiceInsightsResp.ValidateAll() if the designated
// constraints aren't met.
type GetServiceInsightsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceInsightsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceInsightsRespMultiError) AllErrors() []error { return m }

// GetServiceInsightsRespValidationError is the validation error returned by
// GetServiceInsightsResp.Validate if the designated constraints aren't met.
type GetServiceInsightsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceInsightsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceInsightsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceInsightsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceInsightsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceInsightsRespValidationError) ErrorName() string {
	return "GetServiceInsightsRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceInsightsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceInsightsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceInsightsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceInsightsRespValidationError{}

// Validate checks the field values on SnoozeServiceInsightReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SnoozeServiceInsightReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SnoozeServiceInsightReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SnoozeServiceInsightReqMultiError, or nil if none found.
func (m *SnoozeServiceInsightReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SnoozeServiceInsightReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := SnoozeServiceInsightReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := SnoozeServiceInsightReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := insights.Class_name[int32(m.GetClass())]; !ok {
		err := SnoozeServiceInsightReqValidationError{
			field:  "Class",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetDuration() == nil {
		err := SnoozeServiceInsightReqValidationError{
			field:  "Duration",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if d := m.GetDuration(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = SnoozeServiceInsightReqValidationError{
				field:  "Duration",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			gt := time.Duration(0*time.Second + 0*time.Nanosecond)

			if dur <= gt {
				err := SnoozeServiceInsightReqValidationError{
					field:  "Duration",
					reason: "value must be greater than 0s",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if len(errors) > 0 {
		return SnoozeServiceInsightReqMultiError(errors)
	}

	return nil
}

// SnoozeServiceInsightReqMultiError is an error wrapping multiple validation
// errors returned by SnoozeServiceInsightReq.ValidateAll() if the designated
// constraints aren't met.
type SnoozeServiceInsightReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SnoozeServiceInsightReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SnoozeServiceInsightReqMultiError) AllErrors() []error { return m }

// SnoozeServiceInsightReqValidationError is the validation error returned by
// SnoozeServiceInsightReq.Validate if the designated constraints aren't met.
type SnoozeServiceInsightReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SnoozeServiceInsightReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SnoozeServiceInsightReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SnoozeServiceInsightReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SnoozeServiceInsightReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SnoozeServiceInsightReqValidationError) ErrorName() string {
	return "SnoozeServiceInsightReqValidationError"
}

// Error satisfies the builtin error interface
func (e SnoozeServiceInsightReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSnoozeServiceInsightReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SnoozeServiceInsightReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SnoozeServiceInsightReqValidationError{}

// Validate checks the field values on SnoozeServiceInsightResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SnoozeServiceInsightResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SnoozeServiceInsightResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SnoozeServiceInsightRespMultiError, or nil if none found.
func (m *SnoozeServiceInsightResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SnoozeServiceInsightResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SnoozeServiceInsightRespMultiError(errors)
	}

	return nil
}

// SnoozeServiceInsightRespMultiError is an error wrapping multiple validation
// errors returned by SnoozeServiceInsightResp.ValidateAll() if the designated
// constraints aren't met.
type SnoozeServiceInsightRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SnoozeServiceInsightRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SnoozeServiceInsightRespMultiError) AllErrors() []error { return m }

// SnoozeServiceInsightRespValidationError is the validation error returned by
// SnoozeServiceInsightResp.Validate if the designated constraints aren't met.
type SnoozeServiceInsightRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SnoozeServiceInsightRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SnoozeServiceInsightRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SnoozeServiceInsightRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SnoozeServiceInsightRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SnoozeServiceInsightRespValidationError) ErrorName() string {
	return "SnoozeServiceInsightRespValidationError"
}

// Error satisfies the builtin error interface
func (e SnoozeServiceInsightRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSnoozeServiceInsightResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SnoozeServiceInsightRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SnoozeServiceInsightRespValidationError{}

// Validate checks the field values on GetServiceMetadataReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceMetadataReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceMetadataReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceMetadataReqMultiError, or nil if none found.
func (m *GetServiceMetadataReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceMetadataReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := GetServiceMetadataReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GetServiceMetadataReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetServiceMetadataReqMultiError(errors)
	}

	return nil
}

// GetServiceMetadataReqMultiError is an error wrapping multiple validation
// errors returned by GetServiceMetadataReq.ValidateAll() if the designated
// constraints aren't met.
type GetServiceMetadataReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceMetadataReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceMetadataReqMultiError) AllErrors() []error { return m }

// GetServiceMetadataReqValidationError is the validation error returned by
// GetServiceMetadataReq.Validate if the designated constraints aren't met.
type GetServiceMetadataReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceMetadataReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceMetadataReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceMetadataReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceMetadataReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceMetadataReqValidationError) ErrorName() string {
	return "GetServiceMetadataReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceMetadataReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceMetadataReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceMetadataReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceMetadataReqValidationError{}

// Validate checks the field values on GetServiceMetadataResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceMetadataResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceMetadataResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceMetadataRespMultiError, or nil if none found.
func (m *GetServiceMetadataResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceMetadataResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceMetadataRespValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceMetadataRespValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceMetadataRespValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetServiceMetadataRespMultiError(errors)
	}

	return nil
}

// GetServiceMetadataRespMultiError is an error wrapping multiple validation
// errors returned by GetServiceMetadataResp.ValidateAll() if the designated
// constraints aren't met.
type GetServiceMetadataRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceMetadataRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceMetadataRespMultiError) AllErrors() []error { return m }

// GetServiceMetadataRespValidationError is the validation error returned by
// GetServiceMetadataResp.Validate if the designated constraints aren't met.
type GetServiceMetadataRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceMetadataRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceMetadataRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceMetadataRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceMetadataRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceMetadataRespValidationError) ErrorName() string {
	return "GetServiceMetadataRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceMetadataRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceMetadataResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceMetadataRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceMetadataRespValidationError{}

// Validate checks the field values on SetServiceMetadataReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetServiceMetadataReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetServiceMetadataReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetServiceMetadataReqMultiError, or nil if none found.
func (m *SetServiceMetadataReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SetServiceMetadataReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := SetServiceMetadataReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := SetServiceMetadataReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMetadata() == nil {
		err := SetServiceMetadataReqValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetServiceMetadataReqValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetServiceMetadataReqValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetServiceMetadataReqValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SetServiceMetadataReqMultiError(errors)
	}

	return nil
}

// SetServiceMetadataReqMultiError is an error wrapping multiple validation
// errors returned by SetServiceMetadataReq.ValidateAll() if the designated
// constraints aren't met.
type SetServiceMetadataReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetServiceMetadataReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetServiceMetadataReqMultiError) AllErrors() []error { return m }

// SetServiceMetadataReqValidationError is the validation error returned by
// SetServiceMetadataReq.Validate if the designated constraints aren't met.
type SetServiceMetadataReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetServiceMetadataReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetServiceMetadataReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetServiceMetadataReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetServiceMetadataReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetServiceMetadataReqValidationError) ErrorName() string {
	return "SetServiceMetadataReqValidationError"
}

// Error satisfies the builtin error interface
func (e SetServiceMetadataReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetServiceMetadataReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetServiceMetadataReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetServiceMetadataReqValidationError{}

// Validate checks the field values on SetServiceMetadataResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetServiceMetadataResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetServiceMetadataResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetServiceMetadataRespMultiError, or nil if none found.
func (m *SetServiceMetadataResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SetServiceMetadataResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetServiceMetadataRespMultiError(errors)
	}

	return nil
}

// SetServiceMetadataRespMultiError is an error wrapping multiple validation
// errors returned by SetServiceMetadataResp.ValidateAll() if the designated
// constraints aren't met.
type SetServiceMetadataRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetServiceMetadataRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetServiceMetadataRespMultiError) AllErrors() []error { return m }

// SetServiceMetadataRespValidationError is the validation error returned by
// SetServiceMetadataResp.Validate if the designated constraints aren't met.
type SetServiceMetadataRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetServiceMetadataRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetServiceMetadataRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetServiceMetadataRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetServiceMetadataRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetServiceMetadataRespValidationError) ErrorName() string {
	return "SetServiceMetadataRespValidationError"
}

// Error satisfies the builtin error interface
func (e SetServiceMetadataRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetServiceMetadataResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetServiceMetadataRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetServiceMetadataRespValidationError{}

// Validate checks the field values on ListServiceVersionsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListServiceVersionsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServiceVersionsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListServiceVersionsReqMultiError, or nil if none found.
func (m *ListServiceVersionsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServiceVersionsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := ListServiceVersionsReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := ListServiceVersionsReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageToken

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListServiceVersionsReqMultiError(errors)
	}

	return nil
}

// ListServiceVersionsReqMultiError is an error wrapping multiple validation
// errors returned by ListServiceVersionsReq.ValidateAll() if the designated
// constraints aren't met.
type ListServiceVersionsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServiceVersionsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServiceVersionsReqMultiError) AllErrors() []error { return m }

// ListServiceVersionsReqValidationError is the validation error returned by
// ListServiceVersionsReq.Validate if the designated constraints aren't met.
type ListServiceVersionsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServiceVersionsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServiceVersionsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServiceVersionsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServiceVersionsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServiceVersionsReqValidationError) ErrorName() string {
	return "ListServiceVersionsReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListServiceVersionsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServiceVersionsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServiceVersionsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServiceVersionsReqValidationError{}

// Validate checks the field values on ListServiceVersionsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListServiceVersionsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServiceVersionsResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListServiceVersionsRespMultiError, or nil if none found.
func (m *ListServiceVersionsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServiceVersionsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListServiceVersionsRespValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListServiceVersionsRespValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListServiceVersionsRespValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListServiceVersionsRespMultiError(errors)
	}

	return nil
}

// ListServiceVersionsRespMultiError is an error wrapping multiple validation
// errors returned by ListServiceVersionsResp.ValidateAll() if the designated
// constraints aren't met.
type ListServiceVersionsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServiceVersionsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServiceVersionsRespMultiError) AllErrors() []error { return m }

// ListServiceVersionsRespValidationError is the validation error returned by
// ListServiceVersionsResp.Validate if the designated constraints aren't met.
type ListServiceVersionsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServiceVersionsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServiceVersionsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServiceVersionsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServiceVersionsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServiceVersionsRespValidationError) ErrorName() string {
	return "ListServiceVersionsRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListServiceVersionsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServiceVersionsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServiceVersionsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServiceVersionsRespValidationError{}

// Validate checks the field values on ConfigureService2Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigureService2Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigureService2Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigureService2ReqMultiError, or nil if none found.
func (m *ConfigureService2Req) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigureService2Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := ConfigureService2ReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetServiceConfig() == nil {
		err := ConfigureService2ReqValidationError{
			field:  "ServiceConfig",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetServiceConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigureService2ReqValidationError{
					field:  "ServiceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigureService2ReqValidationError{
					field:  "ServiceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServiceConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigureService2ReqValidationError{
				field:  "ServiceConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Source

	if all {
		switch v := interface{}(m.GetSourceMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigureService2ReqValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigureService2ReqValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigureService2ReqValidationError{
				field:  "SourceMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConfigureService2ReqMultiError(errors)
	}

	return nil
}

// ConfigureService2ReqMultiError is an error wrapping multiple validation
// errors returned by ConfigureService2Req.ValidateAll() if the designated
// constraints aren't met.
type ConfigureService2ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigureService2ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigureService2ReqMultiError) AllErrors() []error { return m }

// ConfigureService2ReqValidationError is the validation error returned by
// ConfigureService2Req.Validate if the designated constraints aren't met.
type ConfigureService2ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigureService2ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigureService2ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigureService2ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigureService2ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigureService2ReqValidationError) ErrorName() string {
	return "ConfigureService2ReqValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigureService2ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigureService2Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigureService2ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigureService2ReqValidationError{}

// Validate checks the field values on ConfigureService2Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigureService2Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigureService2Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigureService2RespMultiError, or nil if none found.
func (m *ConfigureService2Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigureService2Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceId

	// no validation rules for ConfigVersion

	if len(errors) > 0 {
		return ConfigureService2RespMultiError(errors)
	}

	return nil
}

// ConfigureService2RespMultiError is an error wrapping multiple validation
// errors returned by ConfigureService2Resp.ValidateAll() if the designated
// constraints aren't met.
type ConfigureService2RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigureService2RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigureService2RespMultiError) AllErrors() []error { return m }

// ConfigureService2RespValidationError is the validation error returned by
// ConfigureService2Resp.Validate if the designated constraints aren't met.
type ConfigureService2RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigureService2RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigureService2RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigureService2RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigureService2RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigureService2RespValidationError) ErrorName() string {
	return "ConfigureService2RespValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigureService2RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigureService2Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigureService2RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigureService2RespValidationError{}

// Validate checks the field values on ListServiceConfigVersionsReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListServiceConfigVersionsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServiceConfigVersionsReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListServiceConfigVersionsReqMultiError, or nil if none found.
func (m *ListServiceConfigVersionsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServiceConfigVersionsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := ListServiceConfigVersionsReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := ListServiceConfigVersionsReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageToken

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListServiceConfigVersionsReqMultiError(errors)
	}

	return nil
}

// ListServiceConfigVersionsReqMultiError is an error wrapping multiple
// validation errors returned by ListServiceConfigVersionsReq.ValidateAll() if
// the designated constraints aren't met.
type ListServiceConfigVersionsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServiceConfigVersionsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServiceConfigVersionsReqMultiError) AllErrors() []error { return m }

// ListServiceConfigVersionsReqValidationError is the validation error returned
// by ListServiceConfigVersionsReq.Validate if the designated constraints
// aren't met.
type ListServiceConfigVersionsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServiceConfigVersionsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServiceConfigVersionsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServiceConfigVersionsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServiceConfigVersionsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServiceConfigVersionsReqValidationError) ErrorName() string {
	return "ListServiceConfigVersionsReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListServiceConfigVersionsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServiceConfigVersionsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServiceConfigVersionsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServiceConfigVersionsReqValidationError{}

// Validate checks the field values on ListServiceConfigVersionsResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListServiceConfigVersionsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServiceConfigVersionsResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListServiceConfigVersionsRespMultiError, or nil if none found.
func (m *ListServiceConfigVersionsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServiceConfigVersionsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListServiceConfigVersionsRespValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListServiceConfigVersionsRespValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListServiceConfigVersionsRespValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListServiceConfigVersionsRespMultiError(errors)
	}

	return nil
}

// ListServiceConfigVersionsRespMultiError is an error wrapping multiple
// validation errors returned by ListServiceConfigVersionsResp.ValidateAll()
// if the designated constraints aren't met.
type ListServiceConfigVersionsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServiceConfigVersionsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServiceConfigVersionsRespMultiError) AllErrors() []error { return m }

// ListServiceConfigVersionsRespValidationError is the validation error
// returned by ListServiceConfigVersionsResp.Validate if the designated
// constraints aren't met.
type ListServiceConfigVersionsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServiceConfigVersionsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServiceConfigVersionsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServiceConfigVersionsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServiceConfigVersionsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServiceConfigVersionsRespValidationError) ErrorName() string {
	return "ListServiceConfigVersionsRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListServiceConfigVersionsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServiceConfigVersionsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServiceConfigVersionsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServiceConfigVersionsRespValidationError{}

// Validate checks the field values on GetServiceConfig2Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceConfig2Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceConfig2Req with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceConfig2ReqMultiError, or nil if none found.
func (m *GetServiceConfig2Req) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceConfig2Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := GetServiceConfig2ReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GetServiceConfig2ReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ConfigVersion

	if len(errors) > 0 {
		return GetServiceConfig2ReqMultiError(errors)
	}

	return nil
}

// GetServiceConfig2ReqMultiError is an error wrapping multiple validation
// errors returned by GetServiceConfig2Req.ValidateAll() if the designated
// constraints aren't met.
type GetServiceConfig2ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceConfig2ReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceConfig2ReqMultiError) AllErrors() []error { return m }

// GetServiceConfig2ReqValidationError is the validation error returned by
// GetServiceConfig2Req.Validate if the designated constraints aren't met.
type GetServiceConfig2ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceConfig2ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceConfig2ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceConfig2ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceConfig2ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceConfig2ReqValidationError) ErrorName() string {
	return "GetServiceConfig2ReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceConfig2ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceConfig2Req.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceConfig2ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceConfig2ReqValidationError{}

// Validate checks the field values on GetServiceConfig2Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceConfig2Resp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceConfig2Resp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceConfig2RespMultiError, or nil if none found.
func (m *GetServiceConfig2Resp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceConfig2Resp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceConfig2RespValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceConfig2RespValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceConfig2RespValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ConfigVersion

	if all {
		switch v := interface{}(m.GetConfigVersionMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceConfig2RespValidationError{
					field:  "ConfigVersionMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceConfig2RespValidationError{
					field:  "ConfigVersionMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfigVersionMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceConfig2RespValidationError{
				field:  "ConfigVersionMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetServiceConfig2RespMultiError(errors)
	}

	return nil
}

// GetServiceConfig2RespMultiError is an error wrapping multiple validation
// errors returned by GetServiceConfig2Resp.ValidateAll() if the designated
// constraints aren't met.
type GetServiceConfig2RespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceConfig2RespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceConfig2RespMultiError) AllErrors() []error { return m }

// GetServiceConfig2RespValidationError is the validation error returned by
// GetServiceConfig2Resp.Validate if the designated constraints aren't met.
type GetServiceConfig2RespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceConfig2RespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceConfig2RespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceConfig2RespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceConfig2RespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceConfig2RespValidationError) ErrorName() string {
	return "GetServiceConfig2RespValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceConfig2RespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceConfig2Resp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceConfig2RespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceConfig2RespValidationError{}

// Validate checks the field values on ConfigureServiceReq_PerReleaseChannel
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ConfigureServiceReq_PerReleaseChannel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigureServiceReq_PerReleaseChannel
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ConfigureServiceReq_PerReleaseChannelMultiError, or nil if none found.
func (m *ConfigureServiceReq_PerReleaseChannel) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigureServiceReq_PerReleaseChannel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetReleaseChannel()) < 1 {
		err := ConfigureServiceReq_PerReleaseChannelValidationError{
			field:  "ReleaseChannel",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if item == nil {
			err := ConfigureServiceReq_PerReleaseChannelValidationError{
				field:  fmt.Sprintf("Parameters[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigureServiceReq_PerReleaseChannelValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigureServiceReq_PerReleaseChannelValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigureServiceReq_PerReleaseChannelValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ConfigureServiceReq_PerReleaseChannelMultiError(errors)
	}

	return nil
}

// ConfigureServiceReq_PerReleaseChannelMultiError is an error wrapping
// multiple validation errors returned by
// ConfigureServiceReq_PerReleaseChannel.ValidateAll() if the designated
// constraints aren't met.
type ConfigureServiceReq_PerReleaseChannelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigureServiceReq_PerReleaseChannelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigureServiceReq_PerReleaseChannelMultiError) AllErrors() []error { return m }

// ConfigureServiceReq_PerReleaseChannelValidationError is the validation error
// returned by ConfigureServiceReq_PerReleaseChannel.Validate if the
// designated constraints aren't met.
type ConfigureServiceReq_PerReleaseChannelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigureServiceReq_PerReleaseChannelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigureServiceReq_PerReleaseChannelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigureServiceReq_PerReleaseChannelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigureServiceReq_PerReleaseChannelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigureServiceReq_PerReleaseChannelValidationError) ErrorName() string {
	return "ConfigureServiceReq_PerReleaseChannelValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigureServiceReq_PerReleaseChannelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigureServiceReq_PerReleaseChannel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigureServiceReq_PerReleaseChannelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigureServiceReq_PerReleaseChannelValidationError{}

// Validate checks the field values on ListServiceVersionsResp_VersionMetadata
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListServiceVersionsResp_VersionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListServiceVersionsResp_VersionMetadata with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ListServiceVersionsResp_VersionMetadataMultiError, or nil if none found.
func (m *ListServiceVersionsResp_VersionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServiceVersionsResp_VersionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetCreationTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListServiceVersionsResp_VersionMetadataValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListServiceVersionsResp_VersionMetadataValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreationTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListServiceVersionsResp_VersionMetadataValidationError{
				field:  "CreationTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ConfigVersion

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListServiceVersionsResp_VersionMetadataValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListServiceVersionsResp_VersionMetadataValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListServiceVersionsResp_VersionMetadataValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListServiceVersionsResp_VersionMetadataMultiError(errors)
	}

	return nil
}

// ListServiceVersionsResp_VersionMetadataMultiError is an error wrapping
// multiple validation errors returned by
// ListServiceVersionsResp_VersionMetadata.ValidateAll() if the designated
// constraints aren't met.
type ListServiceVersionsResp_VersionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServiceVersionsResp_VersionMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServiceVersionsResp_VersionMetadataMultiError) AllErrors() []error { return m }

// ListServiceVersionsResp_VersionMetadataValidationError is the validation
// error returned by ListServiceVersionsResp_VersionMetadata.Validate if the
// designated constraints aren't met.
type ListServiceVersionsResp_VersionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServiceVersionsResp_VersionMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServiceVersionsResp_VersionMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServiceVersionsResp_VersionMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServiceVersionsResp_VersionMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServiceVersionsResp_VersionMetadataValidationError) ErrorName() string {
	return "ListServiceVersionsResp_VersionMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e ListServiceVersionsResp_VersionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServiceVersionsResp_VersionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServiceVersionsResp_VersionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServiceVersionsResp_VersionMetadataValidationError{}

// Validate checks the field values on
// ListServiceConfigVersionsResp_VersionMetadata with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListServiceConfigVersionsResp_VersionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListServiceConfigVersionsResp_VersionMetadata with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListServiceConfigVersionsResp_VersionMetadataMultiError, or nil if none found.
func (m *ListServiceConfigVersionsResp_VersionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServiceConfigVersionsResp_VersionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetCreationTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListServiceConfigVersionsResp_VersionMetadataValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListServiceConfigVersionsResp_VersionMetadataValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreationTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListServiceConfigVersionsResp_VersionMetadataValidationError{
				field:  "CreationTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Source

	if all {
		switch v := interface{}(m.GetSourceMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListServiceConfigVersionsResp_VersionMetadataValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListServiceConfigVersionsResp_VersionMetadataValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListServiceConfigVersionsResp_VersionMetadataValidationError{
				field:  "SourceMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListServiceConfigVersionsResp_VersionMetadataMultiError(errors)
	}

	return nil
}

// ListServiceConfigVersionsResp_VersionMetadataMultiError is an error wrapping
// multiple validation errors returned by
// ListServiceConfigVersionsResp_VersionMetadata.ValidateAll() if the
// designated constraints aren't met.
type ListServiceConfigVersionsResp_VersionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServiceConfigVersionsResp_VersionMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServiceConfigVersionsResp_VersionMetadataMultiError) AllErrors() []error { return m }

// ListServiceConfigVersionsResp_VersionMetadataValidationError is the
// validation error returned by
// ListServiceConfigVersionsResp_VersionMetadata.Validate if the designated
// constraints aren't met.
type ListServiceConfigVersionsResp_VersionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServiceConfigVersionsResp_VersionMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServiceConfigVersionsResp_VersionMetadataValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ListServiceConfigVersionsResp_VersionMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServiceConfigVersionsResp_VersionMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServiceConfigVersionsResp_VersionMetadataValidationError) ErrorName() string {
	return "ListServiceConfigVersionsResp_VersionMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e ListServiceConfigVersionsResp_VersionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServiceConfigVersionsResp_VersionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServiceConfigVersionsResp_VersionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServiceConfigVersionsResp_VersionMetadataValidationError{}
