// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: prodvana/service/service_manager.proto

package service

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	convergence "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/convergence"

	insights "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/insights"

	version "github.com/prodvana/prodvana-public/go/prodvana-sdk/proto/prodvana/version"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = convergence.ConvergenceMode(0)

	_ = insights.Class(0)

	_ = version.Source(0)
)

// Validate checks the field values on ServiceConfigVersionReference with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceConfigVersionReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceConfigVersionReference with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ServiceConfigVersionReferenceMultiError, or nil if none found.
func (m *ServiceConfigVersionReference) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceConfigVersionReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Application

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := ServiceConfigVersionReferenceValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetServiceConfigVersion()) < 1 {
		err := ServiceConfigVersionReferenceValidationError{
			field:  "ServiceConfigVersion",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ServiceConfigVersionReferenceMultiError(errors)
	}

	return nil
}

// ServiceConfigVersionReferenceMultiError is an error wrapping multiple
// validation errors returned by ServiceConfigVersionReference.ValidateAll()
// if the designated constraints aren't met.
type ServiceConfigVersionReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceConfigVersionReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceConfigVersionReferenceMultiError) AllErrors() []error { return m }

// ServiceConfigVersionReferenceValidationError is the validation error
// returned by ServiceConfigVersionReference.Validate if the designated
// constraints aren't met.
type ServiceConfigVersionReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceConfigVersionReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceConfigVersionReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceConfigVersionReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceConfigVersionReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceConfigVersionReferenceValidationError) ErrorName() string {
	return "ServiceConfigVersionReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceConfigVersionReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceConfigVersionReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceConfigVersionReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceConfigVersionReferenceValidationError{}

// Validate checks the field values on GenerateVersionNameReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateVersionNameReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateVersionNameReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateVersionNameReqMultiError, or nil if none found.
func (m *GenerateVersionNameReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateVersionNameReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := GenerateVersionNameReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GenerateVersionNameReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetServiceConfigVersion()) < 1 {
		err := GenerateVersionNameReqValidationError{
			field:  "ServiceConfigVersion",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if item == nil {
			err := GenerateVersionNameReqValidationError{
				field:  fmt.Sprintf("Parameters[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GenerateVersionNameReqValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GenerateVersionNameReqValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GenerateVersionNameReqValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPerReleaseChannel() {
		_, _ = idx, item

		if item == nil {
			err := GenerateVersionNameReqValidationError{
				field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GenerateVersionNameReqValidationError{
						field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GenerateVersionNameReqValidationError{
						field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GenerateVersionNameReqValidationError{
					field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GenerateVersionNameReqMultiError(errors)
	}

	return nil
}

// GenerateVersionNameReqMultiError is an error wrapping multiple validation
// errors returned by GenerateVersionNameReq.ValidateAll() if the designated
// constraints aren't met.
type GenerateVersionNameReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateVersionNameReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateVersionNameReqMultiError) AllErrors() []error { return m }

// GenerateVersionNameReqValidationError is the validation error returned by
// GenerateVersionNameReq.Validate if the designated constraints aren't met.
type GenerateVersionNameReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateVersionNameReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateVersionNameReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateVersionNameReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateVersionNameReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateVersionNameReqValidationError) ErrorName() string {
	return "GenerateVersionNameReqValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateVersionNameReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateVersionNameReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateVersionNameReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateVersionNameReqValidationError{}

// Validate checks the field values on GenerateVersionNameResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateVersionNameResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateVersionNameResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateVersionNameRespMultiError, or nil if none found.
func (m *GenerateVersionNameResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateVersionNameResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	if len(errors) > 0 {
		return GenerateVersionNameRespMultiError(errors)
	}

	return nil
}

// GenerateVersionNameRespMultiError is an error wrapping multiple validation
// errors returned by GenerateVersionNameResp.ValidateAll() if the designated
// constraints aren't met.
type GenerateVersionNameRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateVersionNameRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateVersionNameRespMultiError) AllErrors() []error { return m }

// GenerateVersionNameRespValidationError is the validation error returned by
// GenerateVersionNameResp.Validate if the designated constraints aren't met.
type GenerateVersionNameRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateVersionNameRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateVersionNameRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateVersionNameRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateVersionNameRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateVersionNameRespValidationError) ErrorName() string {
	return "GenerateVersionNameRespValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateVersionNameRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateVersionNameResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateVersionNameRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateVersionNameRespValidationError{}

// Validate checks the field values on ApplyParametersReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplyParametersReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyParametersReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplyParametersReqMultiError, or nil if none found.
func (m *ApplyParametersReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyParametersReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if item == nil {
			err := ApplyParametersReqValidationError{
				field:  fmt.Sprintf("Parameters[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplyParametersReqValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplyParametersReqValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplyParametersReqValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPerReleaseChannel() {
		_, _ = idx, item

		if item == nil {
			err := ApplyParametersReqValidationError{
				field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplyParametersReqValidationError{
						field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplyParametersReqValidationError{
						field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplyParametersReqValidationError{
					field:  fmt.Sprintf("PerReleaseChannel[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TestOnlySkipRegistryCheck

	// no validation rules for Application

	// no validation rules for Source

	if all {
		switch v := interface{}(m.GetSourceMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyParametersReqValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyParametersReqValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyParametersReqValidationError{
				field:  "SourceMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BundleNameOverride

	// no validation rules for HandleBundleNameDuplicate

	// no validation rules for SkipRuntimeValidation

	oneofOneofPresent := false
	switch v := m.Oneof.(type) {
	case *ApplyParametersReq_ServiceConfig:
		if v == nil {
			err := ApplyParametersReqValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofOneofPresent = true

		if all {
			switch v := interface{}(m.GetServiceConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplyParametersReqValidationError{
						field:  "ServiceConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplyParametersReqValidationError{
						field:  "ServiceConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServiceConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplyParametersReqValidationError{
					field:  "ServiceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ApplyParametersReq_ServiceConfigVersion:
		if v == nil {
			err := ApplyParametersReqValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofOneofPresent = true

		if all {
			switch v := interface{}(m.GetServiceConfigVersion()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplyParametersReqValidationError{
						field:  "ServiceConfigVersion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplyParametersReqValidationError{
						field:  "ServiceConfigVersion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServiceConfigVersion()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplyParametersReqValidationError{
					field:  "ServiceConfigVersion",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofOneofPresent {
		err := ApplyParametersReqValidationError{
			field:  "Oneof",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplyParametersReqMultiError(errors)
	}

	return nil
}

// ApplyParametersReqMultiError is an error wrapping multiple validation errors
// returned by ApplyParametersReq.ValidateAll() if the designated constraints
// aren't met.
type ApplyParametersReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyParametersReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyParametersReqMultiError) AllErrors() []error { return m }

// ApplyParametersReqValidationError is the validation error returned by
// ApplyParametersReq.Validate if the designated constraints aren't met.
type ApplyParametersReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyParametersReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyParametersReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyParametersReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyParametersReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyParametersReqValidationError) ErrorName() string {
	return "ApplyParametersReqValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyParametersReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyParametersReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyParametersReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyParametersReqValidationError{}

// Validate checks the field values on ApplyParametersResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplyParametersResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyParametersResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplyParametersRespMultiError, or nil if none found.
func (m *ApplyParametersResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyParametersResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceId

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetEfficiencyStat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyParametersRespValidationError{
					field:  "EfficiencyStat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyParametersRespValidationError{
					field:  "EfficiencyStat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEfficiencyStat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyParametersRespValidationError{
				field:  "EfficiencyStat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ApplyParametersRespMultiError(errors)
	}

	return nil
}

// ApplyParametersRespMultiError is an error wrapping multiple validation
// errors returned by ApplyParametersResp.ValidateAll() if the designated
// constraints aren't met.
type ApplyParametersRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyParametersRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyParametersRespMultiError) AllErrors() []error { return m }

// ApplyParametersRespValidationError is the validation error returned by
// ApplyParametersResp.Validate if the designated constraints aren't met.
type ApplyParametersRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyParametersRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyParametersRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyParametersRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyParametersRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyParametersRespValidationError) ErrorName() string {
	return "ApplyParametersRespValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyParametersRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyParametersResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyParametersRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyParametersRespValidationError{}

// Validate checks the field values on ValidateApplyParametersResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ValidateApplyParametersResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValidateApplyParametersResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ValidateApplyParametersRespMultiError, or nil if none found.
func (m *ValidateApplyParametersResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ValidateApplyParametersResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ValidateApplyParametersRespValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ValidateApplyParametersRespValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ValidateApplyParametersRespValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCompiledConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ValidateApplyParametersRespValidationError{
					field:  "CompiledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ValidateApplyParametersRespValidationError{
					field:  "CompiledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompiledConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ValidateApplyParametersRespValidationError{
				field:  "CompiledConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AppVersion

	for idx, item := range m.GetCompiledServiceInstanceConfigs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ValidateApplyParametersRespValidationError{
						field:  fmt.Sprintf("CompiledServiceInstanceConfigs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ValidateApplyParametersRespValidationError{
						field:  fmt.Sprintf("CompiledServiceInstanceConfigs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ValidateApplyParametersRespValidationError{
					field:  fmt.Sprintf("CompiledServiceInstanceConfigs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ValidateApplyParametersRespMultiError(errors)
	}

	return nil
}

// ValidateApplyParametersRespMultiError is an error wrapping multiple
// validation errors returned by ValidateApplyParametersResp.ValidateAll() if
// the designated constraints aren't met.
type ValidateApplyParametersRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidateApplyParametersRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidateApplyParametersRespMultiError) AllErrors() []error { return m }

// ValidateApplyParametersRespValidationError is the validation error returned
// by ValidateApplyParametersResp.Validate if the designated constraints
// aren't met.
type ValidateApplyParametersRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidateApplyParametersRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidateApplyParametersRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidateApplyParametersRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidateApplyParametersRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidateApplyParametersRespValidationError) ErrorName() string {
	return "ValidateApplyParametersRespValidationError"
}

// Error satisfies the builtin error interface
func (e ValidateApplyParametersRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidateApplyParametersResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidateApplyParametersRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidateApplyParametersRespValidationError{}

// Validate checks the field values on GetMaterializedConfigReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMaterializedConfigReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMaterializedConfigReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMaterializedConfigReqMultiError, or nil if none found.
func (m *GetMaterializedConfigReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMaterializedConfigReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GetMaterializedConfigReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Version

	// no validation rules for Application

	if len(errors) > 0 {
		return GetMaterializedConfigReqMultiError(errors)
	}

	return nil
}

// GetMaterializedConfigReqMultiError is an error wrapping multiple validation
// errors returned by GetMaterializedConfigReq.ValidateAll() if the designated
// constraints aren't met.
type GetMaterializedConfigReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMaterializedConfigReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMaterializedConfigReqMultiError) AllErrors() []error { return m }

// GetMaterializedConfigReqValidationError is the validation error returned by
// GetMaterializedConfigReq.Validate if the designated constraints aren't met.
type GetMaterializedConfigReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMaterializedConfigReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMaterializedConfigReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMaterializedConfigReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMaterializedConfigReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMaterializedConfigReqValidationError) ErrorName() string {
	return "GetMaterializedConfigReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetMaterializedConfigReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMaterializedConfigReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMaterializedConfigReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMaterializedConfigReqValidationError{}

// Validate checks the field values on GetMaterializedConfigResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMaterializedConfigResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMaterializedConfigResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMaterializedConfigRespMultiError, or nil if none found.
func (m *GetMaterializedConfigResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMaterializedConfigResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMaterializedConfigRespValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMaterializedConfigRespValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMaterializedConfigRespValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetCompiledConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMaterializedConfigRespValidationError{
					field:  "CompiledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMaterializedConfigRespValidationError{
					field:  "CompiledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompiledConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMaterializedConfigRespValidationError{
				field:  "CompiledConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCompiledServiceInstanceConfigs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetMaterializedConfigRespValidationError{
						field:  fmt.Sprintf("CompiledServiceInstanceConfigs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetMaterializedConfigRespValidationError{
						field:  fmt.Sprintf("CompiledServiceInstanceConfigs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetMaterializedConfigRespValidationError{
					field:  fmt.Sprintf("CompiledServiceInstanceConfigs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetVersionMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMaterializedConfigRespValidationError{
					field:  "VersionMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMaterializedConfigRespValidationError{
					field:  "VersionMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVersionMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMaterializedConfigRespValidationError{
				field:  "VersionMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetMaterializedConfigRespMultiError(errors)
	}

	return nil
}

// GetMaterializedConfigRespMultiError is an error wrapping multiple validation
// errors returned by GetMaterializedConfigResp.ValidateAll() if the
// designated constraints aren't met.
type GetMaterializedConfigRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMaterializedConfigRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMaterializedConfigRespMultiError) AllErrors() []error { return m }

// GetMaterializedConfigRespValidationError is the validation error returned by
// GetMaterializedConfigResp.Validate if the designated constraints aren't met.
type GetMaterializedConfigRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMaterializedConfigRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMaterializedConfigRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMaterializedConfigRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMaterializedConfigRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMaterializedConfigRespValidationError) ErrorName() string {
	return "GetMaterializedConfigRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetMaterializedConfigRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMaterializedConfigResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMaterializedConfigRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMaterializedConfigRespValidationError{}

// Validate checks the field values on DeleteServiceReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteServiceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteServiceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteServiceReqMultiError, or nil if none found.
func (m *DeleteServiceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteServiceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := DeleteServiceReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Application

	if len(errors) > 0 {
		return DeleteServiceReqMultiError(errors)
	}

	return nil
}

// DeleteServiceReqMultiError is an error wrapping multiple validation errors
// returned by DeleteServiceReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteServiceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteServiceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteServiceReqMultiError) AllErrors() []error { return m }

// DeleteServiceReqValidationError is the validation error returned by
// DeleteServiceReq.Validate if the designated constraints aren't met.
type DeleteServiceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteServiceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteServiceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteServiceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteServiceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteServiceReqValidationError) ErrorName() string { return "DeleteServiceReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteServiceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteServiceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteServiceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteServiceReqValidationError{}

// Validate checks the field values on DeleteServiceResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteServiceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteServiceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteServiceRespMultiError, or nil if none found.
func (m *DeleteServiceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteServiceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteServiceRespMultiError(errors)
	}

	return nil
}

// DeleteServiceRespMultiError is an error wrapping multiple validation errors
// returned by DeleteServiceResp.ValidateAll() if the designated constraints
// aren't met.
type DeleteServiceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteServiceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteServiceRespMultiError) AllErrors() []error { return m }

// DeleteServiceRespValidationError is the validation error returned by
// DeleteServiceResp.Validate if the designated constraints aren't met.
type DeleteServiceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteServiceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteServiceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteServiceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteServiceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteServiceRespValidationError) ErrorName() string {
	return "DeleteServiceRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteServiceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteServiceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteServiceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteServiceRespValidationError{}

// Validate checks the field values on ListServicesReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListServicesReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServicesReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListServicesReqMultiError, or nil if none found.
func (m *ListServicesReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServicesReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := ListServicesReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Detailed

	if len(errors) > 0 {
		return ListServicesReqMultiError(errors)
	}

	return nil
}

// ListServicesReqMultiError is an error wrapping multiple validation errors
// returned by ListServicesReq.ValidateAll() if the designated constraints
// aren't met.
type ListServicesReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServicesReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServicesReqMultiError) AllErrors() []error { return m }

// ListServicesReqValidationError is the validation error returned by
// ListServicesReq.Validate if the designated constraints aren't met.
type ListServicesReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServicesReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServicesReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServicesReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServicesReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServicesReqValidationError) ErrorName() string { return "ListServicesReqValidationError" }

// Error satisfies the builtin error interface
func (e ListServicesReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServicesReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServicesReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServicesReqValidationError{}

// Validate checks the field values on ListServicesResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListServicesResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServicesResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListServicesRespMultiError, or nil if none found.
func (m *ListServicesResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServicesResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetServices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListServicesRespValidationError{
						field:  fmt.Sprintf("Services[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListServicesRespValidationError{
						field:  fmt.Sprintf("Services[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListServicesRespValidationError{
					field:  fmt.Sprintf("Services[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListServicesRespMultiError(errors)
	}

	return nil
}

// ListServicesRespMultiError is an error wrapping multiple validation errors
// returned by ListServicesResp.ValidateAll() if the designated constraints
// aren't met.
type ListServicesRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServicesRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServicesRespMultiError) AllErrors() []error { return m }

// ListServicesRespValidationError is the validation error returned by
// ListServicesResp.Validate if the designated constraints aren't met.
type ListServicesRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServicesRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServicesRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServicesRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServicesRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServicesRespValidationError) ErrorName() string { return "ListServicesRespValidationError" }

// Error satisfies the builtin error interface
func (e ListServicesRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServicesResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServicesRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServicesRespValidationError{}

// Validate checks the field values on GetServiceReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetServiceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetServiceReqMultiError, or
// nil if none found.
func (m *GetServiceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := GetServiceReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GetServiceReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetServiceReqMultiError(errors)
	}

	return nil
}

// GetServiceReqMultiError is an error wrapping multiple validation errors
// returned by GetServiceReq.ValidateAll() if the designated constraints
// aren't met.
type GetServiceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceReqMultiError) AllErrors() []error { return m }

// GetServiceReqValidationError is the validation error returned by
// GetServiceReq.Validate if the designated constraints aren't met.
type GetServiceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceReqValidationError) ErrorName() string { return "GetServiceReqValidationError" }

// Error satisfies the builtin error interface
func (e GetServiceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceReqValidationError{}

// Validate checks the field values on GetServiceResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetServiceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetServiceRespMultiError,
// or nil if none found.
func (m *GetServiceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetService()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceRespValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceRespValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetService()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceRespValidationError{
				field:  "Service",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetServiceRespMultiError(errors)
	}

	return nil
}

// GetServiceRespMultiError is an error wrapping multiple validation errors
// returned by GetServiceResp.ValidateAll() if the designated constraints
// aren't met.
type GetServiceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceRespMultiError) AllErrors() []error { return m }

// GetServiceRespValidationError is the validation error returned by
// GetServiceResp.Validate if the designated constraints aren't met.
type GetServiceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceRespValidationError) ErrorName() string { return "GetServiceRespValidationError" }

// Error satisfies the builtin error interface
func (e GetServiceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceRespValidationError{}

// Validate checks the field values on ListServiceInstancesReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListServiceInstancesReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServiceInstancesReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListServiceInstancesReqMultiError, or nil if none found.
func (m *ListServiceInstancesReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServiceInstancesReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := ListServiceInstancesReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := ListServiceInstancesReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListServiceInstancesReqMultiError(errors)
	}

	return nil
}

// ListServiceInstancesReqMultiError is an error wrapping multiple validation
// errors returned by ListServiceInstancesReq.ValidateAll() if the designated
// constraints aren't met.
type ListServiceInstancesReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServiceInstancesReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServiceInstancesReqMultiError) AllErrors() []error { return m }

// ListServiceInstancesReqValidationError is the validation error returned by
// ListServiceInstancesReq.Validate if the designated constraints aren't met.
type ListServiceInstancesReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServiceInstancesReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServiceInstancesReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServiceInstancesReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServiceInstancesReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServiceInstancesReqValidationError) ErrorName() string {
	return "ListServiceInstancesReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListServiceInstancesReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServiceInstancesReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServiceInstancesReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServiceInstancesReqValidationError{}

// Validate checks the field values on ListServiceInstancesResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListServiceInstancesResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServiceInstancesResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListServiceInstancesRespMultiError, or nil if none found.
func (m *ListServiceInstancesResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServiceInstancesResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetServiceInstances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListServiceInstancesRespValidationError{
						field:  fmt.Sprintf("ServiceInstances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListServiceInstancesRespValidationError{
						field:  fmt.Sprintf("ServiceInstances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListServiceInstancesRespValidationError{
					field:  fmt.Sprintf("ServiceInstances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListServiceInstancesRespMultiError(errors)
	}

	return nil
}

// ListServiceInstancesRespMultiError is an error wrapping multiple validation
// errors returned by ListServiceInstancesResp.ValidateAll() if the designated
// constraints aren't met.
type ListServiceInstancesRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServiceInstancesRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServiceInstancesRespMultiError) AllErrors() []error { return m }

// ListServiceInstancesRespValidationError is the validation error returned by
// ListServiceInstancesResp.Validate if the designated constraints aren't met.
type ListServiceInstancesRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServiceInstancesRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServiceInstancesRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServiceInstancesRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServiceInstancesRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServiceInstancesRespValidationError) ErrorName() string {
	return "ListServiceInstancesRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListServiceInstancesRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServiceInstancesResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServiceInstancesRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServiceInstancesRespValidationError{}

// Validate checks the field values on GetServiceInstanceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceInstanceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceInstanceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceInstanceReqMultiError, or nil if none found.
func (m *GetServiceInstanceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceInstanceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := GetServiceInstanceReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GetServiceInstanceReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetReleaseChannel()) < 1 {
		err := GetServiceInstanceReqValidationError{
			field:  "ReleaseChannel",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetServiceInstanceReqMultiError(errors)
	}

	return nil
}

// GetServiceInstanceReqMultiError is an error wrapping multiple validation
// errors returned by GetServiceInstanceReq.ValidateAll() if the designated
// constraints aren't met.
type GetServiceInstanceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceInstanceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceInstanceReqMultiError) AllErrors() []error { return m }

// GetServiceInstanceReqValidationError is the validation error returned by
// GetServiceInstanceReq.Validate if the designated constraints aren't met.
type GetServiceInstanceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceInstanceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceInstanceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceInstanceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceInstanceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceInstanceReqValidationError) ErrorName() string {
	return "GetServiceInstanceReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceInstanceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceInstanceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceInstanceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceInstanceReqValidationError{}

// Validate checks the field values on GetServiceInstanceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceInstanceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceInstanceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceInstanceRespMultiError, or nil if none found.
func (m *GetServiceInstanceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceInstanceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetServiceInstance()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceInstanceRespValidationError{
					field:  "ServiceInstance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceInstanceRespValidationError{
					field:  "ServiceInstance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServiceInstance()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceInstanceRespValidationError{
				field:  "ServiceInstance",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetServiceInstanceRespMultiError(errors)
	}

	return nil
}

// GetServiceInstanceRespMultiError is an error wrapping multiple validation
// errors returned by GetServiceInstanceResp.ValidateAll() if the designated
// constraints aren't met.
type GetServiceInstanceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceInstanceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceInstanceRespMultiError) AllErrors() []error { return m }

// GetServiceInstanceRespValidationError is the validation error returned by
// GetServiceInstanceResp.Validate if the designated constraints aren't met.
type GetServiceInstanceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceInstanceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceInstanceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceInstanceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceInstanceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceInstanceRespValidationError) ErrorName() string {
	return "GetServiceInstanceRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceInstanceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceInstanceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceInstanceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceInstanceRespValidationError{}

// Validate checks the field values on GetServiceMetricsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceMetricsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceMetricsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceMetricsReqMultiError, or nil if none found.
func (m *GetServiceMetricsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceMetricsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := GetServiceMetricsReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GetServiceMetricsReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetStartTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceMetricsReqValidationError{
					field:  "StartTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceMetricsReqValidationError{
					field:  "StartTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceMetricsReqValidationError{
				field:  "StartTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceMetricsReqValidationError{
					field:  "EndTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceMetricsReqValidationError{
					field:  "EndTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceMetricsReqValidationError{
				field:  "EndTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IncludeCost

	if len(errors) > 0 {
		return GetServiceMetricsReqMultiError(errors)
	}

	return nil
}

// GetServiceMetricsReqMultiError is an error wrapping multiple validation
// errors returned by GetServiceMetricsReq.ValidateAll() if the designated
// constraints aren't met.
type GetServiceMetricsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceMetricsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceMetricsReqMultiError) AllErrors() []error { return m }

// GetServiceMetricsReqValidationError is the validation error returned by
// GetServiceMetricsReq.Validate if the designated constraints aren't met.
type GetServiceMetricsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceMetricsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceMetricsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceMetricsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceMetricsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceMetricsReqValidationError) ErrorName() string {
	return "GetServiceMetricsReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceMetricsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceMetricsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceMetricsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceMetricsReqValidationError{}

// Validate checks the field values on GetServiceMetricsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceMetricsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceMetricsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceMetricsRespMultiError, or nil if none found.
func (m *GetServiceMetricsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceMetricsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDeploymentMetrics()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceMetricsRespValidationError{
					field:  "DeploymentMetrics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceMetricsRespValidationError{
					field:  "DeploymentMetrics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeploymentMetrics()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceMetricsRespValidationError{
				field:  "DeploymentMetrics",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceMetricsRespValidationError{
					field:  "Cost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceMetricsRespValidationError{
					field:  "Cost",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceMetricsRespValidationError{
				field:  "Cost",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetServiceMetricsRespMultiError(errors)
	}

	return nil
}

// GetServiceMetricsRespMultiError is an error wrapping multiple validation
// errors returned by GetServiceMetricsResp.ValidateAll() if the designated
// constraints aren't met.
type GetServiceMetricsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceMetricsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceMetricsRespMultiError) AllErrors() []error { return m }

// GetServiceMetricsRespValidationError is the validation error returned by
// GetServiceMetricsResp.Validate if the designated constraints aren't met.
type GetServiceMetricsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceMetricsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceMetricsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceMetricsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceMetricsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceMetricsRespValidationError) ErrorName() string {
	return "GetServiceMetricsRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceMetricsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceMetricsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceMetricsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceMetricsRespValidationError{}

// Validate checks the field values on GetServiceInsightsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceInsightsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceInsightsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceInsightsReqMultiError, or nil if none found.
func (m *GetServiceInsightsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceInsightsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := GetServiceInsightsReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GetServiceInsightsReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetServiceInsightsReqMultiError(errors)
	}

	return nil
}

// GetServiceInsightsReqMultiError is an error wrapping multiple validation
// errors returned by GetServiceInsightsReq.ValidateAll() if the designated
// constraints aren't met.
type GetServiceInsightsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceInsightsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceInsightsReqMultiError) AllErrors() []error { return m }

// GetServiceInsightsReqValidationError is the validation error returned by
// GetServiceInsightsReq.Validate if the designated constraints aren't met.
type GetServiceInsightsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceInsightsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceInsightsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceInsightsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceInsightsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceInsightsReqValidationError) ErrorName() string {
	return "GetServiceInsightsReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceInsightsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceInsightsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceInsightsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceInsightsReqValidationError{}

// Validate checks the field values on ListCommitsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListCommitsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCommitsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListCommitsReqMultiError,
// or nil if none found.
func (m *ListCommitsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCommitsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := ListCommitsReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := ListCommitsReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageToken

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListCommitsReqMultiError(errors)
	}

	return nil
}

// ListCommitsReqMultiError is an error wrapping multiple validation errors
// returned by ListCommitsReq.ValidateAll() if the designated constraints
// aren't met.
type ListCommitsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCommitsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCommitsReqMultiError) AllErrors() []error { return m }

// ListCommitsReqValidationError is the validation error returned by
// ListCommitsReq.Validate if the designated constraints aren't met.
type ListCommitsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCommitsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCommitsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCommitsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCommitsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCommitsReqValidationError) ErrorName() string { return "ListCommitsReqValidationError" }

// Error satisfies the builtin error interface
func (e ListCommitsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCommitsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCommitsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCommitsReqValidationError{}

// Validate checks the field values on ListCommitsResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListCommitsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCommitsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCommitsRespMultiError, or nil if none found.
func (m *ListCommitsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCommitsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCommits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCommitsRespValidationError{
						field:  fmt.Sprintf("Commits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCommitsRespValidationError{
						field:  fmt.Sprintf("Commits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCommitsRespValidationError{
					field:  fmt.Sprintf("Commits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListCommitsRespMultiError(errors)
	}

	return nil
}

// ListCommitsRespMultiError is an error wrapping multiple validation errors
// returned by ListCommitsResp.ValidateAll() if the designated constraints
// aren't met.
type ListCommitsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCommitsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCommitsRespMultiError) AllErrors() []error { return m }

// ListCommitsRespValidationError is the validation error returned by
// ListCommitsResp.Validate if the designated constraints aren't met.
type ListCommitsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCommitsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCommitsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCommitsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCommitsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCommitsRespValidationError) ErrorName() string { return "ListCommitsRespValidationError" }

// Error satisfies the builtin error interface
func (e ListCommitsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCommitsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCommitsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCommitsRespValidationError{}

// Validate checks the field values on GetServiceInsightsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceInsightsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceInsightsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceInsightsRespMultiError, or nil if none found.
func (m *GetServiceInsightsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceInsightsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInsights() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetServiceInsightsRespValidationError{
						field:  fmt.Sprintf("Insights[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetServiceInsightsRespValidationError{
						field:  fmt.Sprintf("Insights[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetServiceInsightsRespValidationError{
					field:  fmt.Sprintf("Insights[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetServiceInsightsRespMultiError(errors)
	}

	return nil
}

// GetServiceInsightsRespMultiError is an error wrapping multiple validation
// errors returned by GetServiceInsightsResp.ValidateAll() if the designated
// constraints aren't met.
type GetServiceInsightsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceInsightsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceInsightsRespMultiError) AllErrors() []error { return m }

// GetServiceInsightsRespValidationError is the validation error returned by
// GetServiceInsightsResp.Validate if the designated constraints aren't met.
type GetServiceInsightsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceInsightsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceInsightsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceInsightsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceInsightsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceInsightsRespValidationError) ErrorName() string {
	return "GetServiceInsightsRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceInsightsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceInsightsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceInsightsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceInsightsRespValidationError{}

// Validate checks the field values on SnoozeServiceInsightReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SnoozeServiceInsightReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SnoozeServiceInsightReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SnoozeServiceInsightReqMultiError, or nil if none found.
func (m *SnoozeServiceInsightReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SnoozeServiceInsightReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := SnoozeServiceInsightReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := SnoozeServiceInsightReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := insights.Class_name[int32(m.GetClass())]; !ok {
		err := SnoozeServiceInsightReqValidationError{
			field:  "Class",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetDuration() == nil {
		err := SnoozeServiceInsightReqValidationError{
			field:  "Duration",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if d := m.GetDuration(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = SnoozeServiceInsightReqValidationError{
				field:  "Duration",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			gt := time.Duration(0*time.Second + 0*time.Nanosecond)

			if dur <= gt {
				err := SnoozeServiceInsightReqValidationError{
					field:  "Duration",
					reason: "value must be greater than 0s",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if len(errors) > 0 {
		return SnoozeServiceInsightReqMultiError(errors)
	}

	return nil
}

// SnoozeServiceInsightReqMultiError is an error wrapping multiple validation
// errors returned by SnoozeServiceInsightReq.ValidateAll() if the designated
// constraints aren't met.
type SnoozeServiceInsightReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SnoozeServiceInsightReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SnoozeServiceInsightReqMultiError) AllErrors() []error { return m }

// SnoozeServiceInsightReqValidationError is the validation error returned by
// SnoozeServiceInsightReq.Validate if the designated constraints aren't met.
type SnoozeServiceInsightReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SnoozeServiceInsightReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SnoozeServiceInsightReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SnoozeServiceInsightReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SnoozeServiceInsightReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SnoozeServiceInsightReqValidationError) ErrorName() string {
	return "SnoozeServiceInsightReqValidationError"
}

// Error satisfies the builtin error interface
func (e SnoozeServiceInsightReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSnoozeServiceInsightReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SnoozeServiceInsightReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SnoozeServiceInsightReqValidationError{}

// Validate checks the field values on SnoozeServiceInsightResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SnoozeServiceInsightResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SnoozeServiceInsightResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SnoozeServiceInsightRespMultiError, or nil if none found.
func (m *SnoozeServiceInsightResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SnoozeServiceInsightResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SnoozeServiceInsightRespMultiError(errors)
	}

	return nil
}

// SnoozeServiceInsightRespMultiError is an error wrapping multiple validation
// errors returned by SnoozeServiceInsightResp.ValidateAll() if the designated
// constraints aren't met.
type SnoozeServiceInsightRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SnoozeServiceInsightRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SnoozeServiceInsightRespMultiError) AllErrors() []error { return m }

// SnoozeServiceInsightRespValidationError is the validation error returned by
// SnoozeServiceInsightResp.Validate if the designated constraints aren't met.
type SnoozeServiceInsightRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SnoozeServiceInsightRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SnoozeServiceInsightRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SnoozeServiceInsightRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SnoozeServiceInsightRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SnoozeServiceInsightRespValidationError) ErrorName() string {
	return "SnoozeServiceInsightRespValidationError"
}

// Error satisfies the builtin error interface
func (e SnoozeServiceInsightRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSnoozeServiceInsightResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SnoozeServiceInsightRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SnoozeServiceInsightRespValidationError{}

// Validate checks the field values on GetServiceMetadataReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceMetadataReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceMetadataReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceMetadataReqMultiError, or nil if none found.
func (m *GetServiceMetadataReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceMetadataReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := GetServiceMetadataReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GetServiceMetadataReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetServiceMetadataReqMultiError(errors)
	}

	return nil
}

// GetServiceMetadataReqMultiError is an error wrapping multiple validation
// errors returned by GetServiceMetadataReq.ValidateAll() if the designated
// constraints aren't met.
type GetServiceMetadataReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceMetadataReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceMetadataReqMultiError) AllErrors() []error { return m }

// GetServiceMetadataReqValidationError is the validation error returned by
// GetServiceMetadataReq.Validate if the designated constraints aren't met.
type GetServiceMetadataReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceMetadataReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceMetadataReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceMetadataReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceMetadataReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceMetadataReqValidationError) ErrorName() string {
	return "GetServiceMetadataReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceMetadataReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceMetadataReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceMetadataReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceMetadataReqValidationError{}

// Validate checks the field values on GetServiceMetadataResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceMetadataResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceMetadataResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceMetadataRespMultiError, or nil if none found.
func (m *GetServiceMetadataResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceMetadataResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceMetadataRespValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceMetadataRespValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceMetadataRespValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetServiceMetadataRespMultiError(errors)
	}

	return nil
}

// GetServiceMetadataRespMultiError is an error wrapping multiple validation
// errors returned by GetServiceMetadataResp.ValidateAll() if the designated
// constraints aren't met.
type GetServiceMetadataRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceMetadataRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceMetadataRespMultiError) AllErrors() []error { return m }

// GetServiceMetadataRespValidationError is the validation error returned by
// GetServiceMetadataResp.Validate if the designated constraints aren't met.
type GetServiceMetadataRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceMetadataRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceMetadataRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceMetadataRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceMetadataRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceMetadataRespValidationError) ErrorName() string {
	return "GetServiceMetadataRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceMetadataRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceMetadataResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceMetadataRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceMetadataRespValidationError{}

// Validate checks the field values on SetServiceMetadataReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetServiceMetadataReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetServiceMetadataReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetServiceMetadataReqMultiError, or nil if none found.
func (m *SetServiceMetadataReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SetServiceMetadataReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := SetServiceMetadataReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := SetServiceMetadataReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMetadata() == nil {
		err := SetServiceMetadataReqValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetServiceMetadataReqValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetServiceMetadataReqValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetServiceMetadataReqValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SetServiceMetadataReqMultiError(errors)
	}

	return nil
}

// SetServiceMetadataReqMultiError is an error wrapping multiple validation
// errors returned by SetServiceMetadataReq.ValidateAll() if the designated
// constraints aren't met.
type SetServiceMetadataReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetServiceMetadataReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetServiceMetadataReqMultiError) AllErrors() []error { return m }

// SetServiceMetadataReqValidationError is the validation error returned by
// SetServiceMetadataReq.Validate if the designated constraints aren't met.
type SetServiceMetadataReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetServiceMetadataReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetServiceMetadataReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetServiceMetadataReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetServiceMetadataReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetServiceMetadataReqValidationError) ErrorName() string {
	return "SetServiceMetadataReqValidationError"
}

// Error satisfies the builtin error interface
func (e SetServiceMetadataReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetServiceMetadataReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetServiceMetadataReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetServiceMetadataReqValidationError{}

// Validate checks the field values on SetServiceMetadataResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetServiceMetadataResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetServiceMetadataResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetServiceMetadataRespMultiError, or nil if none found.
func (m *SetServiceMetadataResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SetServiceMetadataResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetServiceMetadataRespMultiError(errors)
	}

	return nil
}

// SetServiceMetadataRespMultiError is an error wrapping multiple validation
// errors returned by SetServiceMetadataResp.ValidateAll() if the designated
// constraints aren't met.
type SetServiceMetadataRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetServiceMetadataRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetServiceMetadataRespMultiError) AllErrors() []error { return m }

// SetServiceMetadataRespValidationError is the validation error returned by
// SetServiceMetadataResp.Validate if the designated constraints aren't met.
type SetServiceMetadataRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetServiceMetadataRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetServiceMetadataRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetServiceMetadataRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetServiceMetadataRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetServiceMetadataRespValidationError) ErrorName() string {
	return "SetServiceMetadataRespValidationError"
}

// Error satisfies the builtin error interface
func (e SetServiceMetadataRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetServiceMetadataResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetServiceMetadataRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetServiceMetadataRespValidationError{}

// Validate checks the field values on SetServiceConvergenceModeReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetServiceConvergenceModeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetServiceConvergenceModeReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetServiceConvergenceModeReqMultiError, or nil if none found.
func (m *SetServiceConvergenceModeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SetServiceConvergenceModeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := SetServiceConvergenceModeReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := SetServiceConvergenceModeReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ConvergenceMode

	if len(errors) > 0 {
		return SetServiceConvergenceModeReqMultiError(errors)
	}

	return nil
}

// SetServiceConvergenceModeReqMultiError is an error wrapping multiple
// validation errors returned by SetServiceConvergenceModeReq.ValidateAll() if
// the designated constraints aren't met.
type SetServiceConvergenceModeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetServiceConvergenceModeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetServiceConvergenceModeReqMultiError) AllErrors() []error { return m }

// SetServiceConvergenceModeReqValidationError is the validation error returned
// by SetServiceConvergenceModeReq.Validate if the designated constraints
// aren't met.
type SetServiceConvergenceModeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetServiceConvergenceModeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetServiceConvergenceModeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetServiceConvergenceModeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetServiceConvergenceModeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetServiceConvergenceModeReqValidationError) ErrorName() string {
	return "SetServiceConvergenceModeReqValidationError"
}

// Error satisfies the builtin error interface
func (e SetServiceConvergenceModeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetServiceConvergenceModeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetServiceConvergenceModeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetServiceConvergenceModeReqValidationError{}

// Validate checks the field values on SetServiceConvergenceModeResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetServiceConvergenceModeResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetServiceConvergenceModeResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SetServiceConvergenceModeRespMultiError, or nil if none found.
func (m *SetServiceConvergenceModeResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SetServiceConvergenceModeResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetServiceConvergenceModeRespMultiError(errors)
	}

	return nil
}

// SetServiceConvergenceModeRespMultiError is an error wrapping multiple
// validation errors returned by SetServiceConvergenceModeResp.ValidateAll()
// if the designated constraints aren't met.
type SetServiceConvergenceModeRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetServiceConvergenceModeRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetServiceConvergenceModeRespMultiError) AllErrors() []error { return m }

// SetServiceConvergenceModeRespValidationError is the validation error
// returned by SetServiceConvergenceModeResp.Validate if the designated
// constraints aren't met.
type SetServiceConvergenceModeRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetServiceConvergenceModeRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetServiceConvergenceModeRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetServiceConvergenceModeRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetServiceConvergenceModeRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetServiceConvergenceModeRespValidationError) ErrorName() string {
	return "SetServiceConvergenceModeRespValidationError"
}

// Error satisfies the builtin error interface
func (e SetServiceConvergenceModeRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetServiceConvergenceModeResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetServiceConvergenceModeRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetServiceConvergenceModeRespValidationError{}

// Validate checks the field values on ListMaterializedConfigVersionsReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListMaterializedConfigVersionsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMaterializedConfigVersionsReq
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListMaterializedConfigVersionsReqMultiError, or nil if none found.
func (m *ListMaterializedConfigVersionsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMaterializedConfigVersionsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := ListMaterializedConfigVersionsReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := ListMaterializedConfigVersionsReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageToken

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListMaterializedConfigVersionsReqMultiError(errors)
	}

	return nil
}

// ListMaterializedConfigVersionsReqMultiError is an error wrapping multiple
// validation errors returned by
// ListMaterializedConfigVersionsReq.ValidateAll() if the designated
// constraints aren't met.
type ListMaterializedConfigVersionsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMaterializedConfigVersionsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMaterializedConfigVersionsReqMultiError) AllErrors() []error { return m }

// ListMaterializedConfigVersionsReqValidationError is the validation error
// returned by ListMaterializedConfigVersionsReq.Validate if the designated
// constraints aren't met.
type ListMaterializedConfigVersionsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMaterializedConfigVersionsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMaterializedConfigVersionsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMaterializedConfigVersionsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMaterializedConfigVersionsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMaterializedConfigVersionsReqValidationError) ErrorName() string {
	return "ListMaterializedConfigVersionsReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListMaterializedConfigVersionsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMaterializedConfigVersionsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMaterializedConfigVersionsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMaterializedConfigVersionsReqValidationError{}

// Validate checks the field values on ListMaterializedConfigVersionsResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListMaterializedConfigVersionsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMaterializedConfigVersionsResp
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListMaterializedConfigVersionsRespMultiError, or nil if none found.
func (m *ListMaterializedConfigVersionsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMaterializedConfigVersionsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMaterializedConfigVersionsRespValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMaterializedConfigVersionsRespValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMaterializedConfigVersionsRespValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListMaterializedConfigVersionsRespMultiError(errors)
	}

	return nil
}

// ListMaterializedConfigVersionsRespMultiError is an error wrapping multiple
// validation errors returned by
// ListMaterializedConfigVersionsResp.ValidateAll() if the designated
// constraints aren't met.
type ListMaterializedConfigVersionsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMaterializedConfigVersionsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMaterializedConfigVersionsRespMultiError) AllErrors() []error { return m }

// ListMaterializedConfigVersionsRespValidationError is the validation error
// returned by ListMaterializedConfigVersionsResp.Validate if the designated
// constraints aren't met.
type ListMaterializedConfigVersionsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMaterializedConfigVersionsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMaterializedConfigVersionsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMaterializedConfigVersionsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMaterializedConfigVersionsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMaterializedConfigVersionsRespValidationError) ErrorName() string {
	return "ListMaterializedConfigVersionsRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListMaterializedConfigVersionsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMaterializedConfigVersionsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMaterializedConfigVersionsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMaterializedConfigVersionsRespValidationError{}

// Validate checks the field values on ConfigureServiceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigureServiceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigureServiceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigureServiceReqMultiError, or nil if none found.
func (m *ConfigureServiceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigureServiceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := ConfigureServiceReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetServiceConfig() == nil {
		err := ConfigureServiceReqValidationError{
			field:  "ServiceConfig",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetServiceConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigureServiceReqValidationError{
					field:  "ServiceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigureServiceReqValidationError{
					field:  "ServiceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServiceConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigureServiceReqValidationError{
				field:  "ServiceConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Source

	if all {
		switch v := interface{}(m.GetSourceMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigureServiceReqValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigureServiceReqValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigureServiceReqValidationError{
				field:  "SourceMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BundleNameOverride

	// no validation rules for SkipRuntimeValidation

	if len(errors) > 0 {
		return ConfigureServiceReqMultiError(errors)
	}

	return nil
}

// ConfigureServiceReqMultiError is an error wrapping multiple validation
// errors returned by ConfigureServiceReq.ValidateAll() if the designated
// constraints aren't met.
type ConfigureServiceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigureServiceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigureServiceReqMultiError) AllErrors() []error { return m }

// ConfigureServiceReqValidationError is the validation error returned by
// ConfigureServiceReq.Validate if the designated constraints aren't met.
type ConfigureServiceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigureServiceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigureServiceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigureServiceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigureServiceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigureServiceReqValidationError) ErrorName() string {
	return "ConfigureServiceReqValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigureServiceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigureServiceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigureServiceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigureServiceReqValidationError{}

// Validate checks the field values on ConfigureServiceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigureServiceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigureServiceResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigureServiceRespMultiError, or nil if none found.
func (m *ConfigureServiceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigureServiceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceId

	// no validation rules for ConfigVersion

	if len(errors) > 0 {
		return ConfigureServiceRespMultiError(errors)
	}

	return nil
}

// ConfigureServiceRespMultiError is an error wrapping multiple validation
// errors returned by ConfigureServiceResp.ValidateAll() if the designated
// constraints aren't met.
type ConfigureServiceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigureServiceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigureServiceRespMultiError) AllErrors() []error { return m }

// ConfigureServiceRespValidationError is the validation error returned by
// ConfigureServiceResp.Validate if the designated constraints aren't met.
type ConfigureServiceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigureServiceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigureServiceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigureServiceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigureServiceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigureServiceRespValidationError) ErrorName() string {
	return "ConfigureServiceRespValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigureServiceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigureServiceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigureServiceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigureServiceRespValidationError{}

// Validate checks the field values on ValidateConfigureServiceResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ValidateConfigureServiceResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValidateConfigureServiceResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ValidateConfigureServiceRespMultiError, or nil if none found.
func (m *ValidateConfigureServiceResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ValidateConfigureServiceResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInputConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ValidateConfigureServiceRespValidationError{
					field:  "InputConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ValidateConfigureServiceRespValidationError{
					field:  "InputConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInputConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ValidateConfigureServiceRespValidationError{
				field:  "InputConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCompiledConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ValidateConfigureServiceRespValidationError{
					field:  "CompiledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ValidateConfigureServiceRespValidationError{
					field:  "CompiledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompiledConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ValidateConfigureServiceRespValidationError{
				field:  "CompiledConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ValidateConfigureServiceRespMultiError(errors)
	}

	return nil
}

// ValidateConfigureServiceRespMultiError is an error wrapping multiple
// validation errors returned by ValidateConfigureServiceResp.ValidateAll() if
// the designated constraints aren't met.
type ValidateConfigureServiceRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidateConfigureServiceRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidateConfigureServiceRespMultiError) AllErrors() []error { return m }

// ValidateConfigureServiceRespValidationError is the validation error returned
// by ValidateConfigureServiceResp.Validate if the designated constraints
// aren't met.
type ValidateConfigureServiceRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidateConfigureServiceRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidateConfigureServiceRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidateConfigureServiceRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidateConfigureServiceRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidateConfigureServiceRespValidationError) ErrorName() string {
	return "ValidateConfigureServiceRespValidationError"
}

// Error satisfies the builtin error interface
func (e ValidateConfigureServiceRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidateConfigureServiceResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidateConfigureServiceRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidateConfigureServiceRespValidationError{}

// Validate checks the field values on ListServiceConfigVersionsReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListServiceConfigVersionsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServiceConfigVersionsReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListServiceConfigVersionsReqMultiError, or nil if none found.
func (m *ListServiceConfigVersionsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServiceConfigVersionsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := ListServiceConfigVersionsReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := ListServiceConfigVersionsReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageToken

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListServiceConfigVersionsReqMultiError(errors)
	}

	return nil
}

// ListServiceConfigVersionsReqMultiError is an error wrapping multiple
// validation errors returned by ListServiceConfigVersionsReq.ValidateAll() if
// the designated constraints aren't met.
type ListServiceConfigVersionsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServiceConfigVersionsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServiceConfigVersionsReqMultiError) AllErrors() []error { return m }

// ListServiceConfigVersionsReqValidationError is the validation error returned
// by ListServiceConfigVersionsReq.Validate if the designated constraints
// aren't met.
type ListServiceConfigVersionsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServiceConfigVersionsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServiceConfigVersionsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServiceConfigVersionsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServiceConfigVersionsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServiceConfigVersionsReqValidationError) ErrorName() string {
	return "ListServiceConfigVersionsReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListServiceConfigVersionsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServiceConfigVersionsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServiceConfigVersionsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServiceConfigVersionsReqValidationError{}

// Validate checks the field values on ListServiceConfigVersionsResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListServiceConfigVersionsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServiceConfigVersionsResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListServiceConfigVersionsRespMultiError, or nil if none found.
func (m *ListServiceConfigVersionsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServiceConfigVersionsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListServiceConfigVersionsRespValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListServiceConfigVersionsRespValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListServiceConfigVersionsRespValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListServiceConfigVersionsRespMultiError(errors)
	}

	return nil
}

// ListServiceConfigVersionsRespMultiError is an error wrapping multiple
// validation errors returned by ListServiceConfigVersionsResp.ValidateAll()
// if the designated constraints aren't met.
type ListServiceConfigVersionsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServiceConfigVersionsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServiceConfigVersionsRespMultiError) AllErrors() []error { return m }

// ListServiceConfigVersionsRespValidationError is the validation error
// returned by ListServiceConfigVersionsResp.Validate if the designated
// constraints aren't met.
type ListServiceConfigVersionsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServiceConfigVersionsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServiceConfigVersionsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServiceConfigVersionsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServiceConfigVersionsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServiceConfigVersionsRespValidationError) ErrorName() string {
	return "ListServiceConfigVersionsRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListServiceConfigVersionsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServiceConfigVersionsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServiceConfigVersionsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServiceConfigVersionsRespValidationError{}

// Validate checks the field values on GetServiceConfigReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceConfigReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceConfigReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceConfigReqMultiError, or nil if none found.
func (m *GetServiceConfigReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceConfigReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApplication()) < 1 {
		err := GetServiceConfigReqValidationError{
			field:  "Application",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetService()) < 1 {
		err := GetServiceConfigReqValidationError{
			field:  "Service",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ConfigVersion

	if len(errors) > 0 {
		return GetServiceConfigReqMultiError(errors)
	}

	return nil
}

// GetServiceConfigReqMultiError is an error wrapping multiple validation
// errors returned by GetServiceConfigReq.ValidateAll() if the designated
// constraints aren't met.
type GetServiceConfigReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceConfigReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceConfigReqMultiError) AllErrors() []error { return m }

// GetServiceConfigReqValidationError is the validation error returned by
// GetServiceConfigReq.Validate if the designated constraints aren't met.
type GetServiceConfigReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceConfigReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceConfigReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceConfigReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceConfigReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceConfigReqValidationError) ErrorName() string {
	return "GetServiceConfigReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceConfigReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceConfigReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceConfigReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceConfigReqValidationError{}

// Validate checks the field values on GetServiceConfigResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetServiceConfigResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServiceConfigResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServiceConfigRespMultiError, or nil if none found.
func (m *GetServiceConfigResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServiceConfigResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceConfigRespValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceConfigRespValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceConfigRespValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInputConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceConfigRespValidationError{
					field:  "InputConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceConfigRespValidationError{
					field:  "InputConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInputConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceConfigRespValidationError{
				field:  "InputConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCompiledConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceConfigRespValidationError{
					field:  "CompiledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceConfigRespValidationError{
					field:  "CompiledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompiledConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceConfigRespValidationError{
				field:  "CompiledConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ConfigVersion

	if all {
		switch v := interface{}(m.GetConfigVersionMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetServiceConfigRespValidationError{
					field:  "ConfigVersionMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetServiceConfigRespValidationError{
					field:  "ConfigVersionMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfigVersionMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceConfigRespValidationError{
				field:  "ConfigVersionMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetServiceConfigRespMultiError(errors)
	}

	return nil
}

// GetServiceConfigRespMultiError is an error wrapping multiple validation
// errors returned by GetServiceConfigResp.ValidateAll() if the designated
// constraints aren't met.
type GetServiceConfigRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServiceConfigRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServiceConfigRespMultiError) AllErrors() []error { return m }

// GetServiceConfigRespValidationError is the validation error returned by
// GetServiceConfigResp.Validate if the designated constraints aren't met.
type GetServiceConfigRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceConfigRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceConfigRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceConfigRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceConfigRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceConfigRespValidationError) ErrorName() string {
	return "GetServiceConfigRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceConfigRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceConfigResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceConfigRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceConfigRespValidationError{}

// Validate checks the field values on ApplyParametersReq_PerReleaseChannel
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ApplyParametersReq_PerReleaseChannel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyParametersReq_PerReleaseChannel
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ApplyParametersReq_PerReleaseChannelMultiError, or nil if none found.
func (m *ApplyParametersReq_PerReleaseChannel) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyParametersReq_PerReleaseChannel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetReleaseChannel()) < 1 {
		err := ApplyParametersReq_PerReleaseChannelValidationError{
			field:  "ReleaseChannel",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if item == nil {
			err := ApplyParametersReq_PerReleaseChannelValidationError{
				field:  fmt.Sprintf("Parameters[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplyParametersReq_PerReleaseChannelValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplyParametersReq_PerReleaseChannelValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplyParametersReq_PerReleaseChannelValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ApplyParametersReq_PerReleaseChannelMultiError(errors)
	}

	return nil
}

// ApplyParametersReq_PerReleaseChannelMultiError is an error wrapping multiple
// validation errors returned by
// ApplyParametersReq_PerReleaseChannel.ValidateAll() if the designated
// constraints aren't met.
type ApplyParametersReq_PerReleaseChannelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyParametersReq_PerReleaseChannelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyParametersReq_PerReleaseChannelMultiError) AllErrors() []error { return m }

// ApplyParametersReq_PerReleaseChannelValidationError is the validation error
// returned by ApplyParametersReq_PerReleaseChannel.Validate if the designated
// constraints aren't met.
type ApplyParametersReq_PerReleaseChannelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyParametersReq_PerReleaseChannelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyParametersReq_PerReleaseChannelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyParametersReq_PerReleaseChannelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyParametersReq_PerReleaseChannelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyParametersReq_PerReleaseChannelValidationError) ErrorName() string {
	return "ApplyParametersReq_PerReleaseChannelValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyParametersReq_PerReleaseChannelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyParametersReq_PerReleaseChannel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyParametersReq_PerReleaseChannelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyParametersReq_PerReleaseChannelValidationError{}

// Validate checks the field values on
// ListMaterializedConfigVersionsResp_VersionMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListMaterializedConfigVersionsResp_VersionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListMaterializedConfigVersionsResp_VersionMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// ListMaterializedConfigVersionsResp_VersionMetadataMultiError, or nil if
// none found.
func (m *ListMaterializedConfigVersionsResp_VersionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMaterializedConfigVersionsResp_VersionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetCreationTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListMaterializedConfigVersionsResp_VersionMetadataValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListMaterializedConfigVersionsResp_VersionMetadataValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreationTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListMaterializedConfigVersionsResp_VersionMetadataValidationError{
				field:  "CreationTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ConfigVersion

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMaterializedConfigVersionsResp_VersionMetadataValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMaterializedConfigVersionsResp_VersionMetadataValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMaterializedConfigVersionsResp_VersionMetadataValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetParameterValues()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListMaterializedConfigVersionsResp_VersionMetadataValidationError{
					field:  "ParameterValues",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListMaterializedConfigVersionsResp_VersionMetadataValidationError{
					field:  "ParameterValues",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameterValues()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListMaterializedConfigVersionsResp_VersionMetadataValidationError{
				field:  "ParameterValues",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Source

	if all {
		switch v := interface{}(m.GetSourceMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListMaterializedConfigVersionsResp_VersionMetadataValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListMaterializedConfigVersionsResp_VersionMetadataValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListMaterializedConfigVersionsResp_VersionMetadataValidationError{
				field:  "SourceMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListMaterializedConfigVersionsResp_VersionMetadataMultiError(errors)
	}

	return nil
}

// ListMaterializedConfigVersionsResp_VersionMetadataMultiError is an error
// wrapping multiple validation errors returned by
// ListMaterializedConfigVersionsResp_VersionMetadata.ValidateAll() if the
// designated constraints aren't met.
type ListMaterializedConfigVersionsResp_VersionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMaterializedConfigVersionsResp_VersionMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMaterializedConfigVersionsResp_VersionMetadataMultiError) AllErrors() []error { return m }

// ListMaterializedConfigVersionsResp_VersionMetadataValidationError is the
// validation error returned by
// ListMaterializedConfigVersionsResp_VersionMetadata.Validate if the
// designated constraints aren't met.
type ListMaterializedConfigVersionsResp_VersionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMaterializedConfigVersionsResp_VersionMetadataValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e ListMaterializedConfigVersionsResp_VersionMetadataValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ListMaterializedConfigVersionsResp_VersionMetadataValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e ListMaterializedConfigVersionsResp_VersionMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMaterializedConfigVersionsResp_VersionMetadataValidationError) ErrorName() string {
	return "ListMaterializedConfigVersionsResp_VersionMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e ListMaterializedConfigVersionsResp_VersionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMaterializedConfigVersionsResp_VersionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMaterializedConfigVersionsResp_VersionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMaterializedConfigVersionsResp_VersionMetadataValidationError{}

// Validate checks the field values on
// ListServiceConfigVersionsResp_VersionMetadata with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListServiceConfigVersionsResp_VersionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListServiceConfigVersionsResp_VersionMetadata with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListServiceConfigVersionsResp_VersionMetadataMultiError, or nil if none found.
func (m *ListServiceConfigVersionsResp_VersionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServiceConfigVersionsResp_VersionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetCreationTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListServiceConfigVersionsResp_VersionMetadataValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListServiceConfigVersionsResp_VersionMetadataValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreationTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListServiceConfigVersionsResp_VersionMetadataValidationError{
				field:  "CreationTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Source

	if all {
		switch v := interface{}(m.GetSourceMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListServiceConfigVersionsResp_VersionMetadataValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListServiceConfigVersionsResp_VersionMetadataValidationError{
					field:  "SourceMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListServiceConfigVersionsResp_VersionMetadataValidationError{
				field:  "SourceMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListServiceConfigVersionsResp_VersionMetadataMultiError(errors)
	}

	return nil
}

// ListServiceConfigVersionsResp_VersionMetadataMultiError is an error wrapping
// multiple validation errors returned by
// ListServiceConfigVersionsResp_VersionMetadata.ValidateAll() if the
// designated constraints aren't met.
type ListServiceConfigVersionsResp_VersionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServiceConfigVersionsResp_VersionMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServiceConfigVersionsResp_VersionMetadataMultiError) AllErrors() []error { return m }

// ListServiceConfigVersionsResp_VersionMetadataValidationError is the
// validation error returned by
// ListServiceConfigVersionsResp_VersionMetadata.Validate if the designated
// constraints aren't met.
type ListServiceConfigVersionsResp_VersionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServiceConfigVersionsResp_VersionMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServiceConfigVersionsResp_VersionMetadataValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ListServiceConfigVersionsResp_VersionMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServiceConfigVersionsResp_VersionMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServiceConfigVersionsResp_VersionMetadataValidationError) ErrorName() string {
	return "ListServiceConfigVersionsResp_VersionMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e ListServiceConfigVersionsResp_VersionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServiceConfigVersionsResp_VersionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServiceConfigVersionsResp_VersionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServiceConfigVersionsResp_VersionMetadataValidationError{}
